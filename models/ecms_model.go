// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// EcmsModel Exempt certificate
// Example: {"businessTypeId":2,"companyId":456,"country":"US","createdUserId":0,"customerCode":"ABA","exemptCertId":123,"exemptCertReviewStatusId":"Pending","exemptCertStatusId":"Active","exemptCertTypeId":"SingleUse","exemptReasonId":"A","exemptReasonOtherDescription":"test","modifiedDate":"0001-01-01T00:00:00","modifiedUserId":0,"region":"CA","regionsApplicable":"CA"}
//
// swagger:model EcmsModel
type EcmsModel struct {

	// Address line 1
	// Max Length: 50
	// Min Length: 0
	Address1 *string `json:"address1,omitempty"`

	// Address line 2
	// Max Length: 50
	// Min Length: 0
	Address2 *string `json:"address2,omitempty"`

	// Address line 3
	// Max Length: 50
	// Min Length: 0
	Address3 *string `json:"address3,omitempty"`

	// If the certificate record was synced from an AvaTax Certs account(as opposed to being entered in ECMS directly),
	// the unique AvaTax Certs identifier for the certificate record. Usually same as the Id of a Certificate.
	// Max Length: 10
	// Min Length: 0
	AvaCertID *string `json:"avaCertId,omitempty"`

	// Business type the customer belongs to.
	// Example: 2
	// Required: true
	BusinessTypeID *int32 `json:"businessTypeId"`

	// Other description for this business type
	// Max Length: 255
	// Min Length: 0
	BusinessTypeOtherDescription *string `json:"businessTypeOtherDescription,omitempty"`

	// City
	// Max Length: 50
	// Min Length: 0
	City *string `json:"city,omitempty"`

	// Company ID
	// Example: 456
	// Required: true
	CompanyID *int32 `json:"companyId"`

	// Name or ISO 3166 code identifying the country.
	//
	// This field supports many different country identifiers:
	//  * Two character ISO 3166 codes
	//  * Three character ISO 3166 codes
	//  * Fully spelled out names of the country in ISO supported languages
	//  * Common alternative spellings for many countries
	//
	// For a full list of all supported codes and names, please see the Definitions API `ListCountries`.
	// Example: US
	// Required: true
	Country *string `json:"country"`

	// Name or ISO 3166 code identifying the country that issued this ECMS certificate.
	//
	// This field supports many different country identifiers:
	//  * Two character ISO 3166 codes
	//  * Three character ISO 3166 codes
	//  * Fully spelled out names of the country in ISO supported languages
	//  * Common alternative spellings for many countries
	//
	// For a full list of all supported codes and names, please see the Definitions API `ListCountries`.
	// Required: true
	CountryIssued *string `json:"countryIssued"`

	// Date when this exempt certificate was created
	// Format: date-time
	CreatedDate strfmt.DateTime `json:"createdDate,omitempty"`

	// User that creates the certificate
	// Example: 0
	CreatedUserID int32 `json:"createdUserId,omitempty"`

	// Customer code
	// Example: ABA
	// Required: true
	// Max Length: 50
	// Min Length: 0
	CustomerCode *string `json:"customerCode"`

	// Customer name
	// Max Length: 100
	// Min Length: 0
	CustomerName *string `json:"customerName,omitempty"`

	// Exempt Cert details
	Details []*EcmsDetailModel `json:"details"`

	// Document Reference Number, in the case of single-use exemption certificates, the DocumentCode or PurchaseOrderNo to which the certificate should apply.
	// Max Length: 50
	// Min Length: 0
	DocumentRefNo *string `json:"documentRefNo,omitempty"`

	// Effective date for this exempt certificate
	// Format: date-time
	EffectiveDate strfmt.DateTime `json:"effectiveDate,omitempty"`

	// The calc_id associated with a certificate in CertCapture.
	// Example: 123
	// Required: true
	ExemptCertID *int32 `json:"exemptCertId"`

	// Review status for this exempt certificate
	// Example: Pending
	// Enum: [Pending Accepted Rejected]
	ExemptCertReviewStatusID string `json:"exemptCertReviewStatusId,omitempty"`

	// Status for this exempt certificate
	// Example: Inactive
	// Required: true
	// Enum: [Inactive Active Expired Revoked]
	ExemptCertStatusID *string `json:"exemptCertStatusId"`

	// The type of exemption certificate. Permitted values are: Blanket and Single.
	// Example: Blanket
	// Required: true
	// Enum: [Blanket SingleUse]
	ExemptCertTypeID *string `json:"exemptCertTypeId"`

	// Exempt reason associated with the certificate, coded by CustomerUsageType.
	// Example: A - Federal Government.
	// Example: A
	// Max Length: 1
	// Min Length: 0
	ExemptReasonID *string `json:"exemptReasonId,omitempty"`

	// Other description for exempt reason i.e. Populated on if exemptReasonId is 'L' - Other.
	// Example: test
	// Max Length: 255
	// Min Length: 0
	ExemptReasonOtherDescription *string `json:"exemptReasonOtherDescription,omitempty"`

	// When this exempt certificate will expire
	// Format: date-time
	ExpiryDate strfmt.DateTime `json:"expiryDate,omitempty"`

	// Date when last transaction with this exempt certificate happened
	// Read Only: true
	// Format: date-time
	LastTransactionDate strfmt.DateTime `json:"lastTransactionDate,omitempty"`

	// Date when this exempt certificate was modified
	// Example: 0001-01-01T00:00:00
	// Format: date-time
	ModifiedDate strfmt.DateTime `json:"modifiedDate,omitempty"`

	// Who modified this exempt certificate
	// Example: 0
	ModifiedUserID int32 `json:"modifiedUserId,omitempty"`

	// Postal code / zip code
	// Max Length: 10
	// Min Length: 0
	PostalCode *string `json:"postalCode,omitempty"`

	// Name or ISO 3166 code identifying the region within the country.
	//
	// This field supports many different region identifiers:
	//  * Two and three character ISO 3166 region codes
	//  * Fully spelled out names of the region in ISO supported languages
	//  * Common alternative spellings for many regions
	//
	// For a full list of all supported codes and names, please see the Definitions API `ListRegions`.
	// Example: CA
	// Required: true
	Region *string `json:"region"`

	// A list of applicable regions for this exempt certificate.
	//
	// To list more than one applicable region, separate the list of region codes with commas.
	// Example: CA
	// Required: true
	// Max Length: 200
	// Min Length: 0
	RegionsApplicable *string `json:"regionsApplicable"`
}

// Validate validates this ecms model
func (m *EcmsModel) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAddress3(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAvaCertID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBusinessTypeID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBusinessTypeOtherDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCompanyID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCountryIssued(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomerCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomerName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDocumentRefNo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEffectiveDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExemptCertID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExemptCertReviewStatusID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExemptCertStatusID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExemptCertTypeID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExemptReasonID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExemptReasonOtherDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExpiryDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastTransactionDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateModifiedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRegion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRegionsApplicable(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EcmsModel) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(m.Address1) { // not required
		return nil
	}

	if err := validate.MinLength("address1", "body", *m.Address1, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("address1", "body", *m.Address1, 50); err != nil {
		return err
	}

	return nil
}

func (m *EcmsModel) validateAddress2(formats strfmt.Registry) error {
	if swag.IsZero(m.Address2) { // not required
		return nil
	}

	if err := validate.MinLength("address2", "body", *m.Address2, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("address2", "body", *m.Address2, 50); err != nil {
		return err
	}

	return nil
}

func (m *EcmsModel) validateAddress3(formats strfmt.Registry) error {
	if swag.IsZero(m.Address3) { // not required
		return nil
	}

	if err := validate.MinLength("address3", "body", *m.Address3, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("address3", "body", *m.Address3, 50); err != nil {
		return err
	}

	return nil
}

func (m *EcmsModel) validateAvaCertID(formats strfmt.Registry) error {
	if swag.IsZero(m.AvaCertID) { // not required
		return nil
	}

	if err := validate.MinLength("avaCertId", "body", *m.AvaCertID, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("avaCertId", "body", *m.AvaCertID, 10); err != nil {
		return err
	}

	return nil
}

func (m *EcmsModel) validateBusinessTypeID(formats strfmt.Registry) error {

	if err := validate.Required("businessTypeId", "body", m.BusinessTypeID); err != nil {
		return err
	}

	return nil
}

func (m *EcmsModel) validateBusinessTypeOtherDescription(formats strfmt.Registry) error {
	if swag.IsZero(m.BusinessTypeOtherDescription) { // not required
		return nil
	}

	if err := validate.MinLength("businessTypeOtherDescription", "body", *m.BusinessTypeOtherDescription, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("businessTypeOtherDescription", "body", *m.BusinessTypeOtherDescription, 255); err != nil {
		return err
	}

	return nil
}

func (m *EcmsModel) validateCity(formats strfmt.Registry) error {
	if swag.IsZero(m.City) { // not required
		return nil
	}

	if err := validate.MinLength("city", "body", *m.City, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("city", "body", *m.City, 50); err != nil {
		return err
	}

	return nil
}

func (m *EcmsModel) validateCompanyID(formats strfmt.Registry) error {

	if err := validate.Required("companyId", "body", m.CompanyID); err != nil {
		return err
	}

	return nil
}

func (m *EcmsModel) validateCountry(formats strfmt.Registry) error {

	if err := validate.Required("country", "body", m.Country); err != nil {
		return err
	}

	return nil
}

func (m *EcmsModel) validateCountryIssued(formats strfmt.Registry) error {

	if err := validate.Required("countryIssued", "body", m.CountryIssued); err != nil {
		return err
	}

	return nil
}

func (m *EcmsModel) validateCreatedDate(formats strfmt.Registry) error {
	if swag.IsZero(m.CreatedDate) { // not required
		return nil
	}

	if err := validate.FormatOf("createdDate", "body", "date-time", m.CreatedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *EcmsModel) validateCustomerCode(formats strfmt.Registry) error {

	if err := validate.Required("customerCode", "body", m.CustomerCode); err != nil {
		return err
	}

	if err := validate.MinLength("customerCode", "body", *m.CustomerCode, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("customerCode", "body", *m.CustomerCode, 50); err != nil {
		return err
	}

	return nil
}

func (m *EcmsModel) validateCustomerName(formats strfmt.Registry) error {
	if swag.IsZero(m.CustomerName) { // not required
		return nil
	}

	if err := validate.MinLength("customerName", "body", *m.CustomerName, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("customerName", "body", *m.CustomerName, 100); err != nil {
		return err
	}

	return nil
}

func (m *EcmsModel) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(m.Details) { // not required
		return nil
	}

	for i := 0; i < len(m.Details); i++ {
		if swag.IsZero(m.Details[i]) { // not required
			continue
		}

		if m.Details[i] != nil {
			if err := m.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EcmsModel) validateDocumentRefNo(formats strfmt.Registry) error {
	if swag.IsZero(m.DocumentRefNo) { // not required
		return nil
	}

	if err := validate.MinLength("documentRefNo", "body", *m.DocumentRefNo, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("documentRefNo", "body", *m.DocumentRefNo, 50); err != nil {
		return err
	}

	return nil
}

func (m *EcmsModel) validateEffectiveDate(formats strfmt.Registry) error {
	if swag.IsZero(m.EffectiveDate) { // not required
		return nil
	}

	if err := validate.FormatOf("effectiveDate", "body", "date-time", m.EffectiveDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *EcmsModel) validateExemptCertID(formats strfmt.Registry) error {

	if err := validate.Required("exemptCertId", "body", m.ExemptCertID); err != nil {
		return err
	}

	return nil
}

var ecmsModelTypeExemptCertReviewStatusIDPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Pending","Accepted","Rejected"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		ecmsModelTypeExemptCertReviewStatusIDPropEnum = append(ecmsModelTypeExemptCertReviewStatusIDPropEnum, v)
	}
}

const (

	// EcmsModelExemptCertReviewStatusIDPending captures enum value "Pending"
	EcmsModelExemptCertReviewStatusIDPending string = "Pending"

	// EcmsModelExemptCertReviewStatusIDAccepted captures enum value "Accepted"
	EcmsModelExemptCertReviewStatusIDAccepted string = "Accepted"

	// EcmsModelExemptCertReviewStatusIDRejected captures enum value "Rejected"
	EcmsModelExemptCertReviewStatusIDRejected string = "Rejected"
)

// prop value enum
func (m *EcmsModel) validateExemptCertReviewStatusIDEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, ecmsModelTypeExemptCertReviewStatusIDPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *EcmsModel) validateExemptCertReviewStatusID(formats strfmt.Registry) error {
	if swag.IsZero(m.ExemptCertReviewStatusID) { // not required
		return nil
	}

	// value enum
	if err := m.validateExemptCertReviewStatusIDEnum("exemptCertReviewStatusId", "body", m.ExemptCertReviewStatusID); err != nil {
		return err
	}

	return nil
}

var ecmsModelTypeExemptCertStatusIDPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Inactive","Active","Expired","Revoked"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		ecmsModelTypeExemptCertStatusIDPropEnum = append(ecmsModelTypeExemptCertStatusIDPropEnum, v)
	}
}

const (

	// EcmsModelExemptCertStatusIDInactive captures enum value "Inactive"
	EcmsModelExemptCertStatusIDInactive string = "Inactive"

	// EcmsModelExemptCertStatusIDActive captures enum value "Active"
	EcmsModelExemptCertStatusIDActive string = "Active"

	// EcmsModelExemptCertStatusIDExpired captures enum value "Expired"
	EcmsModelExemptCertStatusIDExpired string = "Expired"

	// EcmsModelExemptCertStatusIDRevoked captures enum value "Revoked"
	EcmsModelExemptCertStatusIDRevoked string = "Revoked"
)

// prop value enum
func (m *EcmsModel) validateExemptCertStatusIDEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, ecmsModelTypeExemptCertStatusIDPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *EcmsModel) validateExemptCertStatusID(formats strfmt.Registry) error {

	if err := validate.Required("exemptCertStatusId", "body", m.ExemptCertStatusID); err != nil {
		return err
	}

	// value enum
	if err := m.validateExemptCertStatusIDEnum("exemptCertStatusId", "body", *m.ExemptCertStatusID); err != nil {
		return err
	}

	return nil
}

var ecmsModelTypeExemptCertTypeIDPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Blanket","SingleUse"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		ecmsModelTypeExemptCertTypeIDPropEnum = append(ecmsModelTypeExemptCertTypeIDPropEnum, v)
	}
}

const (

	// EcmsModelExemptCertTypeIDBlanket captures enum value "Blanket"
	EcmsModelExemptCertTypeIDBlanket string = "Blanket"

	// EcmsModelExemptCertTypeIDSingleUse captures enum value "SingleUse"
	EcmsModelExemptCertTypeIDSingleUse string = "SingleUse"
)

// prop value enum
func (m *EcmsModel) validateExemptCertTypeIDEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, ecmsModelTypeExemptCertTypeIDPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *EcmsModel) validateExemptCertTypeID(formats strfmt.Registry) error {

	if err := validate.Required("exemptCertTypeId", "body", m.ExemptCertTypeID); err != nil {
		return err
	}

	// value enum
	if err := m.validateExemptCertTypeIDEnum("exemptCertTypeId", "body", *m.ExemptCertTypeID); err != nil {
		return err
	}

	return nil
}

func (m *EcmsModel) validateExemptReasonID(formats strfmt.Registry) error {
	if swag.IsZero(m.ExemptReasonID) { // not required
		return nil
	}

	if err := validate.MinLength("exemptReasonId", "body", *m.ExemptReasonID, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("exemptReasonId", "body", *m.ExemptReasonID, 1); err != nil {
		return err
	}

	return nil
}

func (m *EcmsModel) validateExemptReasonOtherDescription(formats strfmt.Registry) error {
	if swag.IsZero(m.ExemptReasonOtherDescription) { // not required
		return nil
	}

	if err := validate.MinLength("exemptReasonOtherDescription", "body", *m.ExemptReasonOtherDescription, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("exemptReasonOtherDescription", "body", *m.ExemptReasonOtherDescription, 255); err != nil {
		return err
	}

	return nil
}

func (m *EcmsModel) validateExpiryDate(formats strfmt.Registry) error {
	if swag.IsZero(m.ExpiryDate) { // not required
		return nil
	}

	if err := validate.FormatOf("expiryDate", "body", "date-time", m.ExpiryDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *EcmsModel) validateLastTransactionDate(formats strfmt.Registry) error {
	if swag.IsZero(m.LastTransactionDate) { // not required
		return nil
	}

	if err := validate.FormatOf("lastTransactionDate", "body", "date-time", m.LastTransactionDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *EcmsModel) validateModifiedDate(formats strfmt.Registry) error {
	if swag.IsZero(m.ModifiedDate) { // not required
		return nil
	}

	if err := validate.FormatOf("modifiedDate", "body", "date-time", m.ModifiedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *EcmsModel) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(m.PostalCode) { // not required
		return nil
	}

	if err := validate.MinLength("postalCode", "body", *m.PostalCode, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("postalCode", "body", *m.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

func (m *EcmsModel) validateRegion(formats strfmt.Registry) error {

	if err := validate.Required("region", "body", m.Region); err != nil {
		return err
	}

	return nil
}

func (m *EcmsModel) validateRegionsApplicable(formats strfmt.Registry) error {

	if err := validate.Required("regionsApplicable", "body", m.RegionsApplicable); err != nil {
		return err
	}

	if err := validate.MinLength("regionsApplicable", "body", *m.RegionsApplicable, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("regionsApplicable", "body", *m.RegionsApplicable, 200); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this ecms model based on the context it is used
func (m *EcmsModel) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLastTransactionDate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EcmsModel) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Details); i++ {

		if m.Details[i] != nil {
			if err := m.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EcmsModel) contextValidateLastTransactionDate(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "lastTransactionDate", "body", strfmt.DateTime(m.LastTransactionDate)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *EcmsModel) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EcmsModel) UnmarshalBinary(b []byte) error {
	var res EcmsModel
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
