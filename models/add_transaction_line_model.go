// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// AddTransactionLineModel Model to add specific lines to exising transaction
// Example: {"companyCode":"DEFAULT","documentType":"SalesInvoice","lines":[{"amount":100,"description":"Yarn","itemCode":"Y0001","number":"1","quantity":1,"taxCode":"PS081282"}],"renumber":false,"transactionCode":"1234"}
//
// swagger:model AddTransactionLineModel
type AddTransactionLineModel struct {

	// company code
	// Example: DEFAULT
	// Required: true
	CompanyCode *string `json:"companyCode"`

	// document type
	// Example: SalesOrder
	// Enum: [SalesOrder SalesInvoice PurchaseOrder PurchaseInvoice ReturnOrder ReturnInvoice InventoryTransferOrder InventoryTransferInvoice ReverseChargeOrder ReverseChargeInvoice CustomsInvoice CustomsOrder Any]
	DocumentType string `json:"documentType,omitempty"`

	// List of lines to be added
	// Example: [{"amount":100,"description":"Yarn","itemCode":"Y0001","number":"1","quantity":1,"taxCode":"PS081282"}]
	// Required: true
	Lines []*LineItemModel `json:"lines"`

	// Option to renumber lines after add. After renumber, the line number becomes: "1", "2", "3", ...
	// Example: false
	Renumber bool `json:"renumber,omitempty"`

	// document code for the transaction to add lines
	// Example: 1234
	// Required: true
	TransactionCode *string `json:"transactionCode"`
}

// Validate validates this add transaction line model
func (m *AddTransactionLineModel) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCompanyCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDocumentType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLines(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransactionCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AddTransactionLineModel) validateCompanyCode(formats strfmt.Registry) error {

	if err := validate.Required("companyCode", "body", m.CompanyCode); err != nil {
		return err
	}

	return nil
}

var addTransactionLineModelTypeDocumentTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SalesOrder","SalesInvoice","PurchaseOrder","PurchaseInvoice","ReturnOrder","ReturnInvoice","InventoryTransferOrder","InventoryTransferInvoice","ReverseChargeOrder","ReverseChargeInvoice","CustomsInvoice","CustomsOrder","Any"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		addTransactionLineModelTypeDocumentTypePropEnum = append(addTransactionLineModelTypeDocumentTypePropEnum, v)
	}
}

const (

	// AddTransactionLineModelDocumentTypeSalesOrder captures enum value "SalesOrder"
	AddTransactionLineModelDocumentTypeSalesOrder string = "SalesOrder"

	// AddTransactionLineModelDocumentTypeSalesInvoice captures enum value "SalesInvoice"
	AddTransactionLineModelDocumentTypeSalesInvoice string = "SalesInvoice"

	// AddTransactionLineModelDocumentTypePurchaseOrder captures enum value "PurchaseOrder"
	AddTransactionLineModelDocumentTypePurchaseOrder string = "PurchaseOrder"

	// AddTransactionLineModelDocumentTypePurchaseInvoice captures enum value "PurchaseInvoice"
	AddTransactionLineModelDocumentTypePurchaseInvoice string = "PurchaseInvoice"

	// AddTransactionLineModelDocumentTypeReturnOrder captures enum value "ReturnOrder"
	AddTransactionLineModelDocumentTypeReturnOrder string = "ReturnOrder"

	// AddTransactionLineModelDocumentTypeReturnInvoice captures enum value "ReturnInvoice"
	AddTransactionLineModelDocumentTypeReturnInvoice string = "ReturnInvoice"

	// AddTransactionLineModelDocumentTypeInventoryTransferOrder captures enum value "InventoryTransferOrder"
	AddTransactionLineModelDocumentTypeInventoryTransferOrder string = "InventoryTransferOrder"

	// AddTransactionLineModelDocumentTypeInventoryTransferInvoice captures enum value "InventoryTransferInvoice"
	AddTransactionLineModelDocumentTypeInventoryTransferInvoice string = "InventoryTransferInvoice"

	// AddTransactionLineModelDocumentTypeReverseChargeOrder captures enum value "ReverseChargeOrder"
	AddTransactionLineModelDocumentTypeReverseChargeOrder string = "ReverseChargeOrder"

	// AddTransactionLineModelDocumentTypeReverseChargeInvoice captures enum value "ReverseChargeInvoice"
	AddTransactionLineModelDocumentTypeReverseChargeInvoice string = "ReverseChargeInvoice"

	// AddTransactionLineModelDocumentTypeCustomsInvoice captures enum value "CustomsInvoice"
	AddTransactionLineModelDocumentTypeCustomsInvoice string = "CustomsInvoice"

	// AddTransactionLineModelDocumentTypeCustomsOrder captures enum value "CustomsOrder"
	AddTransactionLineModelDocumentTypeCustomsOrder string = "CustomsOrder"

	// AddTransactionLineModelDocumentTypeAny captures enum value "Any"
	AddTransactionLineModelDocumentTypeAny string = "Any"
)

// prop value enum
func (m *AddTransactionLineModel) validateDocumentTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, addTransactionLineModelTypeDocumentTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AddTransactionLineModel) validateDocumentType(formats strfmt.Registry) error {
	if swag.IsZero(m.DocumentType) { // not required
		return nil
	}

	// value enum
	if err := m.validateDocumentTypeEnum("documentType", "body", m.DocumentType); err != nil {
		return err
	}

	return nil
}

func (m *AddTransactionLineModel) validateLines(formats strfmt.Registry) error {

	if err := validate.Required("lines", "body", m.Lines); err != nil {
		return err
	}

	for i := 0; i < len(m.Lines); i++ {
		if swag.IsZero(m.Lines[i]) { // not required
			continue
		}

		if m.Lines[i] != nil {
			if err := m.Lines[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("lines" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("lines" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *AddTransactionLineModel) validateTransactionCode(formats strfmt.Registry) error {

	if err := validate.Required("transactionCode", "body", m.TransactionCode); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this add transaction line model based on the context it is used
func (m *AddTransactionLineModel) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLines(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AddTransactionLineModel) contextValidateLines(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Lines); i++ {

		if m.Lines[i] != nil {
			if err := m.Lines[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("lines" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("lines" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *AddTransactionLineModel) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AddTransactionLineModel) UnmarshalBinary(b []byte) error {
	var res AddTransactionLineModel
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
