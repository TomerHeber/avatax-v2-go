// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CompanyModel A company or business entity.
// Example: {"accountId":123456789,"baseCurrencyCode":"USD","companyCode":"DEFAULT","defaultCountry":"US","hasProfile":true,"id":12345,"inProgress":false,"isActive":true,"isDefault":false,"isFein":false,"isReportingEntity":false,"isTest":true,"name":"Default Company","roundingLevelId":"Line","taxDependencyLevelId":"Document","taxpayerIdNumber":"123456789"}
//
// swagger:model CompanyModel
type CompanyModel struct {

	// The unique ID number of the account this company belongs to.
	// Example: 123456789
	// Required: true
	AccountID *int32 `json:"accountId"`

	// This is the three character ISO-4217 currency code of the default currency used by this company.
	// Example: USD
	// Max Length: 3
	// Min Length: 0
	BaseCurrencyCode *string `json:"baseCurrencyCode,omitempty"`

	// Business Identification No
	// Max Length: 25
	// Min Length: 0
	BusinessIdentificationNo *string `json:"businessIdentificationNo,omitempty"`

	// A unique code that references this company within your account.
	// Example: DEFAULT
	// Max Length: 25
	// Min Length: 0
	CompanyCode *string `json:"companyCode,omitempty"`

	// Optional: A list of contacts defined for this company.  To fetch this list, add the query string `?$include=Contacts` to your URL.
	//
	// When calling `CreateCompany`, you may provide a list of objects in this element and they will be created alongside the company.
	// The `UpdateCompany` API does not permit updating nested objects.
	Contacts []*ContactModel `json:"contacts"`

	// The date when this record was created.
	// Read Only: true
	// Format: date-time
	CreatedDate strfmt.DateTime `json:"createdDate,omitempty"`

	// The User ID of the user who created this record.
	// Read Only: true
	CreatedUserID int32 `json:"createdUserId,omitempty"`

	// The two character ISO-3166 country code of the default country for this company.
	// Example: US
	// Required: true
	// Max Length: 2
	// Min Length: 2
	DefaultCountry *string `json:"defaultCountry"`

	// If set, this is the unique ID number of the default location for this company.
	DefaultLocationID int32 `json:"defaultLocationId,omitempty"`

	// DEPRECATED - Date: 9/15/2017, Version: 17.10, Message: Please use the `ListCertificates` API.
	//
	// Read Only: true
	ExemptCerts []*EcmsModel `json:"exemptCerts"`

	// Set this flag to true to give this company its own unique tax profile.
	// If this flag is true, this company will have its own Nexus, TaxRule, TaxCode, and Item definitions.
	// If this flag is false, this company will inherit all profile values from its parent.
	// Example: true
	HasProfile bool `json:"hasProfile,omitempty"`

	// The unique ID number of this company.
	// Example: 12345
	// Required: true
	ID *int32 `json:"id"`

	// Set this value to true to indicate that you are still working to finish configuring this company.
	// While this value is true, no tax reporting will occur and the company will not be usable for transactions.
	// Example: false
	InProgress bool `json:"inProgress,omitempty"`

	// This flag indicates whether tax activity can occur for this company.  Set this flag to true to permit the company to process transactions.
	// Example: true
	IsActive bool `json:"isActive,omitempty"`

	// This flag is true if this company is the default company for this account.  Only one company may be set as the default.
	// Example: false
	IsDefault bool `json:"isDefault,omitempty"`

	// Set this field to true if the taxPayerIdNumber is a FEIN.
	IsFein bool `json:"isFein,omitempty"`

	// Set this flag to true if this company must file its own tax returns.
	// For users who have Returns enabled, this flag turns on monthly Worksheet generation for the company.
	// Example: false
	IsReportingEntity bool `json:"isReportingEntity,omitempty"`

	// Set this flag to true to indicate that this company is a test company.
	// If you have Returns enabled, Test companies will not file tax returns and can be used for validation purposes.
	// Example: true
	IsTest bool `json:"isTest,omitempty"`

	// Optional: A list of items defined for this company.  To fetch this list, add the query string `?$include=Items` to your URL.
	//
	// When calling `CreateCompany`, you may provide a list of objects in this element and they will be created alongside the company.
	// The `UpdateCompany` API does not permit updating nested objects.
	Items []*ItemModel `json:"items"`

	// Optional: A list of locations defined for this company.  To fetch this list, add the query string `?$include=Locations` to your URL.
	//
	// When calling `CreateCompany`, you may provide a list of objects in this element and they will be created alongside the company.
	// The `UpdateCompany` API does not permit updating nested objects.
	Locations []*LocationModel `json:"locations"`

	// The date/time when this record was last modified.
	// Read Only: true
	// Format: date-time
	ModifiedDate strfmt.DateTime `json:"modifiedDate,omitempty"`

	// The user ID of the user who last modified this record.
	// Read Only: true
	ModifiedUserID int32 `json:"modifiedUserId,omitempty"`

	// The country code of the mini-one-stop-shop used for Value Added Tax (VAT) processing.
	// Max Length: 2
	// Min Length: 0
	MossCountry *string `json:"mossCountry,omitempty"`

	// The unique identifier of the mini-one-stop-shop used for Value Added Tax (VAT) processing.
	// Max Length: 25
	// Min Length: 0
	MossID *string `json:"mossId,omitempty"`

	// The name of this company, as shown to customers.
	// Example: Default Company
	// Required: true
	// Max Length: 50
	// Min Length: 0
	Name *string `json:"name"`

	// Optional: A list of nexus defined for this company.  To fetch this list, add the query string `?$include=Nexus` to your URL.
	//
	// When calling `CreateCompany`, you may provide a list of objects in this element and they will be created alongside the company.
	// The `UpdateCompany` API does not permit updating nested objects.
	Nexus []*NexusModel `json:"nexus"`

	// Optional: A list of non reporting child companies associated with this company.  To fetch this list, add the query string `?$include=NonReportingChildren` to your URL.
	// Read Only: true
	NonReportingChildCompanies []*CompanyModel `json:"nonReportingChildCompanies"`

	// The parameters of a company
	// Read Only: true
	Parameters []*CompanyParameterDetailModel `json:"parameters"`

	// If this company is fully owned by another company, this is the unique identity of the parent company.
	ParentCompanyID int32 `json:"parentCompanyId,omitempty"`

	// Indicates whether this company prefers to round amounts at the document level or line level.
	// Example: Line
	// Enum: [Line Document]
	RoundingLevelID string `json:"roundingLevelId,omitempty"`

	// Optional: A list of settings defined for this company.  To fetch this list, add the query string `?$include=Settings` to your URL.
	//
	// When calling `CreateCompany`, you may provide a list of objects in this element and they will be created alongside the company.
	// The `UpdateCompany` API does not permit updating nested objects.
	Settings []*SettingModel `json:"settings"`

	// If this company participates in Streamlined Sales Tax, this is the date when the company joined the SST program.
	// Format: date
	SstEffectiveDate strfmt.Date `json:"sstEffectiveDate,omitempty"`

	// If this company files Streamlined Sales Tax, this is the PID of this company as defined by the Streamlined Sales Tax governing board.
	// Max Length: 9
	// Min Length: 0
	SstPid *string `json:"sstPid,omitempty"`

	// The customers and suppliers of a company
	// Read Only: true
	Supplierandcustomers []*CustomerSupplierModel `json:"supplierandcustomers"`

	// Optional: A list of tax codes defined for this company.  To fetch this list, add the query string `?$include=TaxCodes` to your URL.
	//
	// When calling `CreateCompany`, you may provide a list of objects in this element and they will be created alongside the company.
	// The `UpdateCompany` API does not permit updating nested objects.
	TaxCodes []*TaxCodeModel `json:"taxCodes"`

	// Used to apply tax detail dependency at a jurisdiction level.
	// Example: Document
	// Enum: [Document State TaxRegion Address]
	TaxDependencyLevelID string `json:"taxDependencyLevelId,omitempty"`

	// Optional: A list of tax rules defined for this company.  To fetch this list, add the query string `?$include=TaxRules` to your URL.
	//
	// When calling `CreateCompany`, you may provide a list of objects in this element and they will be created alongside the company.
	// The `UpdateCompany` API does not permit updating nested objects.
	TaxRules []*TaxRuleModel `json:"taxRules"`

	// For United States companies, this field contains your Taxpayer Identification Number.
	// This is a nine digit number that is usually called an EIN for an Employer Identification Number if this company is a corporation,
	// or SSN for a Social Security Number if this company is a person.
	// This value is required if the address provided is inside the US and if you subscribed to the Avalara Managed Returns or SST Certified Service Provider service. Otherwise it is optional.
	// Example: 123456789
	// Max Length: 11
	// Min Length: 0
	TaxpayerIDNumber *string `json:"taxpayerIdNumber,omitempty"`

	// Optional: A list of UPCs defined for this company.  To fetch this list, add the query string `?$include=UPCs` to your URL.
	//
	// When calling `CreateCompany`, you may provide a list of objects in this element and they will be created alongside the company.
	// The `UpdateCompany` API does not permit updating nested objects.
	Upcs []*UPCModel `json:"upcs"`

	// Set this value to true to receive warnings in API calls via SOAP.
	WarningsEnabled bool `json:"warningsEnabled,omitempty"`
}

// Validate validates this company model
func (m *CompanyModel) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccountID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBaseCurrencyCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBusinessIdentificationNo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCompanyCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateContacts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDefaultCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExemptCerts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateItems(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocations(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateModifiedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMossCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMossID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNexus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNonReportingChildCompanies(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateParameters(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRoundingLevelID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSettings(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSstEffectiveDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSstPid(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSupplierandcustomers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTaxCodes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTaxDependencyLevelID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTaxRules(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTaxpayerIDNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpcs(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CompanyModel) validateAccountID(formats strfmt.Registry) error {

	if err := validate.Required("accountId", "body", m.AccountID); err != nil {
		return err
	}

	return nil
}

func (m *CompanyModel) validateBaseCurrencyCode(formats strfmt.Registry) error {
	if swag.IsZero(m.BaseCurrencyCode) { // not required
		return nil
	}

	if err := validate.MinLength("baseCurrencyCode", "body", *m.BaseCurrencyCode, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("baseCurrencyCode", "body", *m.BaseCurrencyCode, 3); err != nil {
		return err
	}

	return nil
}

func (m *CompanyModel) validateBusinessIdentificationNo(formats strfmt.Registry) error {
	if swag.IsZero(m.BusinessIdentificationNo) { // not required
		return nil
	}

	if err := validate.MinLength("businessIdentificationNo", "body", *m.BusinessIdentificationNo, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("businessIdentificationNo", "body", *m.BusinessIdentificationNo, 25); err != nil {
		return err
	}

	return nil
}

func (m *CompanyModel) validateCompanyCode(formats strfmt.Registry) error {
	if swag.IsZero(m.CompanyCode) { // not required
		return nil
	}

	if err := validate.MinLength("companyCode", "body", *m.CompanyCode, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("companyCode", "body", *m.CompanyCode, 25); err != nil {
		return err
	}

	return nil
}

func (m *CompanyModel) validateContacts(formats strfmt.Registry) error {
	if swag.IsZero(m.Contacts) { // not required
		return nil
	}

	for i := 0; i < len(m.Contacts); i++ {
		if swag.IsZero(m.Contacts[i]) { // not required
			continue
		}

		if m.Contacts[i] != nil {
			if err := m.Contacts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("contacts" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("contacts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CompanyModel) validateCreatedDate(formats strfmt.Registry) error {
	if swag.IsZero(m.CreatedDate) { // not required
		return nil
	}

	if err := validate.FormatOf("createdDate", "body", "date-time", m.CreatedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CompanyModel) validateDefaultCountry(formats strfmt.Registry) error {

	if err := validate.Required("defaultCountry", "body", m.DefaultCountry); err != nil {
		return err
	}

	if err := validate.MinLength("defaultCountry", "body", *m.DefaultCountry, 2); err != nil {
		return err
	}

	if err := validate.MaxLength("defaultCountry", "body", *m.DefaultCountry, 2); err != nil {
		return err
	}

	return nil
}

func (m *CompanyModel) validateExemptCerts(formats strfmt.Registry) error {
	if swag.IsZero(m.ExemptCerts) { // not required
		return nil
	}

	for i := 0; i < len(m.ExemptCerts); i++ {
		if swag.IsZero(m.ExemptCerts[i]) { // not required
			continue
		}

		if m.ExemptCerts[i] != nil {
			if err := m.ExemptCerts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("exemptCerts" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("exemptCerts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CompanyModel) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *CompanyModel) validateItems(formats strfmt.Registry) error {
	if swag.IsZero(m.Items) { // not required
		return nil
	}

	for i := 0; i < len(m.Items); i++ {
		if swag.IsZero(m.Items[i]) { // not required
			continue
		}

		if m.Items[i] != nil {
			if err := m.Items[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("items" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("items" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CompanyModel) validateLocations(formats strfmt.Registry) error {
	if swag.IsZero(m.Locations) { // not required
		return nil
	}

	for i := 0; i < len(m.Locations); i++ {
		if swag.IsZero(m.Locations[i]) { // not required
			continue
		}

		if m.Locations[i] != nil {
			if err := m.Locations[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("locations" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("locations" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CompanyModel) validateModifiedDate(formats strfmt.Registry) error {
	if swag.IsZero(m.ModifiedDate) { // not required
		return nil
	}

	if err := validate.FormatOf("modifiedDate", "body", "date-time", m.ModifiedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CompanyModel) validateMossCountry(formats strfmt.Registry) error {
	if swag.IsZero(m.MossCountry) { // not required
		return nil
	}

	if err := validate.MinLength("mossCountry", "body", *m.MossCountry, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("mossCountry", "body", *m.MossCountry, 2); err != nil {
		return err
	}

	return nil
}

func (m *CompanyModel) validateMossID(formats strfmt.Registry) error {
	if swag.IsZero(m.MossID) { // not required
		return nil
	}

	if err := validate.MinLength("mossId", "body", *m.MossID, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("mossId", "body", *m.MossID, 25); err != nil {
		return err
	}

	return nil
}

func (m *CompanyModel) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	if err := validate.MinLength("name", "body", *m.Name, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("name", "body", *m.Name, 50); err != nil {
		return err
	}

	return nil
}

func (m *CompanyModel) validateNexus(formats strfmt.Registry) error {
	if swag.IsZero(m.Nexus) { // not required
		return nil
	}

	for i := 0; i < len(m.Nexus); i++ {
		if swag.IsZero(m.Nexus[i]) { // not required
			continue
		}

		if m.Nexus[i] != nil {
			if err := m.Nexus[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nexus" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("nexus" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CompanyModel) validateNonReportingChildCompanies(formats strfmt.Registry) error {
	if swag.IsZero(m.NonReportingChildCompanies) { // not required
		return nil
	}

	for i := 0; i < len(m.NonReportingChildCompanies); i++ {
		if swag.IsZero(m.NonReportingChildCompanies[i]) { // not required
			continue
		}

		if m.NonReportingChildCompanies[i] != nil {
			if err := m.NonReportingChildCompanies[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nonReportingChildCompanies" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("nonReportingChildCompanies" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CompanyModel) validateParameters(formats strfmt.Registry) error {
	if swag.IsZero(m.Parameters) { // not required
		return nil
	}

	for i := 0; i < len(m.Parameters); i++ {
		if swag.IsZero(m.Parameters[i]) { // not required
			continue
		}

		if m.Parameters[i] != nil {
			if err := m.Parameters[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("parameters" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("parameters" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var companyModelTypeRoundingLevelIDPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Line","Document"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		companyModelTypeRoundingLevelIDPropEnum = append(companyModelTypeRoundingLevelIDPropEnum, v)
	}
}

const (

	// CompanyModelRoundingLevelIDLine captures enum value "Line"
	CompanyModelRoundingLevelIDLine string = "Line"

	// CompanyModelRoundingLevelIDDocument captures enum value "Document"
	CompanyModelRoundingLevelIDDocument string = "Document"
)

// prop value enum
func (m *CompanyModel) validateRoundingLevelIDEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, companyModelTypeRoundingLevelIDPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CompanyModel) validateRoundingLevelID(formats strfmt.Registry) error {
	if swag.IsZero(m.RoundingLevelID) { // not required
		return nil
	}

	// value enum
	if err := m.validateRoundingLevelIDEnum("roundingLevelId", "body", m.RoundingLevelID); err != nil {
		return err
	}

	return nil
}

func (m *CompanyModel) validateSettings(formats strfmt.Registry) error {
	if swag.IsZero(m.Settings) { // not required
		return nil
	}

	for i := 0; i < len(m.Settings); i++ {
		if swag.IsZero(m.Settings[i]) { // not required
			continue
		}

		if m.Settings[i] != nil {
			if err := m.Settings[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("settings" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("settings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CompanyModel) validateSstEffectiveDate(formats strfmt.Registry) error {
	if swag.IsZero(m.SstEffectiveDate) { // not required
		return nil
	}

	if err := validate.FormatOf("sstEffectiveDate", "body", "date", m.SstEffectiveDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CompanyModel) validateSstPid(formats strfmt.Registry) error {
	if swag.IsZero(m.SstPid) { // not required
		return nil
	}

	if err := validate.MinLength("sstPid", "body", *m.SstPid, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("sstPid", "body", *m.SstPid, 9); err != nil {
		return err
	}

	return nil
}

func (m *CompanyModel) validateSupplierandcustomers(formats strfmt.Registry) error {
	if swag.IsZero(m.Supplierandcustomers) { // not required
		return nil
	}

	for i := 0; i < len(m.Supplierandcustomers); i++ {
		if swag.IsZero(m.Supplierandcustomers[i]) { // not required
			continue
		}

		if m.Supplierandcustomers[i] != nil {
			if err := m.Supplierandcustomers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("supplierandcustomers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("supplierandcustomers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CompanyModel) validateTaxCodes(formats strfmt.Registry) error {
	if swag.IsZero(m.TaxCodes) { // not required
		return nil
	}

	for i := 0; i < len(m.TaxCodes); i++ {
		if swag.IsZero(m.TaxCodes[i]) { // not required
			continue
		}

		if m.TaxCodes[i] != nil {
			if err := m.TaxCodes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taxCodes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("taxCodes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var companyModelTypeTaxDependencyLevelIDPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Document","State","TaxRegion","Address"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		companyModelTypeTaxDependencyLevelIDPropEnum = append(companyModelTypeTaxDependencyLevelIDPropEnum, v)
	}
}

const (

	// CompanyModelTaxDependencyLevelIDDocument captures enum value "Document"
	CompanyModelTaxDependencyLevelIDDocument string = "Document"

	// CompanyModelTaxDependencyLevelIDState captures enum value "State"
	CompanyModelTaxDependencyLevelIDState string = "State"

	// CompanyModelTaxDependencyLevelIDTaxRegion captures enum value "TaxRegion"
	CompanyModelTaxDependencyLevelIDTaxRegion string = "TaxRegion"

	// CompanyModelTaxDependencyLevelIDAddress captures enum value "Address"
	CompanyModelTaxDependencyLevelIDAddress string = "Address"
)

// prop value enum
func (m *CompanyModel) validateTaxDependencyLevelIDEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, companyModelTypeTaxDependencyLevelIDPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CompanyModel) validateTaxDependencyLevelID(formats strfmt.Registry) error {
	if swag.IsZero(m.TaxDependencyLevelID) { // not required
		return nil
	}

	// value enum
	if err := m.validateTaxDependencyLevelIDEnum("taxDependencyLevelId", "body", m.TaxDependencyLevelID); err != nil {
		return err
	}

	return nil
}

func (m *CompanyModel) validateTaxRules(formats strfmt.Registry) error {
	if swag.IsZero(m.TaxRules) { // not required
		return nil
	}

	for i := 0; i < len(m.TaxRules); i++ {
		if swag.IsZero(m.TaxRules[i]) { // not required
			continue
		}

		if m.TaxRules[i] != nil {
			if err := m.TaxRules[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taxRules" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("taxRules" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CompanyModel) validateTaxpayerIDNumber(formats strfmt.Registry) error {
	if swag.IsZero(m.TaxpayerIDNumber) { // not required
		return nil
	}

	if err := validate.MinLength("taxpayerIdNumber", "body", *m.TaxpayerIDNumber, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("taxpayerIdNumber", "body", *m.TaxpayerIDNumber, 11); err != nil {
		return err
	}

	return nil
}

func (m *CompanyModel) validateUpcs(formats strfmt.Registry) error {
	if swag.IsZero(m.Upcs) { // not required
		return nil
	}

	for i := 0; i < len(m.Upcs); i++ {
		if swag.IsZero(m.Upcs[i]) { // not required
			continue
		}

		if m.Upcs[i] != nil {
			if err := m.Upcs[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("upcs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("upcs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this company model based on the context it is used
func (m *CompanyModel) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateContacts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCreatedDate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCreatedUserID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExemptCerts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateItems(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLocations(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateModifiedDate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateModifiedUserID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNexus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNonReportingChildCompanies(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateParameters(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSettings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSupplierandcustomers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTaxCodes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTaxRules(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUpcs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CompanyModel) contextValidateContacts(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Contacts); i++ {

		if m.Contacts[i] != nil {
			if err := m.Contacts[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("contacts" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("contacts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CompanyModel) contextValidateCreatedDate(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "createdDate", "body", strfmt.DateTime(m.CreatedDate)); err != nil {
		return err
	}

	return nil
}

func (m *CompanyModel) contextValidateCreatedUserID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "createdUserId", "body", int32(m.CreatedUserID)); err != nil {
		return err
	}

	return nil
}

func (m *CompanyModel) contextValidateExemptCerts(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "exemptCerts", "body", []*EcmsModel(m.ExemptCerts)); err != nil {
		return err
	}

	for i := 0; i < len(m.ExemptCerts); i++ {

		if m.ExemptCerts[i] != nil {
			if err := m.ExemptCerts[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("exemptCerts" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("exemptCerts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CompanyModel) contextValidateItems(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Items); i++ {

		if m.Items[i] != nil {
			if err := m.Items[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("items" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("items" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CompanyModel) contextValidateLocations(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Locations); i++ {

		if m.Locations[i] != nil {
			if err := m.Locations[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("locations" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("locations" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CompanyModel) contextValidateModifiedDate(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "modifiedDate", "body", strfmt.DateTime(m.ModifiedDate)); err != nil {
		return err
	}

	return nil
}

func (m *CompanyModel) contextValidateModifiedUserID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "modifiedUserId", "body", int32(m.ModifiedUserID)); err != nil {
		return err
	}

	return nil
}

func (m *CompanyModel) contextValidateNexus(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Nexus); i++ {

		if m.Nexus[i] != nil {
			if err := m.Nexus[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nexus" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("nexus" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CompanyModel) contextValidateNonReportingChildCompanies(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "nonReportingChildCompanies", "body", []*CompanyModel(m.NonReportingChildCompanies)); err != nil {
		return err
	}

	for i := 0; i < len(m.NonReportingChildCompanies); i++ {

		if m.NonReportingChildCompanies[i] != nil {
			if err := m.NonReportingChildCompanies[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nonReportingChildCompanies" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("nonReportingChildCompanies" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CompanyModel) contextValidateParameters(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "parameters", "body", []*CompanyParameterDetailModel(m.Parameters)); err != nil {
		return err
	}

	for i := 0; i < len(m.Parameters); i++ {

		if m.Parameters[i] != nil {
			if err := m.Parameters[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("parameters" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("parameters" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CompanyModel) contextValidateSettings(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Settings); i++ {

		if m.Settings[i] != nil {
			if err := m.Settings[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("settings" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("settings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CompanyModel) contextValidateSupplierandcustomers(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "supplierandcustomers", "body", []*CustomerSupplierModel(m.Supplierandcustomers)); err != nil {
		return err
	}

	for i := 0; i < len(m.Supplierandcustomers); i++ {

		if m.Supplierandcustomers[i] != nil {
			if err := m.Supplierandcustomers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("supplierandcustomers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("supplierandcustomers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CompanyModel) contextValidateTaxCodes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.TaxCodes); i++ {

		if m.TaxCodes[i] != nil {
			if err := m.TaxCodes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taxCodes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("taxCodes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CompanyModel) contextValidateTaxRules(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.TaxRules); i++ {

		if m.TaxRules[i] != nil {
			if err := m.TaxRules[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taxRules" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("taxRules" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CompanyModel) contextValidateUpcs(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Upcs); i++ {

		if m.Upcs[i] != nil {
			if err := m.Upcs[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("upcs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("upcs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *CompanyModel) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CompanyModel) UnmarshalBinary(b []byte) error {
	var res CompanyModel
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
