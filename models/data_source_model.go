// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// DataSourceModel Data source object
// Example: {"companyId":12345,"createdDate":"2021-12-25T00:00:00+00:00","createdUserId":123,"externalState":"Test Path","id":1,"instance":"0a9cd4d9-d4f8-4db6-a0c0-62f44dc69699","isAuthorized":false,"isEnabled":false,"isSynced":false,"modifiedDate":"2021-12-25T00:00:00+00:00","modifiedUserId":12,"name":"TestName","source":"Amazon v2 Extractor"}
//
// swagger:model DataSourceModel
type DataSourceModel struct {

	// The id of the company to which the datasource belongs to.
	// Example: 12345
	// Required: true
	CompanyID *int32 `json:"companyId"`

	// The date when this record was created.
	// Example: 2021-12-25T00:00:00+00:00
	// Read Only: true
	// Format: date-time
	CreatedDate strfmt.DateTime `json:"createdDate,omitempty"`

	// The User ID of the user who created this record.
	// Example: 123
	// Read Only: true
	CreatedUserID int32 `json:"createdUserId,omitempty"`

	// The date when this record was deleted.
	// Read Only: true
	// Format: date-time
	DeletedDate strfmt.DateTime `json:"deletedDate,omitempty"`

	// Specifies any implementation-specific information along with the DataSource.This field has no internal meaning in AvaTax and is purely for the convenience of the DataSource API user
	// Example: Test Path
	ExternalState string `json:"externalState,omitempty"`

	// The id of the datasource.
	// Example: 1
	// Read Only: true
	ID int32 `json:"id,omitempty"`

	// The unique ID number of this connection.
	// Example: 0a9cd4d9-d4f8-4db6-a0c0-62f44dc69699
	// Read Only: true
	Instance string `json:"instance,omitempty"`

	// True if this data source is authorized.
	// Example: false
	IsAuthorized bool `json:"isAuthorized,omitempty"`

	// The connection using the connection_id is enabled. The customer is responsible to enable or disable.
	// Example: false
	IsEnabled bool `json:"isEnabled,omitempty"`

	// If all the information has been transferred from the extractor to the database.
	// Example: false
	IsSynced bool `json:"isSynced,omitempty"`

	// The date when the information was last synched.
	// Format: date-time
	LastSyncedDate strfmt.DateTime `json:"lastSyncedDate,omitempty"`

	// The date/time when this record was last modified.
	// Example: 2021-12-25T00:00:00+00:00
	// Read Only: true
	// Format: date-time
	ModifiedDate strfmt.DateTime `json:"modifiedDate,omitempty"`

	// The user ID of the user who last modified this record.
	// Example: 12
	// Read Only: true
	ModifiedUserID int32 `json:"modifiedUserId,omitempty"`

	// Specifies the name of the extractor
	// Example: TestName
	Name string `json:"name,omitempty"`

	// Specifies whether transactions created by this data source needs to re-calculate tax or not
	Recalculate bool `json:"recalculate,omitempty"`

	// The extractor/connector id.
	// Example: Amazon v2 Extractor
	// Required: true
	Source *string `json:"source"`
}

// Validate validates this data source model
func (m *DataSourceModel) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCompanyID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeletedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastSyncedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateModifiedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSource(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataSourceModel) validateCompanyID(formats strfmt.Registry) error {

	if err := validate.Required("companyId", "body", m.CompanyID); err != nil {
		return err
	}

	return nil
}

func (m *DataSourceModel) validateCreatedDate(formats strfmt.Registry) error {
	if swag.IsZero(m.CreatedDate) { // not required
		return nil
	}

	if err := validate.FormatOf("createdDate", "body", "date-time", m.CreatedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *DataSourceModel) validateDeletedDate(formats strfmt.Registry) error {
	if swag.IsZero(m.DeletedDate) { // not required
		return nil
	}

	if err := validate.FormatOf("deletedDate", "body", "date-time", m.DeletedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *DataSourceModel) validateLastSyncedDate(formats strfmt.Registry) error {
	if swag.IsZero(m.LastSyncedDate) { // not required
		return nil
	}

	if err := validate.FormatOf("lastSyncedDate", "body", "date-time", m.LastSyncedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *DataSourceModel) validateModifiedDate(formats strfmt.Registry) error {
	if swag.IsZero(m.ModifiedDate) { // not required
		return nil
	}

	if err := validate.FormatOf("modifiedDate", "body", "date-time", m.ModifiedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *DataSourceModel) validateSource(formats strfmt.Registry) error {

	if err := validate.Required("source", "body", m.Source); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this data source model based on the context it is used
func (m *DataSourceModel) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCreatedDate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCreatedUserID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDeletedDate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInstance(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateModifiedDate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateModifiedUserID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataSourceModel) contextValidateCreatedDate(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "createdDate", "body", strfmt.DateTime(m.CreatedDate)); err != nil {
		return err
	}

	return nil
}

func (m *DataSourceModel) contextValidateCreatedUserID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "createdUserId", "body", int32(m.CreatedUserID)); err != nil {
		return err
	}

	return nil
}

func (m *DataSourceModel) contextValidateDeletedDate(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "deletedDate", "body", strfmt.DateTime(m.DeletedDate)); err != nil {
		return err
	}

	return nil
}

func (m *DataSourceModel) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "id", "body", int32(m.ID)); err != nil {
		return err
	}

	return nil
}

func (m *DataSourceModel) contextValidateInstance(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "instance", "body", string(m.Instance)); err != nil {
		return err
	}

	return nil
}

func (m *DataSourceModel) contextValidateModifiedDate(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "modifiedDate", "body", strfmt.DateTime(m.ModifiedDate)); err != nil {
		return err
	}

	return nil
}

func (m *DataSourceModel) contextValidateModifiedUserID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "modifiedUserId", "body", int32(m.ModifiedUserID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataSourceModel) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataSourceModel) UnmarshalBinary(b []byte) error {
	var res DataSourceModel
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
