// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CreateMultiDocumentModel A MultiDocument transaction represents a sale or purchase that occurred between more than two companies.
//
// A traditional transaction requires exactly two parties: a seller and a buyer.  MultiDocument transactions can
// involve a marketplace of vendors, each of which contributes some portion of the final transaction.  Within
// a MultiDocument transaction, each individual buyer and seller pair are matched up and converted to a separate
// document.  This separation of documents allows each seller to file their taxes separately.
// Example: {"addresses":{"singleLocation":{"city":"Irvine","country":"US","line1":"2000 Main Street","postalCode":"92614","region":"CA"}},"commit":true,"companyCode":"DEFAULT","currencyCode":"USD","customerCode":"ABC","date":"2021-12-25","description":"Yarn","lines":[{"amount":100,"companyCode":"DEFAULT","description":"Yarn","itemCode":"Y0001","number":"1","quantity":1,"reportingLocationCode":"ReportLocation111","taxCode":"PS081282"}],"purchaseOrderNo":"2021-12-25-001","type":"SalesInvoice"}
//
// swagger:model CreateMultiDocumentModel
type CreateMultiDocumentModel struct {

	// Default addresses for all lines in this document.
	//
	// These addresses are the default values that will be used for any lines that do not have their own
	// address information.  If you specify addresses for a line, then no default addresses will be loaded
	// for that line.
	// Example: {"singleLocation":{"city":"Irvine","country":"US","line1":"2000 Main Street","postalCode":"92614","region":"CA"}}
	Addresses *AddressesModel `json:"addresses,omitempty"`

	// Set this value to true to allow this API call to adjust the MultiDocument model if one already exists.
	//
	// If you omit this field, or if the value is `null`, you will receive an error if you try to create two MultiDocument
	// objects with the same `code`.
	AllowAdjust bool `json:"allowAdjust,omitempty"`

	// BatchCode for batch operations.
	// Max Length: 25
	// Min Length: 0
	BatchCode *string `json:"batchCode,omitempty"`

	// VAT business identification number for the customer for this transaction.  This number will be used for all lines
	// in the transaction, except for those lines where you have defined a different business identification number.
	//
	// If you specify a VAT business identification number for the customer in this transaction and you have also set up
	// a business identification number for your company during company setup, this transaction will be treated as a
	// business-to-business transaction for VAT purposes and it will be calculated according to VAT tax rules.
	// Max Length: 25
	// Min Length: 0
	BusinessIdentificationNo *string `json:"businessIdentificationNo,omitempty"`

	// The transaction code of the MultiDocument transaction.
	//
	// All individual transactions within this MultiDocument object will have this code as a prefix.
	//
	// If you leave the `code` field blank, a GUID will be assigned.
	// Max Length: 45
	// Min Length: 0
	Code *string `json:"code,omitempty"`

	// Causes the document to be committed if true.  This option is only applicable for invoice document
	// types, not orders.
	// Example: true
	Commit bool `json:"commit,omitempty"`

	// Company Code - Specify the code of the company creating this transaction here.  If you leave this value null,
	// your account's default company will be used instead.
	// Example: DEFAULT
	// Max Length: 50
	// Min Length: 0
	CompanyCode *string `json:"companyCode,omitempty"`

	// The three-character ISO 4217 currency code for this transaction.
	// Example: USD
	// Max Length: 3
	// Min Length: 0
	CurrencyCode *string `json:"currencyCode,omitempty"`

	// Customer Code - The client application customer reference code.
	// Note: This field is case sensitive. To have exemption certificates apply, this value should
	// be the same as the one passed to create a customer.
	// Example: ABC
	// Required: true
	// Max Length: 50
	// Min Length: 0
	CustomerCode *string `json:"customerCode"`

	// The name of the supplier / exporter / seller.
	// For sales doctype enter the name of your own company for which you are reporting.
	// For purchases doctype enter the name of the supplier you have purchased from.
	// Max Length: 200
	// Min Length: 0
	CustomerSupplierName *string `json:"customerSupplierName,omitempty"`

	// DEPRECATED - Date: 10/16/2017, Version: 17.11, Message: Please use entityUseCode instead.
	// Customer Usage Type - The client application customer or usage type.
	// Max Length: 25
	// Min Length: 0
	CustomerUsageType *string `json:"customerUsageType,omitempty"`

	// The Id of the datasource from which this transaction originated.
	// This value will be overridden by the system to take the datasource Id from the call header.
	DataSourceID int32 `json:"dataSourceId,omitempty"`

	// Transaction Date - The date on the invoice, purchase order, etc.
	//
	// By default, this date will be used to calculate the tax rates for the transaction.  If you wish to use a
	// different date to calculate tax rates, please specify a `taxOverride` of type `taxDate`.
	// Example: 2021-12-25T00:00:00+00:00
	// Required: true
	// Format: date
	Date *strfmt.Date `json:"date"`

	// If the user wishes to request additional debug information from this transaction, specify a level higher than `normal`.
	// Example: Normal
	// Enum: [Normal Diagnostic]
	DebugLevel string `json:"debugLevel,omitempty"`

	// The Delivery Terms is a field used in conjunction with Importer of Record to influence whether AvaTax includes Import Duty and Tax values in the transaction totals or not.
	// Delivered at Place (DAP) and Delivered Duty Paid (DDP) are two delivery terms that  indicate that Import Duty and Tax should be included in the transaction total.
	// This field is also used for reports.
	// This field is used for future feature support. This field is not currently in use.
	// Example: DAP
	// Enum: [DAP DDP]
	DeliveryTerms string `json:"deliveryTerms,omitempty"`

	// User-supplied description for this transaction.
	// Example: Yarn
	// Max Length: 2048
	// Min Length: 0
	Description *string `json:"description,omitempty"`

	// Discount - The discount amount to apply to the document.  This value will be applied only to lines
	// that have the `discounted` flag set to true.  If no lines have `discounted` set to true, this discount
	// cannot be applied.
	Discount float64 `json:"discount,omitempty"`

	// User-supplied email address relevant for this transaction.
	// Max Length: 50
	// Min Length: 0
	Email *string `json:"email,omitempty"`

	// Entity Use Code - The client application customer or usage type.  For a list of
	// available usage types, use [ListEntityUseCodes](https://developer.avalara.com/api-reference/avatax/rest/v2/methods/Definitions/ListEntityUseCodes/) API.
	// Max Length: 25
	// Min Length: 0
	EntityUseCode *string `json:"entityUseCode,omitempty"`

	// Currency exchange rate from this transaction to the company base currency.
	//
	// This only needs to be set if the transaction currency is different than the company base currency.
	// It defaults to 1.0.
	ExchangeRate float64 `json:"exchangeRate,omitempty"`

	// Optional three-character ISO 4217 reporting exchange rate currency code for this transaction. The default value is USD.
	// Max Length: 3
	// Min Length: 0
	ExchangeRateCurrencyCode *string `json:"exchangeRateCurrencyCode,omitempty"`

	// Effective date of the exchange rate.
	// Format: date
	ExchangeRateEffectiveDate strfmt.Date `json:"exchangeRateEffectiveDate,omitempty"`

	// Exemption Number for this document.
	//
	// If you specify an exemption number for this document, this document will be considered exempt, and you
	// may be asked to provide proof of this exemption certificate in the event that you are asked by an auditor
	// to verify your exemptions.
	// Note: This is same as 'exemptNo' in TransactionModel.
	// Max Length: 25
	// Min Length: 0
	ExemptionNo *string `json:"exemptionNo,omitempty"`

	// Specifies if the transaction should have value-added and cross-border taxes calculated with the seller as the importer of record.
	//
	// Some taxes only apply if the seller is the importer of record for a product.  In cases where companies are working together to
	// ship products, there may be mutual agreement as to which company is the entity designated as importer of record.  The importer
	// of record will then be the company designated to pay taxes marked as being obligated to the importer of record.
	//
	// Set this value to `true` to consider your company as the importer of record and collect these taxes.
	//
	// This value may also be set at the Nexus level.  See `NexusModel` for more information.
	IsSellerImporterOfRecord bool `json:"isSellerImporterOfRecord,omitempty"`

	// Lines that will appear on the invoice.
	//
	// For a MultiDocument transaction, each line may represent a different company or reporting location code.  AvaTax
	// will separate this MultiDocument transaction object into many different transactions, one for each pair of legal
	// entities, so that each legal entity can file their transactional taxes correctly.
	// Example: [{"amount":100,"companyCode":"DEFAULT","description":"Yarn","itemCode":"Y0001","number":"1","quantity":1,"reportingLocationCode":"ReportLocation111","taxCode":"PS081282"}]
	// Required: true
	Lines []*MultiDocumentLineItemModel `json:"lines"`

	// Special parameters for this transaction.
	//
	// To get a full list of available parameters, please use the [ListParameters](https://developer.avalara.com/api-reference/avatax/rest/v2/methods/Definitions/ListParameters/) endpoint.
	Parameters []*TransactionParameterModel `json:"parameters"`

	// Sets the Point of Sale Lane Code sent by the User for this document.
	// Max Length: 50
	// Min Length: 0
	PosLaneCode *string `json:"posLaneCode,omitempty"`

	// Purchase Order Number for this document.
	//
	// This is required for single use exemption certificates to match the order and invoice with the certificate.
	// Example: 2021-12-25-001
	// Max Length: 50
	// Min Length: 0
	PurchaseOrderNo *string `json:"purchaseOrderNo,omitempty"`

	// Customer-provided Reference Code with information about this transaction.
	//
	// This field could be used to reference the original document for a return invoice, or for any other
	// reference purpose.
	// Max Length: 1024
	// Min Length: 0
	ReferenceCode *string `json:"referenceCode,omitempty"`

	// Sets the sale location code (Outlet ID) for reporting this document to the tax authority.
	//
	// This value is used by Avalara Managed Returns to group documents together by reporting locations
	// for tax authorities that require location-based reporting.
	// Max Length: 50
	// Min Length: 0
	ReportingLocationCode *string `json:"reportingLocationCode,omitempty"`

	// Salesperson Code - The client application salesperson reference code.
	// Max Length: 25
	// Min Length: 0
	SalespersonCode *string `json:"salespersonCode,omitempty"`

	// Specifies whether the tax calculation is handled Local, Remote, or Automatic (default).  This only
	// applies when using an AvaLocal server.
	// Example: Automatic
	// Enum: [Automatic Local Remote]
	ServiceMode string `json:"serviceMode,omitempty"`

	// Specifies a tax override for the entire document
	// Example: {"reason":"Precalculated Tax","taxAmount":6.25,"taxDate":"2021-12-25","type":"TaxAmount"}
	TaxOverride *TaxOverrideModel `json:"taxOverride,omitempty"`

	// Specifies the type of document to create.  A document type ending with `Invoice` is a permanent transaction
	// that will be recorded in AvaTax.  A document type ending with `Order` is a temporary estimate that will not
	// be preserved.
	//
	// If you omit this value, the API will assume you want to create a `SalesOrder`.
	// Example: SalesOrder
	// Enum: [SalesOrder SalesInvoice PurchaseOrder PurchaseInvoice ReturnOrder ReturnInvoice InventoryTransferOrder InventoryTransferInvoice ReverseChargeOrder ReverseChargeInvoice CustomsInvoice CustomsOrder Any]
	Type string `json:"type,omitempty"`

	// Custom user fields/flex fields for this transaction.
	UserDefinedFields []*TransactionUserDefinedFieldModel `json:"userDefinedFields"`
}

// Validate validates this create multi document model
func (m *CreateMultiDocumentModel) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAddresses(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBatchCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBusinessIdentificationNo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCompanyCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCurrencyCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomerCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomerSupplierName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomerUsageType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDebugLevel(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeliveryTerms(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEntityUseCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExchangeRateCurrencyCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExchangeRateEffectiveDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExemptionNo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLines(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateParameters(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePosLaneCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePurchaseOrderNo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReferenceCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReportingLocationCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSalespersonCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServiceMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTaxOverride(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserDefinedFields(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CreateMultiDocumentModel) validateAddresses(formats strfmt.Registry) error {
	if swag.IsZero(m.Addresses) { // not required
		return nil
	}

	if m.Addresses != nil {
		if err := m.Addresses.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addresses")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("addresses")
			}
			return err
		}
	}

	return nil
}

func (m *CreateMultiDocumentModel) validateBatchCode(formats strfmt.Registry) error {
	if swag.IsZero(m.BatchCode) { // not required
		return nil
	}

	if err := validate.MinLength("batchCode", "body", *m.BatchCode, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("batchCode", "body", *m.BatchCode, 25); err != nil {
		return err
	}

	return nil
}

func (m *CreateMultiDocumentModel) validateBusinessIdentificationNo(formats strfmt.Registry) error {
	if swag.IsZero(m.BusinessIdentificationNo) { // not required
		return nil
	}

	if err := validate.MinLength("businessIdentificationNo", "body", *m.BusinessIdentificationNo, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("businessIdentificationNo", "body", *m.BusinessIdentificationNo, 25); err != nil {
		return err
	}

	return nil
}

func (m *CreateMultiDocumentModel) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(m.Code) { // not required
		return nil
	}

	if err := validate.MinLength("code", "body", *m.Code, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("code", "body", *m.Code, 45); err != nil {
		return err
	}

	return nil
}

func (m *CreateMultiDocumentModel) validateCompanyCode(formats strfmt.Registry) error {
	if swag.IsZero(m.CompanyCode) { // not required
		return nil
	}

	if err := validate.MinLength("companyCode", "body", *m.CompanyCode, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("companyCode", "body", *m.CompanyCode, 50); err != nil {
		return err
	}

	return nil
}

func (m *CreateMultiDocumentModel) validateCurrencyCode(formats strfmt.Registry) error {
	if swag.IsZero(m.CurrencyCode) { // not required
		return nil
	}

	if err := validate.MinLength("currencyCode", "body", *m.CurrencyCode, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("currencyCode", "body", *m.CurrencyCode, 3); err != nil {
		return err
	}

	return nil
}

func (m *CreateMultiDocumentModel) validateCustomerCode(formats strfmt.Registry) error {

	if err := validate.Required("customerCode", "body", m.CustomerCode); err != nil {
		return err
	}

	if err := validate.MinLength("customerCode", "body", *m.CustomerCode, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("customerCode", "body", *m.CustomerCode, 50); err != nil {
		return err
	}

	return nil
}

func (m *CreateMultiDocumentModel) validateCustomerSupplierName(formats strfmt.Registry) error {
	if swag.IsZero(m.CustomerSupplierName) { // not required
		return nil
	}

	if err := validate.MinLength("customerSupplierName", "body", *m.CustomerSupplierName, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("customerSupplierName", "body", *m.CustomerSupplierName, 200); err != nil {
		return err
	}

	return nil
}

func (m *CreateMultiDocumentModel) validateCustomerUsageType(formats strfmt.Registry) error {
	if swag.IsZero(m.CustomerUsageType) { // not required
		return nil
	}

	if err := validate.MinLength("customerUsageType", "body", *m.CustomerUsageType, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("customerUsageType", "body", *m.CustomerUsageType, 25); err != nil {
		return err
	}

	return nil
}

func (m *CreateMultiDocumentModel) validateDate(formats strfmt.Registry) error {

	if err := validate.Required("date", "body", m.Date); err != nil {
		return err
	}

	if err := validate.FormatOf("date", "body", "date", m.Date.String(), formats); err != nil {
		return err
	}

	return nil
}

var createMultiDocumentModelTypeDebugLevelPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Normal","Diagnostic"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		createMultiDocumentModelTypeDebugLevelPropEnum = append(createMultiDocumentModelTypeDebugLevelPropEnum, v)
	}
}

const (

	// CreateMultiDocumentModelDebugLevelNormal captures enum value "Normal"
	CreateMultiDocumentModelDebugLevelNormal string = "Normal"

	// CreateMultiDocumentModelDebugLevelDiagnostic captures enum value "Diagnostic"
	CreateMultiDocumentModelDebugLevelDiagnostic string = "Diagnostic"
)

// prop value enum
func (m *CreateMultiDocumentModel) validateDebugLevelEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, createMultiDocumentModelTypeDebugLevelPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CreateMultiDocumentModel) validateDebugLevel(formats strfmt.Registry) error {
	if swag.IsZero(m.DebugLevel) { // not required
		return nil
	}

	// value enum
	if err := m.validateDebugLevelEnum("debugLevel", "body", m.DebugLevel); err != nil {
		return err
	}

	return nil
}

var createMultiDocumentModelTypeDeliveryTermsPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["DAP","DDP"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		createMultiDocumentModelTypeDeliveryTermsPropEnum = append(createMultiDocumentModelTypeDeliveryTermsPropEnum, v)
	}
}

const (

	// CreateMultiDocumentModelDeliveryTermsDAP captures enum value "DAP"
	CreateMultiDocumentModelDeliveryTermsDAP string = "DAP"

	// CreateMultiDocumentModelDeliveryTermsDDP captures enum value "DDP"
	CreateMultiDocumentModelDeliveryTermsDDP string = "DDP"
)

// prop value enum
func (m *CreateMultiDocumentModel) validateDeliveryTermsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, createMultiDocumentModelTypeDeliveryTermsPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CreateMultiDocumentModel) validateDeliveryTerms(formats strfmt.Registry) error {
	if swag.IsZero(m.DeliveryTerms) { // not required
		return nil
	}

	// value enum
	if err := m.validateDeliveryTermsEnum("deliveryTerms", "body", m.DeliveryTerms); err != nil {
		return err
	}

	return nil
}

func (m *CreateMultiDocumentModel) validateDescription(formats strfmt.Registry) error {
	if swag.IsZero(m.Description) { // not required
		return nil
	}

	if err := validate.MinLength("description", "body", *m.Description, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("description", "body", *m.Description, 2048); err != nil {
		return err
	}

	return nil
}

func (m *CreateMultiDocumentModel) validateEmail(formats strfmt.Registry) error {
	if swag.IsZero(m.Email) { // not required
		return nil
	}

	if err := validate.MinLength("email", "body", *m.Email, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("email", "body", *m.Email, 50); err != nil {
		return err
	}

	return nil
}

func (m *CreateMultiDocumentModel) validateEntityUseCode(formats strfmt.Registry) error {
	if swag.IsZero(m.EntityUseCode) { // not required
		return nil
	}

	if err := validate.MinLength("entityUseCode", "body", *m.EntityUseCode, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("entityUseCode", "body", *m.EntityUseCode, 25); err != nil {
		return err
	}

	return nil
}

func (m *CreateMultiDocumentModel) validateExchangeRateCurrencyCode(formats strfmt.Registry) error {
	if swag.IsZero(m.ExchangeRateCurrencyCode) { // not required
		return nil
	}

	if err := validate.MinLength("exchangeRateCurrencyCode", "body", *m.ExchangeRateCurrencyCode, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("exchangeRateCurrencyCode", "body", *m.ExchangeRateCurrencyCode, 3); err != nil {
		return err
	}

	return nil
}

func (m *CreateMultiDocumentModel) validateExchangeRateEffectiveDate(formats strfmt.Registry) error {
	if swag.IsZero(m.ExchangeRateEffectiveDate) { // not required
		return nil
	}

	if err := validate.FormatOf("exchangeRateEffectiveDate", "body", "date", m.ExchangeRateEffectiveDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CreateMultiDocumentModel) validateExemptionNo(formats strfmt.Registry) error {
	if swag.IsZero(m.ExemptionNo) { // not required
		return nil
	}

	if err := validate.MinLength("exemptionNo", "body", *m.ExemptionNo, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("exemptionNo", "body", *m.ExemptionNo, 25); err != nil {
		return err
	}

	return nil
}

func (m *CreateMultiDocumentModel) validateLines(formats strfmt.Registry) error {

	if err := validate.Required("lines", "body", m.Lines); err != nil {
		return err
	}

	for i := 0; i < len(m.Lines); i++ {
		if swag.IsZero(m.Lines[i]) { // not required
			continue
		}

		if m.Lines[i] != nil {
			if err := m.Lines[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("lines" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("lines" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CreateMultiDocumentModel) validateParameters(formats strfmt.Registry) error {
	if swag.IsZero(m.Parameters) { // not required
		return nil
	}

	for i := 0; i < len(m.Parameters); i++ {
		if swag.IsZero(m.Parameters[i]) { // not required
			continue
		}

		if m.Parameters[i] != nil {
			if err := m.Parameters[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("parameters" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("parameters" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CreateMultiDocumentModel) validatePosLaneCode(formats strfmt.Registry) error {
	if swag.IsZero(m.PosLaneCode) { // not required
		return nil
	}

	if err := validate.MinLength("posLaneCode", "body", *m.PosLaneCode, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("posLaneCode", "body", *m.PosLaneCode, 50); err != nil {
		return err
	}

	return nil
}

func (m *CreateMultiDocumentModel) validatePurchaseOrderNo(formats strfmt.Registry) error {
	if swag.IsZero(m.PurchaseOrderNo) { // not required
		return nil
	}

	if err := validate.MinLength("purchaseOrderNo", "body", *m.PurchaseOrderNo, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("purchaseOrderNo", "body", *m.PurchaseOrderNo, 50); err != nil {
		return err
	}

	return nil
}

func (m *CreateMultiDocumentModel) validateReferenceCode(formats strfmt.Registry) error {
	if swag.IsZero(m.ReferenceCode) { // not required
		return nil
	}

	if err := validate.MinLength("referenceCode", "body", *m.ReferenceCode, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("referenceCode", "body", *m.ReferenceCode, 1024); err != nil {
		return err
	}

	return nil
}

func (m *CreateMultiDocumentModel) validateReportingLocationCode(formats strfmt.Registry) error {
	if swag.IsZero(m.ReportingLocationCode) { // not required
		return nil
	}

	if err := validate.MinLength("reportingLocationCode", "body", *m.ReportingLocationCode, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("reportingLocationCode", "body", *m.ReportingLocationCode, 50); err != nil {
		return err
	}

	return nil
}

func (m *CreateMultiDocumentModel) validateSalespersonCode(formats strfmt.Registry) error {
	if swag.IsZero(m.SalespersonCode) { // not required
		return nil
	}

	if err := validate.MinLength("salespersonCode", "body", *m.SalespersonCode, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("salespersonCode", "body", *m.SalespersonCode, 25); err != nil {
		return err
	}

	return nil
}

var createMultiDocumentModelTypeServiceModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Automatic","Local","Remote"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		createMultiDocumentModelTypeServiceModePropEnum = append(createMultiDocumentModelTypeServiceModePropEnum, v)
	}
}

const (

	// CreateMultiDocumentModelServiceModeAutomatic captures enum value "Automatic"
	CreateMultiDocumentModelServiceModeAutomatic string = "Automatic"

	// CreateMultiDocumentModelServiceModeLocal captures enum value "Local"
	CreateMultiDocumentModelServiceModeLocal string = "Local"

	// CreateMultiDocumentModelServiceModeRemote captures enum value "Remote"
	CreateMultiDocumentModelServiceModeRemote string = "Remote"
)

// prop value enum
func (m *CreateMultiDocumentModel) validateServiceModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, createMultiDocumentModelTypeServiceModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CreateMultiDocumentModel) validateServiceMode(formats strfmt.Registry) error {
	if swag.IsZero(m.ServiceMode) { // not required
		return nil
	}

	// value enum
	if err := m.validateServiceModeEnum("serviceMode", "body", m.ServiceMode); err != nil {
		return err
	}

	return nil
}

func (m *CreateMultiDocumentModel) validateTaxOverride(formats strfmt.Registry) error {
	if swag.IsZero(m.TaxOverride) { // not required
		return nil
	}

	if m.TaxOverride != nil {
		if err := m.TaxOverride.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("taxOverride")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("taxOverride")
			}
			return err
		}
	}

	return nil
}

var createMultiDocumentModelTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SalesOrder","SalesInvoice","PurchaseOrder","PurchaseInvoice","ReturnOrder","ReturnInvoice","InventoryTransferOrder","InventoryTransferInvoice","ReverseChargeOrder","ReverseChargeInvoice","CustomsInvoice","CustomsOrder","Any"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		createMultiDocumentModelTypeTypePropEnum = append(createMultiDocumentModelTypeTypePropEnum, v)
	}
}

const (

	// CreateMultiDocumentModelTypeSalesOrder captures enum value "SalesOrder"
	CreateMultiDocumentModelTypeSalesOrder string = "SalesOrder"

	// CreateMultiDocumentModelTypeSalesInvoice captures enum value "SalesInvoice"
	CreateMultiDocumentModelTypeSalesInvoice string = "SalesInvoice"

	// CreateMultiDocumentModelTypePurchaseOrder captures enum value "PurchaseOrder"
	CreateMultiDocumentModelTypePurchaseOrder string = "PurchaseOrder"

	// CreateMultiDocumentModelTypePurchaseInvoice captures enum value "PurchaseInvoice"
	CreateMultiDocumentModelTypePurchaseInvoice string = "PurchaseInvoice"

	// CreateMultiDocumentModelTypeReturnOrder captures enum value "ReturnOrder"
	CreateMultiDocumentModelTypeReturnOrder string = "ReturnOrder"

	// CreateMultiDocumentModelTypeReturnInvoice captures enum value "ReturnInvoice"
	CreateMultiDocumentModelTypeReturnInvoice string = "ReturnInvoice"

	// CreateMultiDocumentModelTypeInventoryTransferOrder captures enum value "InventoryTransferOrder"
	CreateMultiDocumentModelTypeInventoryTransferOrder string = "InventoryTransferOrder"

	// CreateMultiDocumentModelTypeInventoryTransferInvoice captures enum value "InventoryTransferInvoice"
	CreateMultiDocumentModelTypeInventoryTransferInvoice string = "InventoryTransferInvoice"

	// CreateMultiDocumentModelTypeReverseChargeOrder captures enum value "ReverseChargeOrder"
	CreateMultiDocumentModelTypeReverseChargeOrder string = "ReverseChargeOrder"

	// CreateMultiDocumentModelTypeReverseChargeInvoice captures enum value "ReverseChargeInvoice"
	CreateMultiDocumentModelTypeReverseChargeInvoice string = "ReverseChargeInvoice"

	// CreateMultiDocumentModelTypeCustomsInvoice captures enum value "CustomsInvoice"
	CreateMultiDocumentModelTypeCustomsInvoice string = "CustomsInvoice"

	// CreateMultiDocumentModelTypeCustomsOrder captures enum value "CustomsOrder"
	CreateMultiDocumentModelTypeCustomsOrder string = "CustomsOrder"

	// CreateMultiDocumentModelTypeAny captures enum value "Any"
	CreateMultiDocumentModelTypeAny string = "Any"
)

// prop value enum
func (m *CreateMultiDocumentModel) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, createMultiDocumentModelTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CreateMultiDocumentModel) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

func (m *CreateMultiDocumentModel) validateUserDefinedFields(formats strfmt.Registry) error {
	if swag.IsZero(m.UserDefinedFields) { // not required
		return nil
	}

	for i := 0; i < len(m.UserDefinedFields); i++ {
		if swag.IsZero(m.UserDefinedFields[i]) { // not required
			continue
		}

		if m.UserDefinedFields[i] != nil {
			if err := m.UserDefinedFields[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("userDefinedFields" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("userDefinedFields" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this create multi document model based on the context it is used
func (m *CreateMultiDocumentModel) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAddresses(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLines(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateParameters(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTaxOverride(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUserDefinedFields(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CreateMultiDocumentModel) contextValidateAddresses(ctx context.Context, formats strfmt.Registry) error {

	if m.Addresses != nil {
		if err := m.Addresses.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addresses")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("addresses")
			}
			return err
		}
	}

	return nil
}

func (m *CreateMultiDocumentModel) contextValidateLines(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Lines); i++ {

		if m.Lines[i] != nil {
			if err := m.Lines[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("lines" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("lines" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CreateMultiDocumentModel) contextValidateParameters(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Parameters); i++ {

		if m.Parameters[i] != nil {
			if err := m.Parameters[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("parameters" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("parameters" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CreateMultiDocumentModel) contextValidateTaxOverride(ctx context.Context, formats strfmt.Registry) error {

	if m.TaxOverride != nil {
		if err := m.TaxOverride.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("taxOverride")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("taxOverride")
			}
			return err
		}
	}

	return nil
}

func (m *CreateMultiDocumentModel) contextValidateUserDefinedFields(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.UserDefinedFields); i++ {

		if m.UserDefinedFields[i] != nil {
			if err := m.UserDefinedFields[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("userDefinedFields" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("userDefinedFields" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *CreateMultiDocumentModel) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CreateMultiDocumentModel) UnmarshalBinary(b []byte) error {
	var res CreateMultiDocumentModel
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
