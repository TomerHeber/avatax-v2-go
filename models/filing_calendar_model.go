// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// FilingCalendarModel Represents a commitment to file a tax return on a recurring basis.
// Only used if you subscribe to Avalara Returns.
// Example: {"city":"Irvine","companyId":12345,"country":"US","effectiveDate":"2015-01-01","employerIdentificationNumber":"12-3456789","filingFrequencyId":"Quarterly","filingTypeId":"ElectronicReturn","id":56789,"legalEntityName":"Bob's Artisan Pottery","line1":"2000 Main Street","months":2340,"outletTypeId":"None","phone":"714 555-1212","postalCode":"92614","prePaymentRequired":false,"prepayPercentage":90,"region":"CA","returnName":"CABOE401A2","settings":[{"companyReturnId":123,"filingQuestionCode":"EfileUsername","filingQuestionId":26,"id":0,"value":"bobExample"}],"stateRegistrationId":"101-123456","taxTypeId":"All"}
//
// swagger:model FilingCalendarModel
type FilingCalendarModel struct {

	// Custom filing information field for Alabama.
	// Max Length: 25
	// Min Length: 0
	AlAccessCode *string `json:"alAccessCode,omitempty"`

	// Custom filing information field for Alabama.
	// Max Length: 25
	// Min Length: 0
	AlSignOn *string `json:"alSignOn,omitempty"`

	// User name of bulk account.
	// Read Only: true
	BulkAccountID string `json:"bulkAccountId,omitempty"`

	// The status of the bulk account's validation.
	// Example: New
	// Read Only: true
	// Enum: [New Added Failed]
	BulkAccountValidationStatus string `json:"bulkAccountValidationStatus,omitempty"`

	// DEPRECATED - Date: 9/1/2017, Version: 17.9, Message: Field will be no longer be available after the 17.9 release.
	// The city name of the mailing address that will be used when filling out this tax return.
	// Example: Irvine
	// Max Length: 50
	// Min Length: 0
	City *string `json:"city,omitempty"`

	// The unique ID number of the company to which this filing calendar belongs.
	// Example: 12345
	// Required: true
	CompanyID *int32 `json:"companyId"`

	// DEPRECATED - Date: 9/1/2017, Version: 17.9, Message: Field will be no longer be available after the 17.9 release.
	// The two character ISO-3166 country code of the mailing address that will be used when filling out this tax return.
	// Example: US
	// Max Length: 2
	// Min Length: 0
	Country *string `json:"country,omitempty"`

	// The date when this record was created.
	// Read Only: true
	// Format: date-time
	CreatedDate strfmt.DateTime `json:"createdDate,omitempty"`

	// The User ID of the user who created this record.
	// Read Only: true
	CreatedUserID int32 `json:"createdUserId,omitempty"`

	// Custom filing information field for Connecticut.
	// Max Length: 50
	// Min Length: 0
	CtReg *string `json:"ctReg,omitempty"`

	// DEPRECATED - Date: 9/17/2021, Version: 21.9.0, Message: Field will be no longer be available after the 21.9.0 release.
	// Special filing instructions to be used when filing this return.
	// Please note that requesting special filing instructions may incur additional costs.
	// Max Length: 1000
	// Min Length: 0
	CustomerFilingInstructions *string `json:"customerFilingInstructions,omitempty"`

	// If you file electronically, this is the password or pass code you use to log in to the tax authority's website.
	// Max Length: 40
	// Min Length: 0
	EFilePassword *string `json:"eFilePassword,omitempty"`

	// If you file electronically, this is the username you use to log in to the tax authority's website.
	// Max Length: 254
	// Min Length: 0
	EFileUsername *string `json:"eFileUsername,omitempty"`

	// The earliest date for the tax period when this return should be filed.
	// This date specifies the earliest date for tax transactions that should be reported on this filing calendar.
	// Please note that tax is usually filed one month in arrears: for example, tax for January transactions is typically filed during the month of February.
	// Example: 2015-01-01T00:00:00
	// Required: true
	// Format: date
	EffectiveDate *strfmt.Date `json:"effectiveDate"`

	// The Employer Identification Number or Taxpayer Identification Number that is to be used when filing this return.
	// Example: 12-3456789
	// Max Length: 50
	// Min Length: 0
	EmployerIdentificationNumber *string `json:"employerIdentificationNumber,omitempty"`

	// The last date for the tax period when this return should be filed.
	// This date specifies the last date for tax transactions that should be reported on this filing calendar.
	// Please note that tax is usually filed one month in arrears: for example, tax for January transactions is typically filed during the month of February.
	// Format: date
	EndDate strfmt.Date `json:"endDate,omitempty"`

	// The frequency on which this tax form is filed.
	// Example: Monthly
	// Required: true
	// Enum: [Monthly Quarterly SemiAnnually Annually Bimonthly Occasional InverseQuarterly Weekly]
	FilingFrequencyID *string `json:"filingFrequencyId"`

	// The method to be used when filing this return.
	// Example: PaperReturn
	// Enum: [PaperReturn ElectronicReturn SER EFTPaper PhonePaper SignatureReady EfileCheck]
	FilingTypeID string `json:"filingTypeId,omitempty"`

	// The start period of a fiscal year for this form/company
	FiscalYearStartMonth int32 `json:"fiscalYearStartMonth,omitempty"`

	// If your company is required to make a prepayment that is designated by a fixed amount each period, please specify the amount here.
	FixedPrepaymentAmount float64 `json:"fixedPrepaymentAmount,omitempty"`

	// Name or ISO 3166 code identifying the country that issued the tax form for this filing calendar.
	//
	// This field supports many different country identifiers:
	//  * Two character ISO 3166 codes
	//  * Three character ISO 3166 codes
	//  * Fully spelled out names of the country in ISO supported languages
	//  * Common alternative spellings for many countries
	//
	// For a full list of all supported codes and names, please see the Definitions API `ListCountries`.
	FormCountry string `json:"formCountry,omitempty"`

	// Name or ISO 3166 code identifying the region that issued the tax form for this filing calendar.
	//
	// This field supports many different region identifiers:
	//  * Two and three character ISO 3166 region codes
	//  * Fully spelled out names of the region in ISO supported languages
	//  * Common alternative spellings for many regions
	//
	// For a full list of all supported codes and names, please see the Definitions API `ListRegions`.
	FormRegion string `json:"formRegion,omitempty"`

	// Custom filing information field for Iowa.
	// Max Length: 50
	// Min Length: 0
	IaBen *string `json:"iaBen,omitempty"`

	// The unique ID number of this filing calendar.
	// Example: 56789
	// Read Only: true
	ID int64 `json:"id,omitempty"`

	// DEPRECATED - Date: 9/17/2021, Version: 21.9.0, Message: Field will be no longer be available after the 21.9.0 release.
	// Internal filing notes.
	// Max Length: 1000
	// Min Length: 0
	InternalNotes *string `json:"internalNotes,omitempty"`

	// The legal entity name to be used when filing this return.
	// Example: Bob's Artisan Pottery
	// Max Length: 75
	// Min Length: 0
	LegalEntityName *string `json:"legalEntityName,omitempty"`

	// DEPRECATED - Date: 9/1/2017, Version: 17.9, Message: Field will be no longer be available after the 17.9 release.
	// The first line of the mailing address that will be used when filling out this tax return.
	// Example: 2000 Main Street
	// Max Length: 50
	// Min Length: 0
	Line1 *string `json:"line1,omitempty"`

	// DEPRECATED - Date: 9/1/2017, Version: 17.9, Message: Field will be no longer be available after the 17.9 release.
	// The second line of the mailing address that will be used when filling out this tax return.
	// Please note that some tax forms do not support multiple address lines.
	// Max Length: 50
	// Min Length: 0
	Line2 *string `json:"line2,omitempty"`

	// Tax Registration ID for the local jurisdiction, if any.
	// Max Length: 50
	// Min Length: 0
	LocalRegistrationID *string `json:"localRegistrationId,omitempty"`

	// If this calendar is for a location-specific tax return, specify the location code here.  To file for all locations, leave this value NULL.
	// Max Length: 50
	// Min Length: 0
	LocationCode *string `json:"locationCode,omitempty"`

	// The city name of the mailing address that will be used when filling out this tax return.
	// Max Length: 50
	// Min Length: 0
	MailingAddressCity *string `json:"mailingAddressCity,omitempty"`

	// Name or ISO 3166 code identifying the country of the mailing address that will be used when filling out this tax return.
	//
	// This field supports many different country identifiers:
	//  * Two character ISO 3166 codes
	//  * Three character ISO 3166 codes
	//  * Fully spelled out names of the country in ISO supported languages
	//  * Common alternative spellings for many countries
	//
	// For a full list of all supported codes and names, please see the Definitions API `ListCountries`.
	MailingAddressCountry string `json:"mailingAddressCountry,omitempty"`

	// The first line of the mailing address that will be used when filling out this tax return.
	// Max Length: 50
	// Min Length: 0
	MailingAddressLine1 *string `json:"mailingAddressLine1,omitempty"`

	// The second line of the mailing address that will be used when filling out this tax return.
	// Please note that some tax forms do not support multiple address lines.
	// Max Length: 50
	// Min Length: 0
	MailingAddressLine2 *string `json:"mailingAddressLine2,omitempty"`

	// The postal code or zip code of the mailing address that will be used when filling out this tax return.
	// Max Length: 25
	// Min Length: 0
	MailingAddressPostalCode *string `json:"mailingAddressPostalCode,omitempty"`

	// Name or ISO 3166 code identifying the region of the mailing address that will be used when filling out this tax return.
	//
	// This field supports many different region identifiers:
	//  * Two and three character ISO 3166 region codes
	//  * Fully spelled out names of the region in ISO supported languages
	//  * Common alternative spellings for many regions
	//
	// For a full list of all supported codes and names, please see the Definitions API `ListRegions`.
	MailingAddressRegion string `json:"mailingAddressRegion,omitempty"`

	// Custom filing information field for Maine.
	// Max Length: 50
	// Min Length: 0
	MeBusinessCode *string `json:"meBusinessCode,omitempty"`

	// The date/time when this record was last modified.
	// Read Only: true
	// Format: date-time
	ModifiedDate strfmt.DateTime `json:"modifiedDate,omitempty"`

	// The user ID of the user who last modified this record.
	// Read Only: true
	ModifiedUserID int32 `json:"modifiedUserId,omitempty"`

	// A 16-bit bitmap containing a 1 for each month when the return should be filed.
	// Example: 2340
	Months int16 `json:"months,omitempty"`

	// Custom filing information field.  Leave blank.
	// Max Length: 50
	// Min Length: 0
	Other1Name *string `json:"other1Name,omitempty"`

	// Custom filing information field.  Leave blank.
	// Max Length: 50
	// Min Length: 0
	Other1Value *string `json:"other1Value,omitempty"`

	// Custom filing information field.  Leave blank.
	// Max Length: 50
	// Min Length: 0
	Other2Name *string `json:"other2Name,omitempty"`

	// Custom filing information field.  Leave blank.
	// Max Length: 50
	// Min Length: 0
	Other2Value *string `json:"other2Value,omitempty"`

	// Custom filing information field.  Leave blank.
	// Max Length: 50
	// Min Length: 0
	Other3Name *string `json:"other3Name,omitempty"`

	// Custom filing information field.  Leave blank.
	// Max Length: 50
	// Min Length: 0
	Other3Value *string `json:"other3Value,omitempty"`

	// DEPRECATED - Date: 9/17/2021, Version: 21.9.0, Message: Field will be no longer be available after the 21.9.0 release.
	// If this calendar is for a location-specific tax return, specify the location-specific behavior here.
	// Example: None
	// Enum: [None Schedule Duplicate Consolidated]
	OutletTypeID string `json:"outletTypeId,omitempty"`

	// Specify the ISO 4217 currency code for the currency to remit for this tax return.  For all tax returns in the United States, specify "USD".
	// Max Length: 3
	// Min Length: 0
	PaymentCurrency *string `json:"paymentCurrency,omitempty"`

	// The phone number to be used when filing this return.
	// Example: 714 555-1212
	// Max Length: 50
	// Min Length: 0
	Phone *string `json:"phone,omitempty"`

	// DEPRECATED - Date: 9/1/2017, Version: 17.9, Message: Field will be no longer be available after the 17.9 release.
	// The postal code or zip code of the mailing address that will be used when filling out this tax return.
	// Example: 92614
	// Max Length: 25
	// Min Length: 0
	PostalCode *string `json:"postalCode,omitempty"`

	// Determines if a prepayment is required for this filing calendar
	// Example: false
	PrePaymentRequired bool `json:"prePaymentRequired,omitempty"`

	// If you are required to prepay a percentage of taxes for future periods, please specify the percentage in whole numbers;
	// for example, the value 90 would indicate 90%.
	// Example: 90
	PrepayPercentage int32 `json:"prepayPercentage,omitempty"`

	// DEPRECATED - Date: 9/1/2017, Version: 17.9, Message: Field will be no longer be available after the 17.9 release.
	// The state, region, or province of the mailing address that will be used when filling out this tax return.
	// Example: CA
	// Max Length: 3
	// Min Length: 0
	Region *string `json:"region,omitempty"`

	// DEPRECATED - Date: 9/13/2018, Version: 18.10, Message: Please use `taxFormCode` instead.
	// The legacy return name of the tax form to file.
	// Example: CABOE401A2
	// Max Length: 50
	// Min Length: 0
	ReturnName *string `json:"returnName,omitempty"`

	// CompanyReturn settings for complext filing calendar
	// Example: [{"companyReturnId":123,"filingQuestionCode":"EfileUsername","filingQuestionId":26,"id":0,"value":"bobExample"}]
	Settings []*CompanyReturnSettingModel `json:"settings"`

	// The bulk account site code.
	// Read Only: true
	SiteCode string `json:"siteCode,omitempty"`

	// Tax Registration ID for this Region - in the U.S., this is for your state.
	// Example: 101-123456
	// Max Length: 50
	// Min Length: 0
	StateRegistrationID *string `json:"stateRegistrationId,omitempty"`

	// The unique ID of the tax authority of this return.
	// Read Only: true
	TaxAuthorityID int32 `json:"taxAuthorityId,omitempty"`

	// The name of the tax authority of this return.
	// Read Only: true
	TaxAuthorityName string `json:"taxAuthorityName,omitempty"`

	// The type description of the tax authority of this return.
	// Read Only: true
	TaxAuthorityType string `json:"taxAuthorityType,omitempty"`

	// The Avalara standard tax form code of the tax form for this filing calendar.  The first two characters of the tax form code
	// are the ISO 3166 country code of the country that issued this form.
	TaxFormCode string `json:"taxFormCode,omitempty"`

	// DEPRECATED - Date: , Version: , Message: The 'taxTypes' list field should be used going forward.
	// The type of tax to report on this return.
	// Example: E
	// Required: true
	// Enum: [E Lodging Bottle RentToOwn BikeTax LandedCost CheckoutBag Alcohol Amusement Hospitality RentalLeasing GrossReceipts Mattress Lumber Paint Tires EI All BothSalesAndUseTax ConsumerUseTax ConsumersUseAndSellersUseTax ConsumerUseAndSalesTax Fee VATInputTax LightBulbs Meals VATNonrecoverableInputTax VATOutputTax PIF Rental SalesTax UseTax EWaste Batteries]
	TaxTypeID *string `json:"taxTypeId"`

	// The list of tax types to report on this return.
	TaxTypes []string `json:"taxTypes"`
}

// Validate validates this filing calendar model
func (m *FilingCalendarModel) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAlAccessCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAlSignOn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBulkAccountValidationStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCompanyID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCtReg(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomerFilingInstructions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEFilePassword(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEFileUsername(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEffectiveDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmployerIdentificationNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEndDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFilingFrequencyID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFilingTypeID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIaBen(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInternalNotes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLegalEntityName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLine1(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLine2(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocalRegistrationID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocationCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMailingAddressCity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMailingAddressLine1(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMailingAddressLine2(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMailingAddressPostalCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMeBusinessCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateModifiedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOther1Name(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOther1Value(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOther2Name(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOther2Value(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOther3Name(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOther3Value(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOutletTypeID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePaymentCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePhone(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRegion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReturnName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSettings(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStateRegistrationID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTaxTypeID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FilingCalendarModel) validateAlAccessCode(formats strfmt.Registry) error {
	if swag.IsZero(m.AlAccessCode) { // not required
		return nil
	}

	if err := validate.MinLength("alAccessCode", "body", *m.AlAccessCode, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("alAccessCode", "body", *m.AlAccessCode, 25); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) validateAlSignOn(formats strfmt.Registry) error {
	if swag.IsZero(m.AlSignOn) { // not required
		return nil
	}

	if err := validate.MinLength("alSignOn", "body", *m.AlSignOn, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("alSignOn", "body", *m.AlSignOn, 25); err != nil {
		return err
	}

	return nil
}

var filingCalendarModelTypeBulkAccountValidationStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["New","Added","Failed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		filingCalendarModelTypeBulkAccountValidationStatusPropEnum = append(filingCalendarModelTypeBulkAccountValidationStatusPropEnum, v)
	}
}

const (

	// FilingCalendarModelBulkAccountValidationStatusNew captures enum value "New"
	FilingCalendarModelBulkAccountValidationStatusNew string = "New"

	// FilingCalendarModelBulkAccountValidationStatusAdded captures enum value "Added"
	FilingCalendarModelBulkAccountValidationStatusAdded string = "Added"

	// FilingCalendarModelBulkAccountValidationStatusFailed captures enum value "Failed"
	FilingCalendarModelBulkAccountValidationStatusFailed string = "Failed"
)

// prop value enum
func (m *FilingCalendarModel) validateBulkAccountValidationStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, filingCalendarModelTypeBulkAccountValidationStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FilingCalendarModel) validateBulkAccountValidationStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.BulkAccountValidationStatus) { // not required
		return nil
	}

	// value enum
	if err := m.validateBulkAccountValidationStatusEnum("bulkAccountValidationStatus", "body", m.BulkAccountValidationStatus); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) validateCity(formats strfmt.Registry) error {
	if swag.IsZero(m.City) { // not required
		return nil
	}

	if err := validate.MinLength("city", "body", *m.City, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("city", "body", *m.City, 50); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) validateCompanyID(formats strfmt.Registry) error {

	if err := validate.Required("companyId", "body", m.CompanyID); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(m.Country) { // not required
		return nil
	}

	if err := validate.MinLength("country", "body", *m.Country, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("country", "body", *m.Country, 2); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) validateCreatedDate(formats strfmt.Registry) error {
	if swag.IsZero(m.CreatedDate) { // not required
		return nil
	}

	if err := validate.FormatOf("createdDate", "body", "date-time", m.CreatedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) validateCtReg(formats strfmt.Registry) error {
	if swag.IsZero(m.CtReg) { // not required
		return nil
	}

	if err := validate.MinLength("ctReg", "body", *m.CtReg, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("ctReg", "body", *m.CtReg, 50); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) validateCustomerFilingInstructions(formats strfmt.Registry) error {
	if swag.IsZero(m.CustomerFilingInstructions) { // not required
		return nil
	}

	if err := validate.MinLength("customerFilingInstructions", "body", *m.CustomerFilingInstructions, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("customerFilingInstructions", "body", *m.CustomerFilingInstructions, 1000); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) validateEFilePassword(formats strfmt.Registry) error {
	if swag.IsZero(m.EFilePassword) { // not required
		return nil
	}

	if err := validate.MinLength("eFilePassword", "body", *m.EFilePassword, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("eFilePassword", "body", *m.EFilePassword, 40); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) validateEFileUsername(formats strfmt.Registry) error {
	if swag.IsZero(m.EFileUsername) { // not required
		return nil
	}

	if err := validate.MinLength("eFileUsername", "body", *m.EFileUsername, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("eFileUsername", "body", *m.EFileUsername, 254); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) validateEffectiveDate(formats strfmt.Registry) error {

	if err := validate.Required("effectiveDate", "body", m.EffectiveDate); err != nil {
		return err
	}

	if err := validate.FormatOf("effectiveDate", "body", "date", m.EffectiveDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) validateEmployerIdentificationNumber(formats strfmt.Registry) error {
	if swag.IsZero(m.EmployerIdentificationNumber) { // not required
		return nil
	}

	if err := validate.MinLength("employerIdentificationNumber", "body", *m.EmployerIdentificationNumber, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("employerIdentificationNumber", "body", *m.EmployerIdentificationNumber, 50); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) validateEndDate(formats strfmt.Registry) error {
	if swag.IsZero(m.EndDate) { // not required
		return nil
	}

	if err := validate.FormatOf("endDate", "body", "date", m.EndDate.String(), formats); err != nil {
		return err
	}

	return nil
}

var filingCalendarModelTypeFilingFrequencyIDPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Monthly","Quarterly","SemiAnnually","Annually","Bimonthly","Occasional","InverseQuarterly","Weekly"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		filingCalendarModelTypeFilingFrequencyIDPropEnum = append(filingCalendarModelTypeFilingFrequencyIDPropEnum, v)
	}
}

const (

	// FilingCalendarModelFilingFrequencyIDMonthly captures enum value "Monthly"
	FilingCalendarModelFilingFrequencyIDMonthly string = "Monthly"

	// FilingCalendarModelFilingFrequencyIDQuarterly captures enum value "Quarterly"
	FilingCalendarModelFilingFrequencyIDQuarterly string = "Quarterly"

	// FilingCalendarModelFilingFrequencyIDSemiAnnually captures enum value "SemiAnnually"
	FilingCalendarModelFilingFrequencyIDSemiAnnually string = "SemiAnnually"

	// FilingCalendarModelFilingFrequencyIDAnnually captures enum value "Annually"
	FilingCalendarModelFilingFrequencyIDAnnually string = "Annually"

	// FilingCalendarModelFilingFrequencyIDBimonthly captures enum value "Bimonthly"
	FilingCalendarModelFilingFrequencyIDBimonthly string = "Bimonthly"

	// FilingCalendarModelFilingFrequencyIDOccasional captures enum value "Occasional"
	FilingCalendarModelFilingFrequencyIDOccasional string = "Occasional"

	// FilingCalendarModelFilingFrequencyIDInverseQuarterly captures enum value "InverseQuarterly"
	FilingCalendarModelFilingFrequencyIDInverseQuarterly string = "InverseQuarterly"

	// FilingCalendarModelFilingFrequencyIDWeekly captures enum value "Weekly"
	FilingCalendarModelFilingFrequencyIDWeekly string = "Weekly"
)

// prop value enum
func (m *FilingCalendarModel) validateFilingFrequencyIDEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, filingCalendarModelTypeFilingFrequencyIDPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FilingCalendarModel) validateFilingFrequencyID(formats strfmt.Registry) error {

	if err := validate.Required("filingFrequencyId", "body", m.FilingFrequencyID); err != nil {
		return err
	}

	// value enum
	if err := m.validateFilingFrequencyIDEnum("filingFrequencyId", "body", *m.FilingFrequencyID); err != nil {
		return err
	}

	return nil
}

var filingCalendarModelTypeFilingTypeIDPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PaperReturn","ElectronicReturn","SER","EFTPaper","PhonePaper","SignatureReady","EfileCheck"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		filingCalendarModelTypeFilingTypeIDPropEnum = append(filingCalendarModelTypeFilingTypeIDPropEnum, v)
	}
}

const (

	// FilingCalendarModelFilingTypeIDPaperReturn captures enum value "PaperReturn"
	FilingCalendarModelFilingTypeIDPaperReturn string = "PaperReturn"

	// FilingCalendarModelFilingTypeIDElectronicReturn captures enum value "ElectronicReturn"
	FilingCalendarModelFilingTypeIDElectronicReturn string = "ElectronicReturn"

	// FilingCalendarModelFilingTypeIDSER captures enum value "SER"
	FilingCalendarModelFilingTypeIDSER string = "SER"

	// FilingCalendarModelFilingTypeIDEFTPaper captures enum value "EFTPaper"
	FilingCalendarModelFilingTypeIDEFTPaper string = "EFTPaper"

	// FilingCalendarModelFilingTypeIDPhonePaper captures enum value "PhonePaper"
	FilingCalendarModelFilingTypeIDPhonePaper string = "PhonePaper"

	// FilingCalendarModelFilingTypeIDSignatureReady captures enum value "SignatureReady"
	FilingCalendarModelFilingTypeIDSignatureReady string = "SignatureReady"

	// FilingCalendarModelFilingTypeIDEfileCheck captures enum value "EfileCheck"
	FilingCalendarModelFilingTypeIDEfileCheck string = "EfileCheck"
)

// prop value enum
func (m *FilingCalendarModel) validateFilingTypeIDEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, filingCalendarModelTypeFilingTypeIDPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FilingCalendarModel) validateFilingTypeID(formats strfmt.Registry) error {
	if swag.IsZero(m.FilingTypeID) { // not required
		return nil
	}

	// value enum
	if err := m.validateFilingTypeIDEnum("filingTypeId", "body", m.FilingTypeID); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) validateIaBen(formats strfmt.Registry) error {
	if swag.IsZero(m.IaBen) { // not required
		return nil
	}

	if err := validate.MinLength("iaBen", "body", *m.IaBen, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("iaBen", "body", *m.IaBen, 50); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) validateInternalNotes(formats strfmt.Registry) error {
	if swag.IsZero(m.InternalNotes) { // not required
		return nil
	}

	if err := validate.MinLength("internalNotes", "body", *m.InternalNotes, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("internalNotes", "body", *m.InternalNotes, 1000); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) validateLegalEntityName(formats strfmt.Registry) error {
	if swag.IsZero(m.LegalEntityName) { // not required
		return nil
	}

	if err := validate.MinLength("legalEntityName", "body", *m.LegalEntityName, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("legalEntityName", "body", *m.LegalEntityName, 75); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) validateLine1(formats strfmt.Registry) error {
	if swag.IsZero(m.Line1) { // not required
		return nil
	}

	if err := validate.MinLength("line1", "body", *m.Line1, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("line1", "body", *m.Line1, 50); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) validateLine2(formats strfmt.Registry) error {
	if swag.IsZero(m.Line2) { // not required
		return nil
	}

	if err := validate.MinLength("line2", "body", *m.Line2, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("line2", "body", *m.Line2, 50); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) validateLocalRegistrationID(formats strfmt.Registry) error {
	if swag.IsZero(m.LocalRegistrationID) { // not required
		return nil
	}

	if err := validate.MinLength("localRegistrationId", "body", *m.LocalRegistrationID, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("localRegistrationId", "body", *m.LocalRegistrationID, 50); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) validateLocationCode(formats strfmt.Registry) error {
	if swag.IsZero(m.LocationCode) { // not required
		return nil
	}

	if err := validate.MinLength("locationCode", "body", *m.LocationCode, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("locationCode", "body", *m.LocationCode, 50); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) validateMailingAddressCity(formats strfmt.Registry) error {
	if swag.IsZero(m.MailingAddressCity) { // not required
		return nil
	}

	if err := validate.MinLength("mailingAddressCity", "body", *m.MailingAddressCity, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("mailingAddressCity", "body", *m.MailingAddressCity, 50); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) validateMailingAddressLine1(formats strfmt.Registry) error {
	if swag.IsZero(m.MailingAddressLine1) { // not required
		return nil
	}

	if err := validate.MinLength("mailingAddressLine1", "body", *m.MailingAddressLine1, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("mailingAddressLine1", "body", *m.MailingAddressLine1, 50); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) validateMailingAddressLine2(formats strfmt.Registry) error {
	if swag.IsZero(m.MailingAddressLine2) { // not required
		return nil
	}

	if err := validate.MinLength("mailingAddressLine2", "body", *m.MailingAddressLine2, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("mailingAddressLine2", "body", *m.MailingAddressLine2, 50); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) validateMailingAddressPostalCode(formats strfmt.Registry) error {
	if swag.IsZero(m.MailingAddressPostalCode) { // not required
		return nil
	}

	if err := validate.MinLength("mailingAddressPostalCode", "body", *m.MailingAddressPostalCode, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("mailingAddressPostalCode", "body", *m.MailingAddressPostalCode, 25); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) validateMeBusinessCode(formats strfmt.Registry) error {
	if swag.IsZero(m.MeBusinessCode) { // not required
		return nil
	}

	if err := validate.MinLength("meBusinessCode", "body", *m.MeBusinessCode, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("meBusinessCode", "body", *m.MeBusinessCode, 50); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) validateModifiedDate(formats strfmt.Registry) error {
	if swag.IsZero(m.ModifiedDate) { // not required
		return nil
	}

	if err := validate.FormatOf("modifiedDate", "body", "date-time", m.ModifiedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) validateOther1Name(formats strfmt.Registry) error {
	if swag.IsZero(m.Other1Name) { // not required
		return nil
	}

	if err := validate.MinLength("other1Name", "body", *m.Other1Name, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("other1Name", "body", *m.Other1Name, 50); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) validateOther1Value(formats strfmt.Registry) error {
	if swag.IsZero(m.Other1Value) { // not required
		return nil
	}

	if err := validate.MinLength("other1Value", "body", *m.Other1Value, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("other1Value", "body", *m.Other1Value, 50); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) validateOther2Name(formats strfmt.Registry) error {
	if swag.IsZero(m.Other2Name) { // not required
		return nil
	}

	if err := validate.MinLength("other2Name", "body", *m.Other2Name, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("other2Name", "body", *m.Other2Name, 50); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) validateOther2Value(formats strfmt.Registry) error {
	if swag.IsZero(m.Other2Value) { // not required
		return nil
	}

	if err := validate.MinLength("other2Value", "body", *m.Other2Value, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("other2Value", "body", *m.Other2Value, 50); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) validateOther3Name(formats strfmt.Registry) error {
	if swag.IsZero(m.Other3Name) { // not required
		return nil
	}

	if err := validate.MinLength("other3Name", "body", *m.Other3Name, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("other3Name", "body", *m.Other3Name, 50); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) validateOther3Value(formats strfmt.Registry) error {
	if swag.IsZero(m.Other3Value) { // not required
		return nil
	}

	if err := validate.MinLength("other3Value", "body", *m.Other3Value, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("other3Value", "body", *m.Other3Value, 50); err != nil {
		return err
	}

	return nil
}

var filingCalendarModelTypeOutletTypeIDPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["None","Schedule","Duplicate","Consolidated"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		filingCalendarModelTypeOutletTypeIDPropEnum = append(filingCalendarModelTypeOutletTypeIDPropEnum, v)
	}
}

const (

	// FilingCalendarModelOutletTypeIDNone captures enum value "None"
	FilingCalendarModelOutletTypeIDNone string = "None"

	// FilingCalendarModelOutletTypeIDSchedule captures enum value "Schedule"
	FilingCalendarModelOutletTypeIDSchedule string = "Schedule"

	// FilingCalendarModelOutletTypeIDDuplicate captures enum value "Duplicate"
	FilingCalendarModelOutletTypeIDDuplicate string = "Duplicate"

	// FilingCalendarModelOutletTypeIDConsolidated captures enum value "Consolidated"
	FilingCalendarModelOutletTypeIDConsolidated string = "Consolidated"
)

// prop value enum
func (m *FilingCalendarModel) validateOutletTypeIDEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, filingCalendarModelTypeOutletTypeIDPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FilingCalendarModel) validateOutletTypeID(formats strfmt.Registry) error {
	if swag.IsZero(m.OutletTypeID) { // not required
		return nil
	}

	// value enum
	if err := m.validateOutletTypeIDEnum("outletTypeId", "body", m.OutletTypeID); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) validatePaymentCurrency(formats strfmt.Registry) error {
	if swag.IsZero(m.PaymentCurrency) { // not required
		return nil
	}

	if err := validate.MinLength("paymentCurrency", "body", *m.PaymentCurrency, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("paymentCurrency", "body", *m.PaymentCurrency, 3); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) validatePhone(formats strfmt.Registry) error {
	if swag.IsZero(m.Phone) { // not required
		return nil
	}

	if err := validate.MinLength("phone", "body", *m.Phone, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("phone", "body", *m.Phone, 50); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(m.PostalCode) { // not required
		return nil
	}

	if err := validate.MinLength("postalCode", "body", *m.PostalCode, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("postalCode", "body", *m.PostalCode, 25); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) validateRegion(formats strfmt.Registry) error {
	if swag.IsZero(m.Region) { // not required
		return nil
	}

	if err := validate.MinLength("region", "body", *m.Region, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("region", "body", *m.Region, 3); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) validateReturnName(formats strfmt.Registry) error {
	if swag.IsZero(m.ReturnName) { // not required
		return nil
	}

	if err := validate.MinLength("returnName", "body", *m.ReturnName, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("returnName", "body", *m.ReturnName, 50); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) validateSettings(formats strfmt.Registry) error {
	if swag.IsZero(m.Settings) { // not required
		return nil
	}

	for i := 0; i < len(m.Settings); i++ {
		if swag.IsZero(m.Settings[i]) { // not required
			continue
		}

		if m.Settings[i] != nil {
			if err := m.Settings[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("settings" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("settings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *FilingCalendarModel) validateStateRegistrationID(formats strfmt.Registry) error {
	if swag.IsZero(m.StateRegistrationID) { // not required
		return nil
	}

	if err := validate.MinLength("stateRegistrationId", "body", *m.StateRegistrationID, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("stateRegistrationId", "body", *m.StateRegistrationID, 50); err != nil {
		return err
	}

	return nil
}

var filingCalendarModelTypeTaxTypeIDPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["E","Lodging","Bottle","RentToOwn","BikeTax","LandedCost","CheckoutBag","Alcohol","Amusement","Hospitality","RentalLeasing","GrossReceipts","Mattress","Lumber","Paint","Tires","EI","All","BothSalesAndUseTax","ConsumerUseTax","ConsumersUseAndSellersUseTax","ConsumerUseAndSalesTax","Fee","VATInputTax","LightBulbs","Meals","VATNonrecoverableInputTax","VATOutputTax","PIF","Rental","SalesTax","UseTax","EWaste","Batteries"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		filingCalendarModelTypeTaxTypeIDPropEnum = append(filingCalendarModelTypeTaxTypeIDPropEnum, v)
	}
}

const (

	// FilingCalendarModelTaxTypeIDE captures enum value "E"
	FilingCalendarModelTaxTypeIDE string = "E"

	// FilingCalendarModelTaxTypeIDLodging captures enum value "Lodging"
	FilingCalendarModelTaxTypeIDLodging string = "Lodging"

	// FilingCalendarModelTaxTypeIDBottle captures enum value "Bottle"
	FilingCalendarModelTaxTypeIDBottle string = "Bottle"

	// FilingCalendarModelTaxTypeIDRentToOwn captures enum value "RentToOwn"
	FilingCalendarModelTaxTypeIDRentToOwn string = "RentToOwn"

	// FilingCalendarModelTaxTypeIDBikeTax captures enum value "BikeTax"
	FilingCalendarModelTaxTypeIDBikeTax string = "BikeTax"

	// FilingCalendarModelTaxTypeIDLandedCost captures enum value "LandedCost"
	FilingCalendarModelTaxTypeIDLandedCost string = "LandedCost"

	// FilingCalendarModelTaxTypeIDCheckoutBag captures enum value "CheckoutBag"
	FilingCalendarModelTaxTypeIDCheckoutBag string = "CheckoutBag"

	// FilingCalendarModelTaxTypeIDAlcohol captures enum value "Alcohol"
	FilingCalendarModelTaxTypeIDAlcohol string = "Alcohol"

	// FilingCalendarModelTaxTypeIDAmusement captures enum value "Amusement"
	FilingCalendarModelTaxTypeIDAmusement string = "Amusement"

	// FilingCalendarModelTaxTypeIDHospitality captures enum value "Hospitality"
	FilingCalendarModelTaxTypeIDHospitality string = "Hospitality"

	// FilingCalendarModelTaxTypeIDRentalLeasing captures enum value "RentalLeasing"
	FilingCalendarModelTaxTypeIDRentalLeasing string = "RentalLeasing"

	// FilingCalendarModelTaxTypeIDGrossReceipts captures enum value "GrossReceipts"
	FilingCalendarModelTaxTypeIDGrossReceipts string = "GrossReceipts"

	// FilingCalendarModelTaxTypeIDMattress captures enum value "Mattress"
	FilingCalendarModelTaxTypeIDMattress string = "Mattress"

	// FilingCalendarModelTaxTypeIDLumber captures enum value "Lumber"
	FilingCalendarModelTaxTypeIDLumber string = "Lumber"

	// FilingCalendarModelTaxTypeIDPaint captures enum value "Paint"
	FilingCalendarModelTaxTypeIDPaint string = "Paint"

	// FilingCalendarModelTaxTypeIDTires captures enum value "Tires"
	FilingCalendarModelTaxTypeIDTires string = "Tires"

	// FilingCalendarModelTaxTypeIDEI captures enum value "EI"
	FilingCalendarModelTaxTypeIDEI string = "EI"

	// FilingCalendarModelTaxTypeIDAll captures enum value "All"
	FilingCalendarModelTaxTypeIDAll string = "All"

	// FilingCalendarModelTaxTypeIDBothSalesAndUseTax captures enum value "BothSalesAndUseTax"
	FilingCalendarModelTaxTypeIDBothSalesAndUseTax string = "BothSalesAndUseTax"

	// FilingCalendarModelTaxTypeIDConsumerUseTax captures enum value "ConsumerUseTax"
	FilingCalendarModelTaxTypeIDConsumerUseTax string = "ConsumerUseTax"

	// FilingCalendarModelTaxTypeIDConsumersUseAndSellersUseTax captures enum value "ConsumersUseAndSellersUseTax"
	FilingCalendarModelTaxTypeIDConsumersUseAndSellersUseTax string = "ConsumersUseAndSellersUseTax"

	// FilingCalendarModelTaxTypeIDConsumerUseAndSalesTax captures enum value "ConsumerUseAndSalesTax"
	FilingCalendarModelTaxTypeIDConsumerUseAndSalesTax string = "ConsumerUseAndSalesTax"

	// FilingCalendarModelTaxTypeIDFee captures enum value "Fee"
	FilingCalendarModelTaxTypeIDFee string = "Fee"

	// FilingCalendarModelTaxTypeIDVATInputTax captures enum value "VATInputTax"
	FilingCalendarModelTaxTypeIDVATInputTax string = "VATInputTax"

	// FilingCalendarModelTaxTypeIDLightBulbs captures enum value "LightBulbs"
	FilingCalendarModelTaxTypeIDLightBulbs string = "LightBulbs"

	// FilingCalendarModelTaxTypeIDMeals captures enum value "Meals"
	FilingCalendarModelTaxTypeIDMeals string = "Meals"

	// FilingCalendarModelTaxTypeIDVATNonrecoverableInputTax captures enum value "VATNonrecoverableInputTax"
	FilingCalendarModelTaxTypeIDVATNonrecoverableInputTax string = "VATNonrecoverableInputTax"

	// FilingCalendarModelTaxTypeIDVATOutputTax captures enum value "VATOutputTax"
	FilingCalendarModelTaxTypeIDVATOutputTax string = "VATOutputTax"

	// FilingCalendarModelTaxTypeIDPIF captures enum value "PIF"
	FilingCalendarModelTaxTypeIDPIF string = "PIF"

	// FilingCalendarModelTaxTypeIDRental captures enum value "Rental"
	FilingCalendarModelTaxTypeIDRental string = "Rental"

	// FilingCalendarModelTaxTypeIDSalesTax captures enum value "SalesTax"
	FilingCalendarModelTaxTypeIDSalesTax string = "SalesTax"

	// FilingCalendarModelTaxTypeIDUseTax captures enum value "UseTax"
	FilingCalendarModelTaxTypeIDUseTax string = "UseTax"

	// FilingCalendarModelTaxTypeIDEWaste captures enum value "EWaste"
	FilingCalendarModelTaxTypeIDEWaste string = "EWaste"

	// FilingCalendarModelTaxTypeIDBatteries captures enum value "Batteries"
	FilingCalendarModelTaxTypeIDBatteries string = "Batteries"
)

// prop value enum
func (m *FilingCalendarModel) validateTaxTypeIDEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, filingCalendarModelTypeTaxTypeIDPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FilingCalendarModel) validateTaxTypeID(formats strfmt.Registry) error {

	if err := validate.Required("taxTypeId", "body", m.TaxTypeID); err != nil {
		return err
	}

	// value enum
	if err := m.validateTaxTypeIDEnum("taxTypeId", "body", *m.TaxTypeID); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this filing calendar model based on the context it is used
func (m *FilingCalendarModel) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBulkAccountID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBulkAccountValidationStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCreatedDate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCreatedUserID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateModifiedDate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateModifiedUserID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSettings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSiteCode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTaxAuthorityID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTaxAuthorityName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTaxAuthorityType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FilingCalendarModel) contextValidateBulkAccountID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "bulkAccountId", "body", string(m.BulkAccountID)); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) contextValidateBulkAccountValidationStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "bulkAccountValidationStatus", "body", string(m.BulkAccountValidationStatus)); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) contextValidateCreatedDate(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "createdDate", "body", strfmt.DateTime(m.CreatedDate)); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) contextValidateCreatedUserID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "createdUserId", "body", int32(m.CreatedUserID)); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "id", "body", int64(m.ID)); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) contextValidateModifiedDate(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "modifiedDate", "body", strfmt.DateTime(m.ModifiedDate)); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) contextValidateModifiedUserID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "modifiedUserId", "body", int32(m.ModifiedUserID)); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) contextValidateSettings(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Settings); i++ {

		if m.Settings[i] != nil {
			if err := m.Settings[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("settings" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("settings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *FilingCalendarModel) contextValidateSiteCode(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "siteCode", "body", string(m.SiteCode)); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) contextValidateTaxAuthorityID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "taxAuthorityId", "body", int32(m.TaxAuthorityID)); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) contextValidateTaxAuthorityName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "taxAuthorityName", "body", string(m.TaxAuthorityName)); err != nil {
		return err
	}

	return nil
}

func (m *FilingCalendarModel) contextValidateTaxAuthorityType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "taxAuthorityType", "body", string(m.TaxAuthorityType)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FilingCalendarModel) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FilingCalendarModel) UnmarshalBinary(b []byte) error {
	var res FilingCalendarModel
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
