// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ComplianceJurisdictionModel Model for distinct jurisdictions.
// Example: {"city":"QUINCY","country":"US","county":"ADAMS","jurisdictionTypeId":"CIT","name":"QUINCY","rates":[{"effectiveDate":"1900-01-01","endDate":"9999-12-21","rate":0.005,"rateTypeId":"G","stackRate":0.005,"taxTypeId":"S"}],"region":"IL","stateAssignedCode":"001-0001-3 QUINCY","taxAuthorityId":275,"taxRegionId":2062642}
//
// swagger:model ComplianceJurisdictionModel
type ComplianceJurisdictionModel struct {

	// The name of the city.
	// Example: QUINCY
	// Read Only: true
	City string `json:"city,omitempty"`

	// Name or ISO 3166 code identifying the country of this jurisdiction.
	//
	// This field supports many different country identifiers:
	//  * Two character ISO 3166 codes
	//  * Three character ISO 3166 codes
	//  * Fully spelled out names of the country in ISO supported languages
	//  * Common alternative spellings for many countries
	//
	// For a full list of all supported codes and names, please see the Definitions API `ListCountries`.
	// Example: US
	// Read Only: true
	Country string `json:"country,omitempty"`

	// The name of the county.
	// Example: ADAMS
	// Read Only: true
	County string `json:"county,omitempty"`

	// The type of the jurisdiction, indicating whether it is a country, state/region, city, for example.
	// Example: CIT
	// Read Only: true
	JurisdictionTypeID string `json:"jurisdictionTypeId,omitempty"`

	// The name of the jurisdiction.
	// Example: QUINCY
	// Read Only: true
	Name string `json:"name,omitempty"`

	// Optional: A list of rates for this jurisdiction. To fetch this list, add the query string `?$include=TaxRates` to your URL.
	// Example: [{"effectiveDate":"1900-01-01","endDate":"9999-12-21","rate":0.005,"rateTypeId":"G","stackRate":0.005,"taxTypeId":"S"}]
	Rates []*ComplianceAggregatedTaxRateModel `json:"rates"`

	// Name or ISO 3166 code identifying the region within the country.
	//
	// This field supports many different region identifiers:
	//  * Two and three character ISO 3166 region codes
	//  * Fully spelled out names of the region in ISO supported languages
	//  * Common alternative spellings for many regions
	//
	// For a full list of all supported codes and names, please see the Definitions API `ListRegions`.
	// Example: IL
	// Read Only: true
	Region string `json:"region,omitempty"`

	// The state assigned code for the jurisdiction.
	// Example: 001-0001-3 QUINCY
	// Read Only: true
	StateAssignedCode string `json:"stateAssignedCode,omitempty"`

	// The id of the tax authority.
	// Example: 275
	TaxAuthorityID int32 `json:"taxAuthorityId,omitempty"`

	// The id of the tax region.
	// Example: 2062642
	// Read Only: true
	TaxRegionID int32 `json:"taxRegionId,omitempty"`

	// The name of the tax region.
	// Read Only: true
	TaxRegionName string `json:"taxRegionName,omitempty"`
}

// Validate validates this compliance jurisdiction model
func (m *ComplianceJurisdictionModel) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateRates(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComplianceJurisdictionModel) validateRates(formats strfmt.Registry) error {
	if swag.IsZero(m.Rates) { // not required
		return nil
	}

	for i := 0; i < len(m.Rates); i++ {
		if swag.IsZero(m.Rates[i]) { // not required
			continue
		}

		if m.Rates[i] != nil {
			if err := m.Rates[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("rates" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("rates" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this compliance jurisdiction model based on the context it is used
func (m *ComplianceJurisdictionModel) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCountry(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCounty(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateJurisdictionTypeID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRates(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRegion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStateAssignedCode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTaxRegionID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTaxRegionName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComplianceJurisdictionModel) contextValidateCity(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "city", "body", string(m.City)); err != nil {
		return err
	}

	return nil
}

func (m *ComplianceJurisdictionModel) contextValidateCountry(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "country", "body", string(m.Country)); err != nil {
		return err
	}

	return nil
}

func (m *ComplianceJurisdictionModel) contextValidateCounty(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "county", "body", string(m.County)); err != nil {
		return err
	}

	return nil
}

func (m *ComplianceJurisdictionModel) contextValidateJurisdictionTypeID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "jurisdictionTypeId", "body", string(m.JurisdictionTypeID)); err != nil {
		return err
	}

	return nil
}

func (m *ComplianceJurisdictionModel) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "name", "body", string(m.Name)); err != nil {
		return err
	}

	return nil
}

func (m *ComplianceJurisdictionModel) contextValidateRates(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Rates); i++ {

		if m.Rates[i] != nil {
			if err := m.Rates[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("rates" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("rates" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComplianceJurisdictionModel) contextValidateRegion(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "region", "body", string(m.Region)); err != nil {
		return err
	}

	return nil
}

func (m *ComplianceJurisdictionModel) contextValidateStateAssignedCode(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "stateAssignedCode", "body", string(m.StateAssignedCode)); err != nil {
		return err
	}

	return nil
}

func (m *ComplianceJurisdictionModel) contextValidateTaxRegionID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "taxRegionId", "body", int32(m.TaxRegionID)); err != nil {
		return err
	}

	return nil
}

func (m *ComplianceJurisdictionModel) contextValidateTaxRegionName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "taxRegionName", "body", string(m.TaxRegionName)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ComplianceJurisdictionModel) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComplianceJurisdictionModel) UnmarshalBinary(b []byte) error {
	var res ComplianceJurisdictionModel
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
