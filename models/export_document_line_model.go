// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ExportDocumentLineModel An input model for executing a report detailed to the document line level
// Example: {"country":"US","currencyCode":"USD","dateFilter":"DocumentDate","docType":"Sales","documentStatus":"Committed","endDate":"2021-12-25T00:00:00+00:00","format":"CSV","isLocked":true,"isModifiedDateSameAsDocumentDate":false,"merchantSellerIdentifier":"abc,xyz","numberOfPartitions":10,"partition":0,"startDate":"2021-11-25T00:00:00+00:00","state":"All","taxCode":"123","taxGroup":"Alcohol","taxName":"VAT","taxSubType":"Prepared Food and Beverage"}
//
// swagger:model ExportDocumentLineModel
type ExportDocumentLineModel struct {

	// The transactions in the country you wish to run a report.
	// Use "ALL" for all countries
	// Use "ALL Non-US" for all international countries
	// Or use a single 2-char ISO country code
	// Example: US
	Country string `json:"country,omitempty"`

	// The currency your report is displayed in.
	// Accepts "USD" or leave this blank to get all the documents with all the currencies
	// Example: USD
	CurrencyCode string `json:"currencyCode,omitempty"`

	// The code your business application uses to identify a customer or vendor
	CustomerVendorCode string `json:"customerVendorCode,omitempty"`

	// The type of date to filter your transactions
	// Example: DocumentDate
	// Enum: [DocumentDate ModifiedDate PaymentDate ReportingDate TaxDate]
	DateFilter string `json:"dateFilter,omitempty"`

	// The transaction type you want to run a report on
	// Example: ConsumerUse
	// Enum: [ConsumerUse Sales]
	DocType string `json:"docType,omitempty"`

	// DocumentStatus
	// For documentStatus, accepted values are: Saved, Posted, Committed, Cancelled
	// Example: Temporary
	// Enum: [Temporary Saved Posted Committed Cancelled Adjusted Queued PendingApproval Any]
	DocumentStatus string `json:"documentStatus,omitempty"`

	// The end date filter for report execution. If no date provided, today's date will be used as the endDate.
	// Accepts date in short format yyyy-mm-dd as well as date time stamp
	// Example: 2021-12-25T00:00:00+00:00
	// Format: date-time
	EndDate strfmt.DateTime `json:"endDate,omitempty"`

	// The file format.
	// Example: CSV
	// Enum: [CSV]
	Format string `json:"format,omitempty"`

	// If true, include only documents that are locked.
	// If false, include only documents that are not locked.
	// Defaults to false if not specified.
	// Example: true
	IsLocked bool `json:"isLocked,omitempty"`

	// Use this parameter when dateFilter = ModifiedDate.
	// For dateFilter = DocumentDate, PaymentDate, TaxDate or ReportingDate, the isModifiedDateSameAsDocumentDate parameter is ignored.
	// Set this parameter to true when you would like to get Documents which have the Document Date same as Modified Date.
	// Defaults to false if not specified.
	// Example: false
	IsModifiedDateSameAsDocumentDate bool `json:"isModifiedDateSameAsDocumentDate,omitempty"`

	// If set, include only documents associated with these merchantSellerIds.Multiple merchantSellerIds should be sent by comma separated values.
	// Example: abc,xyz
	MerchantSellerIdentifier string `json:"merchantSellerIdentifier,omitempty"`

	// Number of partitions (2 - 250) to split the report into.
	// If a value is provided for this property, a value must also be provided for the partition property.
	// Example: 10
	NumberOfPartitions int32 `json:"numberOfPartitions,omitempty"`

	// The zero-based partition number to retrieve in this export request.
	// If a value is provided for this property, a value must also be provided for the numberOfPartitions property.
	// Example: 0
	Partition int32 `json:"partition,omitempty"`

	// The start date filter for report execution. If no date provided, same date of last month will be used as the startDate.
	// Accepts date in short format yyyy-mm-dd as well as date time stamp
	// Example: 2021-11-25T00:00:00+00:00
	// Format: date-time
	StartDate strfmt.DateTime `json:"startDate,omitempty"`

	// The state associated with the transactions you wish to run a report.
	// Use "ALL" for all states or 2-char state code.
	// Example: All
	State string `json:"state,omitempty"`

	// The AvaTax tax code or customer tax code associated with the item or SKU in the transaction
	// Example: 123
	TaxCode string `json:"taxCode,omitempty"`

	// TaxGroup is required to support Sales tax (Sales + SellersUse) and VAT (Input+ Output).
	// TaxTypes, such as Lodging, Bottle, LandedCost, Ewaste, BevAlc, etc
	// Example: Alcohol
	TaxGroup string `json:"taxGroup,omitempty"`

	// The description of the tax
	// Example: VAT
	TaxName string `json:"taxName,omitempty"`

	// Defines the individual taxes associated with a TaxType category, such as Lodging TaxType which supports numerous TaxSubTypes, including Hotel, Occupancy, ConventionCenter, Accommotations, etc.
	// Example: Prepared Food and Beverage
	TaxSubType string `json:"taxSubType,omitempty"`
}

// Validate validates this export document line model
func (m *ExportDocumentLineModel) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDateFilter(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDocType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDocumentStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEndDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFormat(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStartDate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var exportDocumentLineModelTypeDateFilterPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["DocumentDate","ModifiedDate","PaymentDate","ReportingDate","TaxDate"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		exportDocumentLineModelTypeDateFilterPropEnum = append(exportDocumentLineModelTypeDateFilterPropEnum, v)
	}
}

const (

	// ExportDocumentLineModelDateFilterDocumentDate captures enum value "DocumentDate"
	ExportDocumentLineModelDateFilterDocumentDate string = "DocumentDate"

	// ExportDocumentLineModelDateFilterModifiedDate captures enum value "ModifiedDate"
	ExportDocumentLineModelDateFilterModifiedDate string = "ModifiedDate"

	// ExportDocumentLineModelDateFilterPaymentDate captures enum value "PaymentDate"
	ExportDocumentLineModelDateFilterPaymentDate string = "PaymentDate"

	// ExportDocumentLineModelDateFilterReportingDate captures enum value "ReportingDate"
	ExportDocumentLineModelDateFilterReportingDate string = "ReportingDate"

	// ExportDocumentLineModelDateFilterTaxDate captures enum value "TaxDate"
	ExportDocumentLineModelDateFilterTaxDate string = "TaxDate"
)

// prop value enum
func (m *ExportDocumentLineModel) validateDateFilterEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, exportDocumentLineModelTypeDateFilterPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ExportDocumentLineModel) validateDateFilter(formats strfmt.Registry) error {
	if swag.IsZero(m.DateFilter) { // not required
		return nil
	}

	// value enum
	if err := m.validateDateFilterEnum("dateFilter", "body", m.DateFilter); err != nil {
		return err
	}

	return nil
}

var exportDocumentLineModelTypeDocTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ConsumerUse","Sales"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		exportDocumentLineModelTypeDocTypePropEnum = append(exportDocumentLineModelTypeDocTypePropEnum, v)
	}
}

const (

	// ExportDocumentLineModelDocTypeConsumerUse captures enum value "ConsumerUse"
	ExportDocumentLineModelDocTypeConsumerUse string = "ConsumerUse"

	// ExportDocumentLineModelDocTypeSales captures enum value "Sales"
	ExportDocumentLineModelDocTypeSales string = "Sales"
)

// prop value enum
func (m *ExportDocumentLineModel) validateDocTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, exportDocumentLineModelTypeDocTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ExportDocumentLineModel) validateDocType(formats strfmt.Registry) error {
	if swag.IsZero(m.DocType) { // not required
		return nil
	}

	// value enum
	if err := m.validateDocTypeEnum("docType", "body", m.DocType); err != nil {
		return err
	}

	return nil
}

var exportDocumentLineModelTypeDocumentStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Temporary","Saved","Posted","Committed","Cancelled","Adjusted","Queued","PendingApproval","Any"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		exportDocumentLineModelTypeDocumentStatusPropEnum = append(exportDocumentLineModelTypeDocumentStatusPropEnum, v)
	}
}

const (

	// ExportDocumentLineModelDocumentStatusTemporary captures enum value "Temporary"
	ExportDocumentLineModelDocumentStatusTemporary string = "Temporary"

	// ExportDocumentLineModelDocumentStatusSaved captures enum value "Saved"
	ExportDocumentLineModelDocumentStatusSaved string = "Saved"

	// ExportDocumentLineModelDocumentStatusPosted captures enum value "Posted"
	ExportDocumentLineModelDocumentStatusPosted string = "Posted"

	// ExportDocumentLineModelDocumentStatusCommitted captures enum value "Committed"
	ExportDocumentLineModelDocumentStatusCommitted string = "Committed"

	// ExportDocumentLineModelDocumentStatusCancelled captures enum value "Cancelled"
	ExportDocumentLineModelDocumentStatusCancelled string = "Cancelled"

	// ExportDocumentLineModelDocumentStatusAdjusted captures enum value "Adjusted"
	ExportDocumentLineModelDocumentStatusAdjusted string = "Adjusted"

	// ExportDocumentLineModelDocumentStatusQueued captures enum value "Queued"
	ExportDocumentLineModelDocumentStatusQueued string = "Queued"

	// ExportDocumentLineModelDocumentStatusPendingApproval captures enum value "PendingApproval"
	ExportDocumentLineModelDocumentStatusPendingApproval string = "PendingApproval"

	// ExportDocumentLineModelDocumentStatusAny captures enum value "Any"
	ExportDocumentLineModelDocumentStatusAny string = "Any"
)

// prop value enum
func (m *ExportDocumentLineModel) validateDocumentStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, exportDocumentLineModelTypeDocumentStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ExportDocumentLineModel) validateDocumentStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.DocumentStatus) { // not required
		return nil
	}

	// value enum
	if err := m.validateDocumentStatusEnum("documentStatus", "body", m.DocumentStatus); err != nil {
		return err
	}

	return nil
}

func (m *ExportDocumentLineModel) validateEndDate(formats strfmt.Registry) error {
	if swag.IsZero(m.EndDate) { // not required
		return nil
	}

	if err := validate.FormatOf("endDate", "body", "date-time", m.EndDate.String(), formats); err != nil {
		return err
	}

	return nil
}

var exportDocumentLineModelTypeFormatPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["CSV"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		exportDocumentLineModelTypeFormatPropEnum = append(exportDocumentLineModelTypeFormatPropEnum, v)
	}
}

const (

	// ExportDocumentLineModelFormatCSV captures enum value "CSV"
	ExportDocumentLineModelFormatCSV string = "CSV"
)

// prop value enum
func (m *ExportDocumentLineModel) validateFormatEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, exportDocumentLineModelTypeFormatPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ExportDocumentLineModel) validateFormat(formats strfmt.Registry) error {
	if swag.IsZero(m.Format) { // not required
		return nil
	}

	// value enum
	if err := m.validateFormatEnum("format", "body", m.Format); err != nil {
		return err
	}

	return nil
}

func (m *ExportDocumentLineModel) validateStartDate(formats strfmt.Registry) error {
	if swag.IsZero(m.StartDate) { // not required
		return nil
	}

	if err := validate.FormatOf("startDate", "body", "date-time", m.StartDate.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this export document line model based on context it is used
func (m *ExportDocumentLineModel) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ExportDocumentLineModel) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ExportDocumentLineModel) UnmarshalBinary(b []byte) error {
	var res ExportDocumentLineModel
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
