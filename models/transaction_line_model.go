// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// TransactionLineModel One line item on this transaction.
// Example: {"boundaryOverrideId":0,"description":"Yarn","destinationAddressId":12345,"details":[{"addressId":12345,"country":"US","exemptAmount":0,"exemptReasonId":4,"exemptUnits":62.5,"id":123456789,"inState":false,"jurisCode":"06","jurisName":"CALIFORNIA","jurisType":"STA","jurisdictionId":5000531,"nonTaxableAmount":0,"nonTaxableRuleId":0,"nonTaxableType":"BaseRule","nonTaxableUnits":1000,"rate":0.0625,"rateRuleId":1321915,"rateSourceId":3,"rateType":"General","region":"CA","reportingExemptUnits":125,"reportingNonTaxableUnits":2000,"reportingTax":125,"reportingTaxCalculated":125,"reportingTaxableUnits":125,"serCode":"","signatureCode":"AGAM","sourcing":"Destination","stateAssignedNo":"","stateFIPS":"06","tax":62.5,"taxAuthorityTypeId":45,"taxCalculated":62.5,"taxName":"CA STATE TAX","taxOverride":0,"taxRegionId":2127184,"taxType":"Sales","taxableAmount":1000,"taxableUnits":62.5,"transactionId":123456789,"transactionLineId":123456789}],"discountAmount":100,"discountTypeId":0,"entityUseCode":"","exemptAmount":0,"exemptCertId":0,"exemptNo":"","id":123456789,"isItemTaxable":true,"isSSTP":false,"itemCode":"116292","lineAmount":1000,"lineNumber":"1","originAddressId":123456789,"quantity":1,"ref1":"Note: Deliver to Bob","reportingDate":"2021-12-25","revAccount":"","sourcing":"Destination","tax":62.5,"taxCalculated":62.5,"taxCode":"PS081282","taxDate":"2021-12-25","taxEngine":"","taxIncluded":false,"taxOverrideAmount":0,"taxOverrideReason":"","taxOverrideType":"None","taxableAmount":1000,"transactionId":123456789,"vatNumberTypeId":0}
//
// swagger:model TransactionLineModel
type TransactionLineModel struct {

	// The unique ID number of the boundary override applied to this line item.
	// Example: 0
	BoundaryOverrideID int32 `json:"boundaryOverrideId,omitempty"`

	// VAT business identification number used for this transaction.
	BusinessIdentificationNo string `json:"businessIdentificationNo,omitempty"`

	// Product category breadcrumbs. This is the full path to the category where item is included. Categories should be separated by “ > “.  Multiple category paths per item are accepted. In this case, category paths should be separated by “;”.
	Category string `json:"category,omitempty"`

	// The CertCapture Certificate ID
	// Read Only: true
	CertificateID string `json:"certificateId,omitempty"`

	// Indicates the cost of insurance and freight for this line.
	CostInsuranceFreight float64 `json:"costInsuranceFreight,omitempty"`

	// DEPRECATED - Date: 10/16/2017, Version: 17.11, Message: Please use entityUseCode instead.
	// The customer usage type for this line item.  Usage type often affects taxability rules.
	CustomerUsageType string `json:"customerUsageType,omitempty"`

	// Deemed Supplier field indicates which party on the marketplace transaction is liable for collecting and reporting the VAT. This is based on the 2021 E-commerce legislative reforms in EU and UK. This field will not be used until after July 1, 2021.
	// Example: Marketplace
	// Enum: [Marketplace Merchant]
	DeemedSupplier string `json:"deemedSupplier,omitempty"`

	// A description of the item or service represented by this line.
	// Example: Yarn
	Description string `json:"description,omitempty"`

	// The unique ID number of the destination address where this line was delivered or sold.
	// In the case of a point-of-sale transaction, the destination address and origin address will be the same.
	// In the case of a shipped transaction, they will be different.
	// Example: 12345
	DestinationAddressID int64 `json:"destinationAddressId,omitempty"`

	// Optional: A list of tax details for this line item.
	//
	// Tax details represent taxes being charged by various tax authorities. Taxes that appear in the `details` collection are intended to be
	// displayed to the customer and charged as a 'tax' on the invoice.
	//
	// To fetch this list, add the query string `?$include=Details` to your URL.
	// Example: [{"addressId":12345,"country":"US","exemptAmount":0,"exemptReasonId":4,"exemptUnits":62.5,"id":123456789,"inState":false,"jurisCode":"06","jurisName":"CALIFORNIA","jurisType":"STA","jurisdictionId":5000531,"nonTaxableAmount":0,"nonTaxableRuleId":0,"nonTaxableType":"BaseRule","nonTaxableUnits":1000,"rate":0.0625,"rateRuleId":1321915,"rateSourceId":3,"rateType":"General","region":"CA","reportingExemptUnits":125,"reportingNonTaxableUnits":2000,"reportingTax":125,"reportingTaxCalculated":125,"reportingTaxableUnits":125,"serCode":"","signatureCode":"AGAM","sourcing":"Destination","stateAssignedNo":"","stateFIPS":"06","tax":62.5,"taxAuthorityTypeId":45,"taxCalculated":62.5,"taxName":"CA STATE TAX","taxOverride":0,"taxRegionId":2127184,"taxType":"Sales","taxableAmount":1000,"taxableUnits":62.5,"transactionId":123456789,"transactionLineId":123456789}]
	Details []*TransactionLineDetailModel `json:"details"`

	// The amount of discount that was applied to this line item.  This represents the difference between list price and sale price of the item.
	// In general, a discount represents money that did not change hands; tax is calculated on only the amount of money that changed hands.
	// Example: 100
	DiscountAmount float64 `json:"discountAmount,omitempty"`

	// The type of discount, if any, that was applied to this line item.
	// Example: 0
	DiscountTypeID int32 `json:"discountTypeId,omitempty"`

	// The entity use code for this line item.  Usage type often affects taxability rules.
	EntityUseCode string `json:"entityUseCode,omitempty"`

	// The amount of this line item that was exempt.
	// Example: 0
	ExemptAmount float64 `json:"exemptAmount,omitempty"`

	// The unique ID number of the exemption certificate that applied to this line item. It is the calc_id associated with a certificate in CertCapture.
	// Example: 0
	ExemptCertID int32 `json:"exemptCertId,omitempty"`

	// The customer Tax Id Number (tax_number) associated with a certificate - Sales tax calculation requests first determine if there is an applicable
	// ECMS entry available, and will utilize it for exemption processing. If no applicable ECMS entry is available, the AvaTax service
	// will determine if an Exemption Number field is populated or an Entity/Use Code is included in the sales tax calculation request,
	// and will perform exemption processing using either of those two options.
	ExemptNo string `json:"exemptNo,omitempty"`

	// The cross-border harmonized system code (HSCode) used to calculate tariffs and duties for this line item.
	// For a full list of HS codes, see `ListCrossBorderCodes()`.
	HsCode string `json:"hsCode,omitempty"`

	// The unique ID number of this transaction line item.
	// Example: 123456789
	ID int64 `json:"id,omitempty"`

	// True if this item is taxable.
	// Example: true
	IsItemTaxable bool `json:"isItemTaxable,omitempty"`

	// True if this item is a Streamlined Sales Tax line item.
	// Example: false
	IsSSTP bool `json:"isSSTP,omitempty"`

	// The code string of the item represented by this line item.
	// Example: 116292
	ItemCode string `json:"itemCode,omitempty"`

	// The total amount of the transaction, including both taxable and exempt.  This is the total price for all items.
	// To determine the individual item price, divide this by quantity.
	// Example: 1000
	LineAmount float64 `json:"lineAmount,omitempty"`

	// Optional: A list of location types for this line item.  To fetch this list, add the query string "?$include=LineLocationTypes" to your URL.
	LineLocationTypes []*TransactionLineLocationTypeModel `json:"lineLocationTypes"`

	// The line number or code indicating the line on this invoice or receipt or document.
	// Example: 1
	LineNumber string `json:"lineNumber,omitempty"`

	// This field will identify who is remitting Marketplace or Seller. This field must be populated by Marketplace.
	// Example: Marketplace
	// Enum: [Marketplace Seller]
	MarketplaceLiabilityType string `json:"marketplaceLiabilityType,omitempty"`

	// DEPRECATED - Date: 04/15/2021, Version: 21.4, Message: Please use merchantSellerIdentifier instead.
	// ID of the merchant selling on the Marketplace. This field must be populated by Marketplace.
	MerchantSellerID int64 `json:"merchantSellerId,omitempty"`

	// ID of the merchant selling on the Marketplace. This field must be populated by Marketplace.
	MerchantSellerIdentifier string `json:"merchantSellerIdentifier,omitempty"`

	// Optional: A list of non-passthrough tax details for this line item.
	//
	// Tax details represent taxes being charged by various tax authorities. Taxes that appear in the `nonPassthroughDetails` collection are
	// taxes that must be paid directly by the company and not shown to the customer.
	NonPassthroughDetails []*TransactionLineDetailModel `json:"nonPassthroughDetails"`

	// The unique ID number of the origin address where this line was delivered or sold.
	// In the case of a point-of-sale transaction, the origin address and destination address will be the same.
	// In the case of a shipped transaction, they will be different.
	// Example: 123456789
	OriginAddressID int64 `json:"originAddressId,omitempty"`

	// The transaction's original ID in its origination system
	OriginationDocumentID string `json:"originationDocumentId,omitempty"`

	// Synonym of Marketplace Origination. Name of the Marketplace where the transaction originated from.
	OriginationSite string `json:"originationSite,omitempty"`

	// Contains a list of extra parameters that were set when the transaction was created.
	Parameters []*TransactionLineParameterModel `json:"parameters"`

	// The quantity of products sold on this line item.
	// Example: 1
	Quantity float64 `json:"quantity,omitempty"`

	// A user-defined reference identifier for this transaction line item.
	// Example: Note: Deliver to Bob
	Ref1 string `json:"ref1,omitempty"`

	// A user-defined reference identifier for this transaction line item.
	Ref2 string `json:"ref2,omitempty"`

	// The date when this transaction should be reported.  By default, all transactions are reported on the date when the actual transaction took place.
	// In some cases, line items may be reported later due to delayed shipments or other business reasons.
	// Example: 2021-12-25T00:00:00+00:00
	// Format: date
	ReportingDate strfmt.Date `json:"reportingDate,omitempty"`

	// The revenue account number for this line item.
	RevAccount string `json:"revAccount,omitempty"`

	// Indicates whether this line item was taxed according to the origin or destination.
	// Example: Mixed
	// Enum: [Mixed Destination Origin]
	Sourcing string `json:"sourcing,omitempty"`

	// A long description of the product.
	Summary string `json:"summary,omitempty"`

	// The tax for this line in this transaction.
	//
	// If you used a `taxOverride` of type `taxAmount` for this line, this value
	// will represent the amount of your override.  AvaTax will still attempt to calculate the correct tax
	// for this line and will store that calculated value in the `taxCalculated` field.
	//
	// You can compare the `tax` and `taxCalculated` fields to check for any discrepancies
	// between an external tax calculation provider and the calculation performed by AvaTax.
	// Example: 62.5
	Tax float64 `json:"tax,omitempty"`

	// Contains a list of TaxType that are to be overridden with their respective TaxOverrideAmount.
	TaxAmountByTaxTypes []*TransactionLineTaxAmountByTaxTypeModel `json:"taxAmountByTaxTypes"`

	// The amount of tax that AvaTax calculated for the transaction.
	//
	// If you used a `taxOverride` of type `taxAmount`, there may be a difference between
	// the `tax` field which applies your override, and the `taxCalculated` field which
	// represents the amount of tax that AvaTax calculated without the override.
	//
	// You can compare the `tax` and `taxCalculated` fields to check for any discrepancies
	// between an external tax calculation provider and the calculation performed by AvaTax.
	// Example: 62.5
	TaxCalculated float64 `json:"taxCalculated,omitempty"`

	// The code string for the tax code that was used to calculate this line item.
	// Example: PS081282
	TaxCode string `json:"taxCode,omitempty"`

	// The unique ID number for the tax code that was used to calculate this line item.
	TaxCodeID int32 `json:"taxCodeId,omitempty"`

	// The date that was used for calculating tax amounts for this line item.  By default, this date should be the same as the document date.
	// In some cases, for example when a consumer returns a product purchased previously, line items may be calculated using a tax date in the past
	// so that the consumer can receive a refund for the correct tax amount that was charged when the item was originally purchased.
	// Example: 2021-12-25T00:00:00+00:00
	// Format: date
	TaxDate strfmt.Date `json:"taxDate,omitempty"`

	// The tax engine identifier that was used to calculate this line item.
	TaxEngine string `json:"taxEngine,omitempty"`

	// Indicates whether the `amount` for this line already includes tax.
	//
	// If this value is `true`, the final price of this line including tax will equal the value in `amount`.
	//
	// If this value is `null` or `false`, the final price will equal `amount` plus whatever taxes apply to this line.
	// Example: false
	TaxIncluded bool `json:"taxIncluded,omitempty"`

	// If a tax override was specified, this indicates the amount of tax that was requested.
	// Example: 0
	TaxOverrideAmount float64 `json:"taxOverrideAmount,omitempty"`

	// If a tax override was specified, represents the reason for the tax override.
	TaxOverrideReason string `json:"taxOverrideReason,omitempty"`

	// If a tax override was specified, this indicates the type of tax override.
	// Example: None
	// Enum: [None TaxAmount Exemption TaxDate AccruedTaxAmount DeriveTaxable OutOfHarbor TaxAmountByTaxType]
	TaxOverrideType string `json:"taxOverrideType,omitempty"`

	// The taxable amount of this line item.
	// Example: 1000
	TaxableAmount float64 `json:"taxableAmount,omitempty"`

	// The unique ID number of the transaction to which this line item belongs.
	// Example: 123456789
	TransactionID int64 `json:"transactionId,omitempty"`

	// Custom user fields/flex fields for this transaction.
	UserDefinedFields []*TransactionLineUserDefinedFieldModel `json:"userDefinedFields"`

	// Indicates the VAT code for this line item.
	VatCode string `json:"vatCode,omitempty"`

	// Indicates the VAT number type for this line item.
	// Example: 0
	VatNumberTypeID int32 `json:"vatNumberTypeId,omitempty"`
}

// Validate validates this transaction line model
func (m *TransactionLineModel) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDeemedSupplier(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLineLocationTypes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMarketplaceLiabilityType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNonPassthroughDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateParameters(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReportingDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourcing(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTaxAmountByTaxTypes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTaxDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTaxOverrideType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserDefinedFields(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var transactionLineModelTypeDeemedSupplierPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Marketplace","Merchant"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		transactionLineModelTypeDeemedSupplierPropEnum = append(transactionLineModelTypeDeemedSupplierPropEnum, v)
	}
}

const (

	// TransactionLineModelDeemedSupplierMarketplace captures enum value "Marketplace"
	TransactionLineModelDeemedSupplierMarketplace string = "Marketplace"

	// TransactionLineModelDeemedSupplierMerchant captures enum value "Merchant"
	TransactionLineModelDeemedSupplierMerchant string = "Merchant"
)

// prop value enum
func (m *TransactionLineModel) validateDeemedSupplierEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, transactionLineModelTypeDeemedSupplierPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TransactionLineModel) validateDeemedSupplier(formats strfmt.Registry) error {
	if swag.IsZero(m.DeemedSupplier) { // not required
		return nil
	}

	// value enum
	if err := m.validateDeemedSupplierEnum("deemedSupplier", "body", m.DeemedSupplier); err != nil {
		return err
	}

	return nil
}

func (m *TransactionLineModel) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(m.Details) { // not required
		return nil
	}

	for i := 0; i < len(m.Details); i++ {
		if swag.IsZero(m.Details[i]) { // not required
			continue
		}

		if m.Details[i] != nil {
			if err := m.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TransactionLineModel) validateLineLocationTypes(formats strfmt.Registry) error {
	if swag.IsZero(m.LineLocationTypes) { // not required
		return nil
	}

	for i := 0; i < len(m.LineLocationTypes); i++ {
		if swag.IsZero(m.LineLocationTypes[i]) { // not required
			continue
		}

		if m.LineLocationTypes[i] != nil {
			if err := m.LineLocationTypes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("lineLocationTypes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("lineLocationTypes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var transactionLineModelTypeMarketplaceLiabilityTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Marketplace","Seller"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		transactionLineModelTypeMarketplaceLiabilityTypePropEnum = append(transactionLineModelTypeMarketplaceLiabilityTypePropEnum, v)
	}
}

const (

	// TransactionLineModelMarketplaceLiabilityTypeMarketplace captures enum value "Marketplace"
	TransactionLineModelMarketplaceLiabilityTypeMarketplace string = "Marketplace"

	// TransactionLineModelMarketplaceLiabilityTypeSeller captures enum value "Seller"
	TransactionLineModelMarketplaceLiabilityTypeSeller string = "Seller"
)

// prop value enum
func (m *TransactionLineModel) validateMarketplaceLiabilityTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, transactionLineModelTypeMarketplaceLiabilityTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TransactionLineModel) validateMarketplaceLiabilityType(formats strfmt.Registry) error {
	if swag.IsZero(m.MarketplaceLiabilityType) { // not required
		return nil
	}

	// value enum
	if err := m.validateMarketplaceLiabilityTypeEnum("marketplaceLiabilityType", "body", m.MarketplaceLiabilityType); err != nil {
		return err
	}

	return nil
}

func (m *TransactionLineModel) validateNonPassthroughDetails(formats strfmt.Registry) error {
	if swag.IsZero(m.NonPassthroughDetails) { // not required
		return nil
	}

	for i := 0; i < len(m.NonPassthroughDetails); i++ {
		if swag.IsZero(m.NonPassthroughDetails[i]) { // not required
			continue
		}

		if m.NonPassthroughDetails[i] != nil {
			if err := m.NonPassthroughDetails[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nonPassthroughDetails" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("nonPassthroughDetails" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TransactionLineModel) validateParameters(formats strfmt.Registry) error {
	if swag.IsZero(m.Parameters) { // not required
		return nil
	}

	for i := 0; i < len(m.Parameters); i++ {
		if swag.IsZero(m.Parameters[i]) { // not required
			continue
		}

		if m.Parameters[i] != nil {
			if err := m.Parameters[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("parameters" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("parameters" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TransactionLineModel) validateReportingDate(formats strfmt.Registry) error {
	if swag.IsZero(m.ReportingDate) { // not required
		return nil
	}

	if err := validate.FormatOf("reportingDate", "body", "date", m.ReportingDate.String(), formats); err != nil {
		return err
	}

	return nil
}

var transactionLineModelTypeSourcingPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Mixed","Destination","Origin"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		transactionLineModelTypeSourcingPropEnum = append(transactionLineModelTypeSourcingPropEnum, v)
	}
}

const (

	// TransactionLineModelSourcingMixed captures enum value "Mixed"
	TransactionLineModelSourcingMixed string = "Mixed"

	// TransactionLineModelSourcingDestination captures enum value "Destination"
	TransactionLineModelSourcingDestination string = "Destination"

	// TransactionLineModelSourcingOrigin captures enum value "Origin"
	TransactionLineModelSourcingOrigin string = "Origin"
)

// prop value enum
func (m *TransactionLineModel) validateSourcingEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, transactionLineModelTypeSourcingPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TransactionLineModel) validateSourcing(formats strfmt.Registry) error {
	if swag.IsZero(m.Sourcing) { // not required
		return nil
	}

	// value enum
	if err := m.validateSourcingEnum("sourcing", "body", m.Sourcing); err != nil {
		return err
	}

	return nil
}

func (m *TransactionLineModel) validateTaxAmountByTaxTypes(formats strfmt.Registry) error {
	if swag.IsZero(m.TaxAmountByTaxTypes) { // not required
		return nil
	}

	for i := 0; i < len(m.TaxAmountByTaxTypes); i++ {
		if swag.IsZero(m.TaxAmountByTaxTypes[i]) { // not required
			continue
		}

		if m.TaxAmountByTaxTypes[i] != nil {
			if err := m.TaxAmountByTaxTypes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taxAmountByTaxTypes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("taxAmountByTaxTypes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TransactionLineModel) validateTaxDate(formats strfmt.Registry) error {
	if swag.IsZero(m.TaxDate) { // not required
		return nil
	}

	if err := validate.FormatOf("taxDate", "body", "date", m.TaxDate.String(), formats); err != nil {
		return err
	}

	return nil
}

var transactionLineModelTypeTaxOverrideTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["None","TaxAmount","Exemption","TaxDate","AccruedTaxAmount","DeriveTaxable","OutOfHarbor","TaxAmountByTaxType"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		transactionLineModelTypeTaxOverrideTypePropEnum = append(transactionLineModelTypeTaxOverrideTypePropEnum, v)
	}
}

const (

	// TransactionLineModelTaxOverrideTypeNone captures enum value "None"
	TransactionLineModelTaxOverrideTypeNone string = "None"

	// TransactionLineModelTaxOverrideTypeTaxAmount captures enum value "TaxAmount"
	TransactionLineModelTaxOverrideTypeTaxAmount string = "TaxAmount"

	// TransactionLineModelTaxOverrideTypeExemption captures enum value "Exemption"
	TransactionLineModelTaxOverrideTypeExemption string = "Exemption"

	// TransactionLineModelTaxOverrideTypeTaxDate captures enum value "TaxDate"
	TransactionLineModelTaxOverrideTypeTaxDate string = "TaxDate"

	// TransactionLineModelTaxOverrideTypeAccruedTaxAmount captures enum value "AccruedTaxAmount"
	TransactionLineModelTaxOverrideTypeAccruedTaxAmount string = "AccruedTaxAmount"

	// TransactionLineModelTaxOverrideTypeDeriveTaxable captures enum value "DeriveTaxable"
	TransactionLineModelTaxOverrideTypeDeriveTaxable string = "DeriveTaxable"

	// TransactionLineModelTaxOverrideTypeOutOfHarbor captures enum value "OutOfHarbor"
	TransactionLineModelTaxOverrideTypeOutOfHarbor string = "OutOfHarbor"

	// TransactionLineModelTaxOverrideTypeTaxAmountByTaxType captures enum value "TaxAmountByTaxType"
	TransactionLineModelTaxOverrideTypeTaxAmountByTaxType string = "TaxAmountByTaxType"
)

// prop value enum
func (m *TransactionLineModel) validateTaxOverrideTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, transactionLineModelTypeTaxOverrideTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TransactionLineModel) validateTaxOverrideType(formats strfmt.Registry) error {
	if swag.IsZero(m.TaxOverrideType) { // not required
		return nil
	}

	// value enum
	if err := m.validateTaxOverrideTypeEnum("taxOverrideType", "body", m.TaxOverrideType); err != nil {
		return err
	}

	return nil
}

func (m *TransactionLineModel) validateUserDefinedFields(formats strfmt.Registry) error {
	if swag.IsZero(m.UserDefinedFields) { // not required
		return nil
	}

	for i := 0; i < len(m.UserDefinedFields); i++ {
		if swag.IsZero(m.UserDefinedFields[i]) { // not required
			continue
		}

		if m.UserDefinedFields[i] != nil {
			if err := m.UserDefinedFields[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("userDefinedFields" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("userDefinedFields" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this transaction line model based on the context it is used
func (m *TransactionLineModel) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCertificateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLineLocationTypes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNonPassthroughDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateParameters(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTaxAmountByTaxTypes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUserDefinedFields(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TransactionLineModel) contextValidateCertificateID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "certificateId", "body", string(m.CertificateID)); err != nil {
		return err
	}

	return nil
}

func (m *TransactionLineModel) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Details); i++ {

		if m.Details[i] != nil {
			if err := m.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TransactionLineModel) contextValidateLineLocationTypes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.LineLocationTypes); i++ {

		if m.LineLocationTypes[i] != nil {
			if err := m.LineLocationTypes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("lineLocationTypes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("lineLocationTypes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TransactionLineModel) contextValidateNonPassthroughDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.NonPassthroughDetails); i++ {

		if m.NonPassthroughDetails[i] != nil {
			if err := m.NonPassthroughDetails[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nonPassthroughDetails" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("nonPassthroughDetails" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TransactionLineModel) contextValidateParameters(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Parameters); i++ {

		if m.Parameters[i] != nil {
			if err := m.Parameters[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("parameters" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("parameters" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TransactionLineModel) contextValidateTaxAmountByTaxTypes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.TaxAmountByTaxTypes); i++ {

		if m.TaxAmountByTaxTypes[i] != nil {
			if err := m.TaxAmountByTaxTypes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taxAmountByTaxTypes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("taxAmountByTaxTypes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TransactionLineModel) contextValidateUserDefinedFields(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.UserDefinedFields); i++ {

		if m.UserDefinedFields[i] != nil {
			if err := m.UserDefinedFields[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("userDefinedFields" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("userDefinedFields" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *TransactionLineModel) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TransactionLineModel) UnmarshalBinary(b []byte) error {
	var res TransactionLineModel
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
