// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// LineItemModel Represents one line item in a transaction
// Example: {"amount":100,"description":"Yarn","itemCode":"Y0001","number":"1","quantity":1,"taxCode":"PS081282"}
//
// swagger:model LineItemModel
type LineItemModel struct {

	// The addresses to use for this transaction line.
	//
	// If you set this value to `null`, or if you omit this element from your API call, then instead the transaction
	// will use the `addresses` from the document level.
	//
	// If you specify any other value besides `null`, only addresses specified for this line will be used for this line.
	// Example: {"shipFrom":{"city":"Irvine","country":"US","line1":"2000 Main Street","postalCode":"92614","region":"CA"},"shipTo":{"city":"Seattle","country":"US","line1":"1100 2nd Ave","postalCode":"98101","region":"WA"}}
	Addresses *AddressesModel `json:"addresses,omitempty"`

	// Total amount for this line.  The amount represents the net currency value that changed hands from the customer (represented by the `customerCode` field) to the company (represented by the `companyCode`) field.
	//
	// For sale transactions, this value must be positive.  It indicates the amount of money paid by the customer to the company.
	//
	// For refund or return transactions, this value must be negative.
	// Example: 100
	// Required: true
	Amount *float64 `json:"amount"`

	// VAT business identification number for the customer for this line item.  If you leave this field empty,
	// this line item will use whatever business identification number you provided at the transaction level.
	//
	// If you specify a VAT business identification number for the customer in this transaction and you have also set up
	// a business identification number for your company during company setup, this transaction will be treated as a
	// business-to-business transaction for VAT purposes and it will be calculated according to VAT tax rules.
	// Max Length: 25
	// Min Length: 0
	BusinessIdentificationNo *string `json:"businessIdentificationNo,omitempty"`

	// Product category breadcrumbs. This is the full path to the category where item is included. Categories should be separated by “ > “.  Multiple category paths per item are accepted. In this case, category paths should be separated by “;”.
	// Max Length: 4000
	// Min Length: 0
	Category *string `json:"category,omitempty"`

	// DEPRECATED - Date: 10/16/2017, Version: 17.11, Message: Please use `entityUseCode` instead.
	//
	// Max Length: 25
	// Min Length: 0
	CustomerUsageType *string `json:"customerUsageType,omitempty"`

	// Item description.
	//
	// For Streamlined Sales Tax (SST) customers, this field is required if an unmapped `itemCode` is used.
	// Example: Yarn
	// Max Length: 2096
	// Min Length: 0
	Description *string `json:"description,omitempty"`

	// True if the document discount should be applied to this line.  If this value is false, or not provided, discounts will not be
	// applied to this line even if they are specified on the root `discount` element.
	Discounted bool `json:"discounted,omitempty"`

	// Entity Use Code - The client application customer or usage type.  This field allows you to designate a type of usage that
	// may make this transaction considered exempt by reason of exempt usage.
	//
	// For a list of entity use codes, see the Definitions API `ListEntityUseCodes`.
	// Max Length: 25
	// Min Length: 0
	EntityUseCode *string `json:"entityUseCode,omitempty"`

	// The customer Tax Id Number (tax_number) associated with a certificate - Sales tax calculation requests first determine if there is an applicable
	// ECMS entry available, and will utilize it for exemption processing. If no applicable ECMS entry is available, the AvaTax service
	// will determine if an Exemption Number field is populated or an Entity/Use Code is included in the sales tax calculation request,
	// and will perform exemption processing using either of those two options.
	// Note: This is same as 'exemptNo' in TransactionModel.
	ExemptionCode string `json:"exemptionCode,omitempty"`

	// The Item code for Custom Duty / Global Import tax determination
	// Harmonized Tariff System code for this transaction.
	//
	// For a list of harmonized tariff codes, see the Definitions API for harmonized tariff codes.
	// Max Length: 25
	// Min Length: 0
	HsCode *string `json:"hsCode,omitempty"`

	// Item Code (SKU).  If you provide an `itemCode` field, the AvaTax API will look up the item you created with the `CreateItems` API call
	// and use all the information available about that item for this transaction.
	// Example: Y0001
	// Max Length: 50
	// Min Length: 0
	ItemCode *string `json:"itemCode,omitempty"`

	// This field will identify who is remitting Marketplace or Seller. This field must be populated by Marketplace.
	// Example: Marketplace
	// Enum: [Marketplace Seller]
	MarketplaceLiabilityType string `json:"marketplaceLiabilityType,omitempty"`

	// DEPRECATED - Date: 04/15/2021, Version: 21.4, Message: Please use merchantSellerIdentifier instead.
	// ID of the merchant selling on the Marketplace. This field must be populated by Marketplace.
	MerchantSellerID int64 `json:"merchantSellerId,omitempty"`

	// ID of the merchant selling on the Marketplace. This field must be populated by Marketplace.
	// Max Length: 100
	// Min Length: 0
	MerchantSellerIdentifier *string `json:"merchantSellerIdentifier,omitempty"`

	// The line number of this line within the document.  This can be any text that is useful to you, such as numeric line numbers, alphabetic line numbers, or other text.
	// Example: 1
	// Max Length: 50
	// Min Length: 0
	Number *string `json:"number,omitempty"`

	// The transaction's original ID in its origination system
	// Max Length: 50
	// Min Length: 0
	OriginationDocumentID *string `json:"originationDocumentId,omitempty"`

	// Synonym of Marketplace Origination. Name of the Marketplace where the transaction originated from.
	// Max Length: 60
	// Min Length: 0
	OriginationSite *string `json:"originationSite,omitempty"`

	// Special parameters that apply to this line within this transaction.
	//
	// To get a full list of available parameters, please use the `ListParameters` API.
	Parameters []*TransactionLineParameterModel `json:"parameters"`

	// Quantity of items in this line.  This quantity value should always be a positive value representing the quantity of product that changed hands, even when handling returns or refunds.
	//
	// If not provided, or if set to zero, the quantity value is assumed to be one (1).
	// Example: 1
	Quantity float64 `json:"quantity,omitempty"`

	// Ref1 (Customer Defined Field)
	//
	// This field is available for you to use to provide whatever information your implementation requires.  It does not affect tax calculation.
	// Max Length: 250
	// Min Length: 0
	Ref1 *string `json:"ref1,omitempty"`

	// Ref2 (Customer Defined Field)
	//
	// This field is available for you to use to provide whatever information your implementation requires.  It does not affect tax calculation.
	// Max Length: 250
	// Min Length: 0
	Ref2 *string `json:"ref2,omitempty"`

	// Revenue Account (Customer Defined Field).
	//
	// This field is available for you to use to provide whatever information your implementation requires.  It does not affect tax calculation.
	// Max Length: 50
	// Min Length: 0
	RevenueAccount *string `json:"revenueAccount,omitempty"`

	// A long description of the product.
	// Max Length: 4000
	// Min Length: 0
	Summary *string `json:"summary,omitempty"`

	// Tax Code - System or Custom Tax Code.
	//
	// You can use your own tax code mapping or standard Avalara tax codes.  For a full list of tax codes, see `ListTaxCodes`.
	// Example: PS081282
	// Max Length: 25
	// Min Length: 0
	TaxCode *string `json:"taxCode,omitempty"`

	// Indicates whether the `amount` for this line already includes tax.
	//
	// If this value is `true`, the final price of this line including tax will equal the value in `amount`.
	//
	// If this value is `null` or `false`, the final price will equal `amount` plus whatever taxes apply to this line.
	TaxIncluded bool `json:"taxIncluded,omitempty"`

	// Specifies a tax override for this line.
	// Example: {"reason":"Precalculated Tax","taxAmount":6.25,"taxDate":"2021-12-25","type":"TaxAmount"}
	TaxOverride *TaxOverrideModel `json:"taxOverride,omitempty"`

	// Custom user fields/flex fields for this line.
	UserDefinedFields []*TransactionLineUserDefinedFieldModel `json:"userDefinedFields"`
}

// Validate validates this line item model
func (m *LineItemModel) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAddresses(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBusinessIdentificationNo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCategory(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomerUsageType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEntityUseCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHsCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateItemCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMarketplaceLiabilityType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMerchantSellerIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginationDocumentID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginationSite(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateParameters(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRef1(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRef2(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRevenueAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSummary(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTaxCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTaxOverride(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserDefinedFields(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LineItemModel) validateAddresses(formats strfmt.Registry) error {
	if swag.IsZero(m.Addresses) { // not required
		return nil
	}

	if m.Addresses != nil {
		if err := m.Addresses.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addresses")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("addresses")
			}
			return err
		}
	}

	return nil
}

func (m *LineItemModel) validateAmount(formats strfmt.Registry) error {

	if err := validate.Required("amount", "body", m.Amount); err != nil {
		return err
	}

	return nil
}

func (m *LineItemModel) validateBusinessIdentificationNo(formats strfmt.Registry) error {
	if swag.IsZero(m.BusinessIdentificationNo) { // not required
		return nil
	}

	if err := validate.MinLength("businessIdentificationNo", "body", *m.BusinessIdentificationNo, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("businessIdentificationNo", "body", *m.BusinessIdentificationNo, 25); err != nil {
		return err
	}

	return nil
}

func (m *LineItemModel) validateCategory(formats strfmt.Registry) error {
	if swag.IsZero(m.Category) { // not required
		return nil
	}

	if err := validate.MinLength("category", "body", *m.Category, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("category", "body", *m.Category, 4000); err != nil {
		return err
	}

	return nil
}

func (m *LineItemModel) validateCustomerUsageType(formats strfmt.Registry) error {
	if swag.IsZero(m.CustomerUsageType) { // not required
		return nil
	}

	if err := validate.MinLength("customerUsageType", "body", *m.CustomerUsageType, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("customerUsageType", "body", *m.CustomerUsageType, 25); err != nil {
		return err
	}

	return nil
}

func (m *LineItemModel) validateDescription(formats strfmt.Registry) error {
	if swag.IsZero(m.Description) { // not required
		return nil
	}

	if err := validate.MinLength("description", "body", *m.Description, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("description", "body", *m.Description, 2096); err != nil {
		return err
	}

	return nil
}

func (m *LineItemModel) validateEntityUseCode(formats strfmt.Registry) error {
	if swag.IsZero(m.EntityUseCode) { // not required
		return nil
	}

	if err := validate.MinLength("entityUseCode", "body", *m.EntityUseCode, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("entityUseCode", "body", *m.EntityUseCode, 25); err != nil {
		return err
	}

	return nil
}

func (m *LineItemModel) validateHsCode(formats strfmt.Registry) error {
	if swag.IsZero(m.HsCode) { // not required
		return nil
	}

	if err := validate.MinLength("hsCode", "body", *m.HsCode, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("hsCode", "body", *m.HsCode, 25); err != nil {
		return err
	}

	return nil
}

func (m *LineItemModel) validateItemCode(formats strfmt.Registry) error {
	if swag.IsZero(m.ItemCode) { // not required
		return nil
	}

	if err := validate.MinLength("itemCode", "body", *m.ItemCode, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("itemCode", "body", *m.ItemCode, 50); err != nil {
		return err
	}

	return nil
}

var lineItemModelTypeMarketplaceLiabilityTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Marketplace","Seller"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		lineItemModelTypeMarketplaceLiabilityTypePropEnum = append(lineItemModelTypeMarketplaceLiabilityTypePropEnum, v)
	}
}

const (

	// LineItemModelMarketplaceLiabilityTypeMarketplace captures enum value "Marketplace"
	LineItemModelMarketplaceLiabilityTypeMarketplace string = "Marketplace"

	// LineItemModelMarketplaceLiabilityTypeSeller captures enum value "Seller"
	LineItemModelMarketplaceLiabilityTypeSeller string = "Seller"
)

// prop value enum
func (m *LineItemModel) validateMarketplaceLiabilityTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, lineItemModelTypeMarketplaceLiabilityTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *LineItemModel) validateMarketplaceLiabilityType(formats strfmt.Registry) error {
	if swag.IsZero(m.MarketplaceLiabilityType) { // not required
		return nil
	}

	// value enum
	if err := m.validateMarketplaceLiabilityTypeEnum("marketplaceLiabilityType", "body", m.MarketplaceLiabilityType); err != nil {
		return err
	}

	return nil
}

func (m *LineItemModel) validateMerchantSellerIdentifier(formats strfmt.Registry) error {
	if swag.IsZero(m.MerchantSellerIdentifier) { // not required
		return nil
	}

	if err := validate.MinLength("merchantSellerIdentifier", "body", *m.MerchantSellerIdentifier, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("merchantSellerIdentifier", "body", *m.MerchantSellerIdentifier, 100); err != nil {
		return err
	}

	return nil
}

func (m *LineItemModel) validateNumber(formats strfmt.Registry) error {
	if swag.IsZero(m.Number) { // not required
		return nil
	}

	if err := validate.MinLength("number", "body", *m.Number, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("number", "body", *m.Number, 50); err != nil {
		return err
	}

	return nil
}

func (m *LineItemModel) validateOriginationDocumentID(formats strfmt.Registry) error {
	if swag.IsZero(m.OriginationDocumentID) { // not required
		return nil
	}

	if err := validate.MinLength("originationDocumentId", "body", *m.OriginationDocumentID, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("originationDocumentId", "body", *m.OriginationDocumentID, 50); err != nil {
		return err
	}

	return nil
}

func (m *LineItemModel) validateOriginationSite(formats strfmt.Registry) error {
	if swag.IsZero(m.OriginationSite) { // not required
		return nil
	}

	if err := validate.MinLength("originationSite", "body", *m.OriginationSite, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("originationSite", "body", *m.OriginationSite, 60); err != nil {
		return err
	}

	return nil
}

func (m *LineItemModel) validateParameters(formats strfmt.Registry) error {
	if swag.IsZero(m.Parameters) { // not required
		return nil
	}

	for i := 0; i < len(m.Parameters); i++ {
		if swag.IsZero(m.Parameters[i]) { // not required
			continue
		}

		if m.Parameters[i] != nil {
			if err := m.Parameters[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("parameters" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("parameters" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *LineItemModel) validateRef1(formats strfmt.Registry) error {
	if swag.IsZero(m.Ref1) { // not required
		return nil
	}

	if err := validate.MinLength("ref1", "body", *m.Ref1, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("ref1", "body", *m.Ref1, 250); err != nil {
		return err
	}

	return nil
}

func (m *LineItemModel) validateRef2(formats strfmt.Registry) error {
	if swag.IsZero(m.Ref2) { // not required
		return nil
	}

	if err := validate.MinLength("ref2", "body", *m.Ref2, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("ref2", "body", *m.Ref2, 250); err != nil {
		return err
	}

	return nil
}

func (m *LineItemModel) validateRevenueAccount(formats strfmt.Registry) error {
	if swag.IsZero(m.RevenueAccount) { // not required
		return nil
	}

	if err := validate.MinLength("revenueAccount", "body", *m.RevenueAccount, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("revenueAccount", "body", *m.RevenueAccount, 50); err != nil {
		return err
	}

	return nil
}

func (m *LineItemModel) validateSummary(formats strfmt.Registry) error {
	if swag.IsZero(m.Summary) { // not required
		return nil
	}

	if err := validate.MinLength("summary", "body", *m.Summary, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("summary", "body", *m.Summary, 4000); err != nil {
		return err
	}

	return nil
}

func (m *LineItemModel) validateTaxCode(formats strfmt.Registry) error {
	if swag.IsZero(m.TaxCode) { // not required
		return nil
	}

	if err := validate.MinLength("taxCode", "body", *m.TaxCode, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("taxCode", "body", *m.TaxCode, 25); err != nil {
		return err
	}

	return nil
}

func (m *LineItemModel) validateTaxOverride(formats strfmt.Registry) error {
	if swag.IsZero(m.TaxOverride) { // not required
		return nil
	}

	if m.TaxOverride != nil {
		if err := m.TaxOverride.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("taxOverride")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("taxOverride")
			}
			return err
		}
	}

	return nil
}

func (m *LineItemModel) validateUserDefinedFields(formats strfmt.Registry) error {
	if swag.IsZero(m.UserDefinedFields) { // not required
		return nil
	}

	for i := 0; i < len(m.UserDefinedFields); i++ {
		if swag.IsZero(m.UserDefinedFields[i]) { // not required
			continue
		}

		if m.UserDefinedFields[i] != nil {
			if err := m.UserDefinedFields[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("userDefinedFields" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("userDefinedFields" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this line item model based on the context it is used
func (m *LineItemModel) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAddresses(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateParameters(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTaxOverride(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUserDefinedFields(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LineItemModel) contextValidateAddresses(ctx context.Context, formats strfmt.Registry) error {

	if m.Addresses != nil {
		if err := m.Addresses.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addresses")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("addresses")
			}
			return err
		}
	}

	return nil
}

func (m *LineItemModel) contextValidateParameters(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Parameters); i++ {

		if m.Parameters[i] != nil {
			if err := m.Parameters[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("parameters" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("parameters" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *LineItemModel) contextValidateTaxOverride(ctx context.Context, formats strfmt.Registry) error {

	if m.TaxOverride != nil {
		if err := m.TaxOverride.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("taxOverride")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("taxOverride")
			}
			return err
		}
	}

	return nil
}

func (m *LineItemModel) contextValidateUserDefinedFields(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.UserDefinedFields); i++ {

		if m.UserDefinedFields[i] != nil {
			if err := m.UserDefinedFields[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("userDefinedFields" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("userDefinedFields" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *LineItemModel) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LineItemModel) UnmarshalBinary(b []byte) error {
	var res LineItemModel
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
