// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CertificateModel A certificate is a document stored in either AvaTax Exemptions or CertCapture.  The certificate document
// can contain information about a customer's eligibility for exemption from sales or use taxes based on
// criteria you specify when you store the certificate.  To view or manage your certificates directly, please
// log onto the administrative website for the product you purchased.
// Example: {"businessNumberType":"Business Services","createdDate":"2021-12-25T17:08:37.796337Z","customers":[{"alternateId":"987654321","attnName":"Attn: Receiving","city":"Irvine","companyId":0,"contactName":"Alice Smith","country":"US","customerCode":"73539ce2-dddf-425c-bacf-69cd418bea17","emailAddress":"dr.bob.example@example.org","exposureZones":[{"name":"Washington"}],"faxNumber":"949.555.1213","lastTransaction":"2008-10-08T00:00:00","line1":"645 Main Street","name":"Dr. Bob Example","phoneNumber":"(949) 555-1212","postalCode":"92614","region":"CA"},{"alternateId":"987654321","attnName":"Attn: Receiving","city":"Irvine","companyId":0,"contactName":"Alice Smith","country":"US","customerCode":"953880f2-6390-495c-9ce3-e12ab9ee2a6b","emailAddress":"dr.bob.example@example.org","exposureZones":[{"name":"Washington"}],"faxNumber":"949.555.1213","lastTransaction":"2008-10-08T00:00:00","line1":"645 Main Street","name":"Dr. Bob Example","phoneNumber":"(949) 555-1212","postalCode":"92614","region":"CA"}],"documentExists":false,"exemptPercentage":0,"exemptionNumber":"Exempt-1234","exemptionReason":{"name":"RESALE"},"expirationDate":"2020-12-31","exposureZone":{"name":"Washington"},"filename":"878e7641-12be-490d-9f14-f7054dea8cc3","id":0,"isSingleCertificate":false,"modifiedDate":"2021-12-25","pageCount":0,"signedDate":"2016-02-01","taxNumberType":"FEIN","valid":true,"verified":false}
//
// swagger:model CertificateModel
type CertificateModel struct {

	// A list of certificate attributes that apply to this certificate.
	//
	// You can fetch this data by specifying `$include=attributes` when calling a certificate fetch API.
	Attributes []*CertificateAttributeModel `json:"attributes"`

	// Description of business for the certificate. For example, `Retail trade`, `Professional services`, or `Construction`.
	// Example: Business Services
	BusinessNumberType string `json:"businessNumberType,omitempty"`

	// The unique ID number of the AvaTax company that recorded this certificate.
	CompanyID int32 `json:"companyId,omitempty"`

	// The date/time when this record was created.
	// Example: 2021-12-25T17:08:37.796337Z
	// Format: date-time
	CreatedDate strfmt.DateTime `json:"createdDate,omitempty"`

	// A list of customers to which this certificate applies.  You can fetch this data by specifying
	// `$include=customers` when calling a certificate fetch API.
	// Example: [{"alternateId":"987654321","attnName":"Attn: Receiving","city":"Irvine","companyId":0,"contactName":"Alice Smith","country":"US","customerCode":"73539ce2-dddf-425c-bacf-69cd418bea17","emailAddress":"dr.bob.example@example.org","exposureZones":[{"name":"Washington"}],"faxNumber":"949.555.1213","lastTransaction":"2008-10-08T00:00:00","line1":"645 Main Street","name":"Dr. Bob Example","phoneNumber":"(949) 555-1212","postalCode":"92614","region":"CA"},{"alternateId":"987654321","attnName":"Attn: Receiving","city":"Irvine","companyId":0,"contactName":"Alice Smith","country":"US","customerCode":"953880f2-6390-495c-9ce3-e12ab9ee2a6b","emailAddress":"dr.bob.example@example.org","exposureZones":[{"name":"Washington"}],"faxNumber":"949.555.1213","lastTransaction":"2008-10-08T00:00:00","line1":"645 Main Street","name":"Dr. Bob Example","phoneNumber":"(949) 555-1212","postalCode":"92614","region":"CA"}]
	Customers []*CustomerModel `json:"customers"`

	// This value is true if there exists scanned PDF copy of this certificate or the PDF version of the form that the customer filled via the CertCapture wizard on S3 bucket.
	// Example: false
	// Read Only: true
	DocumentExists *bool `json:"documentExists,omitempty"`

	// The unique ID number of current AvaTax Exemption Certificate that refers this certificate.
	EcmsID int32 `json:"ecmsId,omitempty"`

	// The status of current AvaTax Exemption Certificate  that refers to this certificate.
	EcmsStatus string `json:"ecmsStatus,omitempty"`

	// If this certificate provides exemption from transactional taxes, what percentage of the transaction
	// is considered exempt?
	//
	// For a fully exempt certificate, this percentage should be 100.
	// Example: 0
	ExemptPercentage float64 `json:"exemptPercentage,omitempty"`

	// Indicates the tax number passed in for the certificate.
	// Example: Exempt-1234
	ExemptionNumber string `json:"exemptionNumber,omitempty"`

	// The exemption reason associated with this certificate.  For example, the reason code for exemption
	// for purposes of resale is `RESALE`.
	//
	// For a list of exemption reasons, call `ListCertificateExemptReasons`.
	// Example: {"name":"RESALE"}
	// Required: true
	ExemptionReason *ExemptionReasonModel `json:"exemptionReason"`

	// Expiration date when this certificate will no longer be valid.
	// Example: 2020-12-31T00:00:00
	// Required: true
	// Format: date
	ExpirationDate *strfmt.Date `json:"expirationDate"`

	// The exposure zone where this certificate is valid.
	// Example: {"name":"Washington"}
	// Required: true
	ExposureZone *ExposureZoneModel `json:"exposureZone"`

	// File name for the image of this certificate.
	//
	// When creating a certificate, if you do not upload a PDF or JPG image, you must specify the filename
	// of the certificate as it is tracked in your repository.
	//
	// To create a certificate, you must provide one of the following fields: either a `filename`, a `pdf` file,
	// or an array of JPG `pages`.  The API will return an error if you omit these fields or if you attempt to
	// put values in more than one of them.
	// Example: 878e7641-12be-490d-9f14-f7054dea8cc3
	Filename string `json:"filename,omitempty"`

	// Unique ID number of this certificate.
	// Example: 0
	ID int32 `json:"id,omitempty"`

	// This value is true if this certificate is a single (or standalone) certificate.  This value is set
	// during the audit stage of the certificate validation process.
	// Example: false
	// Read Only: true
	IsSingleCertificate *bool `json:"isSingleCertificate,omitempty"`

	// The date/time when this record was last modified.
	// Example: 2021-12-25T17:08:37.7963369Z
	// Format: date
	ModifiedDate strfmt.Date `json:"modifiedDate,omitempty"`

	// Number of pages contained within this certificate.
	// Example: 0
	// Read Only: true
	PageCount int32 `json:"pageCount,omitempty"`

	// This field is available for input only.  To retrieve the image after creation, use the
	// `DownloadCertificateImage` API.
	//
	// When creating a certificate, you may optionally provide a list of JPG images, one per page, in
	// Base64 URLEncoded format.  These JPG images are automatically combined into a single downloadable
	// PDF and can be retrieved back later as either the original JPG images or the combined PDF.
	//
	// To create a certificate, you must provide one of the following fields: either a `filename`, a `pdf` file,
	// or an array of JPG `pages`.  The API will return an error if you omit these fields or if you attempt to
	// put values in more than one of them.
	Pages []string `json:"pages"`

	// This field is available for input only.  To retrieve the image after creation, use the
	// `DownloadCertificateImage` API.
	//
	// When creating a certificate, you may optionally provide a PDF image in Base64 URLEncoded format.
	// PDFs are automatically parsed into individual page JPG images and can be retrieved back
	// later as either the original PDF or the individual pages.
	//
	// To create a certificate, you must provide one of the following fields: either a `filename`, a `pdf` file,
	// or an array of JPG `pages`.  The API will return an error if you omit these fields or if you attempt to
	// put values in more than one of them.
	Pdf string `json:"pdf,omitempty"`

	// A list of purchase order numbers that are valid for use with this certificate.
	//
	// If this certificate is applicable for all purchase order numbers, this field will be empty.
	//
	// You can fetch this data by specifying `$include=po_numbers` when calling a certificate fetch API.
	PoNumbers []*PoNumberModel `json:"poNumbers"`

	// The date when this certificate was signed.
	// Example: 2016-02-01T00:00:00
	// Required: true
	// Format: date
	SignedDate *strfmt.Date `json:"signedDate"`

	// The status of the certificate
	// Read Only: true
	Status string `json:"status,omitempty"`

	// The tax number type for the certificate. For example, `FEIN`, `Social Security Number`, or `Employer Identification Number`.
	// Example: FEIN
	TaxNumberType string `json:"taxNumberType,omitempty"`

	// True if this certificate is marked as valid.  A valid certificate can be considered for exemption purposes.
	// When a certificate is marked invalid, it will no longer be considered when calculating exemption for
	// a customer.
	// Example: true
	Valid bool `json:"valid,omitempty"`

	// The exemption reason that CertCapture audit/internal logic identifies for created certificate.
	// Example: {"name":"EXPOSURE"}
	ValidatedExemptionReason *ExemptionReasonModel `json:"validatedExemptionReason,omitempty"`

	// This value is true if the certificate has gone through the certificate validation process.
	// For more information on the certificate validation process, please see the Avalara Help Center.
	// Example: false
	// Read Only: true
	Verified *bool `json:"verified,omitempty"`
}

// Validate validates this certificate model
func (m *CertificateModel) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAttributes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExemptionReason(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExpirationDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExposureZone(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateModifiedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePoNumbers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSignedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValidatedExemptionReason(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CertificateModel) validateAttributes(formats strfmt.Registry) error {
	if swag.IsZero(m.Attributes) { // not required
		return nil
	}

	for i := 0; i < len(m.Attributes); i++ {
		if swag.IsZero(m.Attributes[i]) { // not required
			continue
		}

		if m.Attributes[i] != nil {
			if err := m.Attributes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("attributes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("attributes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CertificateModel) validateCreatedDate(formats strfmt.Registry) error {
	if swag.IsZero(m.CreatedDate) { // not required
		return nil
	}

	if err := validate.FormatOf("createdDate", "body", "date-time", m.CreatedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CertificateModel) validateCustomers(formats strfmt.Registry) error {
	if swag.IsZero(m.Customers) { // not required
		return nil
	}

	for i := 0; i < len(m.Customers); i++ {
		if swag.IsZero(m.Customers[i]) { // not required
			continue
		}

		if m.Customers[i] != nil {
			if err := m.Customers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("customers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("customers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CertificateModel) validateExemptionReason(formats strfmt.Registry) error {

	if err := validate.Required("exemptionReason", "body", m.ExemptionReason); err != nil {
		return err
	}

	if m.ExemptionReason != nil {
		if err := m.ExemptionReason.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("exemptionReason")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("exemptionReason")
			}
			return err
		}
	}

	return nil
}

func (m *CertificateModel) validateExpirationDate(formats strfmt.Registry) error {

	if err := validate.Required("expirationDate", "body", m.ExpirationDate); err != nil {
		return err
	}

	if err := validate.FormatOf("expirationDate", "body", "date", m.ExpirationDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CertificateModel) validateExposureZone(formats strfmt.Registry) error {

	if err := validate.Required("exposureZone", "body", m.ExposureZone); err != nil {
		return err
	}

	if m.ExposureZone != nil {
		if err := m.ExposureZone.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("exposureZone")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("exposureZone")
			}
			return err
		}
	}

	return nil
}

func (m *CertificateModel) validateModifiedDate(formats strfmt.Registry) error {
	if swag.IsZero(m.ModifiedDate) { // not required
		return nil
	}

	if err := validate.FormatOf("modifiedDate", "body", "date", m.ModifiedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CertificateModel) validatePoNumbers(formats strfmt.Registry) error {
	if swag.IsZero(m.PoNumbers) { // not required
		return nil
	}

	for i := 0; i < len(m.PoNumbers); i++ {
		if swag.IsZero(m.PoNumbers[i]) { // not required
			continue
		}

		if m.PoNumbers[i] != nil {
			if err := m.PoNumbers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("poNumbers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("poNumbers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CertificateModel) validateSignedDate(formats strfmt.Registry) error {

	if err := validate.Required("signedDate", "body", m.SignedDate); err != nil {
		return err
	}

	if err := validate.FormatOf("signedDate", "body", "date", m.SignedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CertificateModel) validateValidatedExemptionReason(formats strfmt.Registry) error {
	if swag.IsZero(m.ValidatedExemptionReason) { // not required
		return nil
	}

	if m.ValidatedExemptionReason != nil {
		if err := m.ValidatedExemptionReason.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validatedExemptionReason")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validatedExemptionReason")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this certificate model based on the context it is used
func (m *CertificateModel) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAttributes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCustomers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDocumentExists(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExemptionReason(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExposureZone(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsSingleCertificate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePageCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePoNumbers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateValidatedExemptionReason(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVerified(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CertificateModel) contextValidateAttributes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Attributes); i++ {

		if m.Attributes[i] != nil {
			if err := m.Attributes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("attributes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("attributes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CertificateModel) contextValidateCustomers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Customers); i++ {

		if m.Customers[i] != nil {
			if err := m.Customers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("customers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("customers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CertificateModel) contextValidateDocumentExists(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "documentExists", "body", m.DocumentExists); err != nil {
		return err
	}

	return nil
}

func (m *CertificateModel) contextValidateExemptionReason(ctx context.Context, formats strfmt.Registry) error {

	if m.ExemptionReason != nil {
		if err := m.ExemptionReason.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("exemptionReason")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("exemptionReason")
			}
			return err
		}
	}

	return nil
}

func (m *CertificateModel) contextValidateExposureZone(ctx context.Context, formats strfmt.Registry) error {

	if m.ExposureZone != nil {
		if err := m.ExposureZone.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("exposureZone")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("exposureZone")
			}
			return err
		}
	}

	return nil
}

func (m *CertificateModel) contextValidateIsSingleCertificate(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "isSingleCertificate", "body", m.IsSingleCertificate); err != nil {
		return err
	}

	return nil
}

func (m *CertificateModel) contextValidatePageCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "pageCount", "body", int32(m.PageCount)); err != nil {
		return err
	}

	return nil
}

func (m *CertificateModel) contextValidatePoNumbers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.PoNumbers); i++ {

		if m.PoNumbers[i] != nil {
			if err := m.PoNumbers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("poNumbers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("poNumbers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CertificateModel) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "status", "body", string(m.Status)); err != nil {
		return err
	}

	return nil
}

func (m *CertificateModel) contextValidateValidatedExemptionReason(ctx context.Context, formats strfmt.Registry) error {

	if m.ValidatedExemptionReason != nil {
		if err := m.ValidatedExemptionReason.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validatedExemptionReason")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validatedExemptionReason")
			}
			return err
		}
	}

	return nil
}

func (m *CertificateModel) contextValidateVerified(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "verified", "body", m.Verified); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CertificateModel) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CertificateModel) UnmarshalBinary(b []byte) error {
	var res CertificateModel
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
