// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// TaxRuleModel Represents a tax rule that changes the behavior of Avalara's tax engine for certain products and/or entity use codes
// in certain jurisdictions.
//
// Avalara supports a few different types of tax rules.  For information about tax rule types, see
// [TaxRuleTypeId](https://developer.avalara.com/api-reference/avatax/rest/v2/models/enums/TaxRuleTypeId/)
//
// Because different types of tax rules have different behavior, some fields may change their behavior based on
// the type of tax rule selected.  Please read the documentation for each field carefully and ensure that
// the value you send is appropriate for the type of tax rule.
// Example: {"cap":0,"companyId":12345,"country":"US","countyFIPS":"013","description":"Freight","effectiveDate":"2021-12-25","id":56789,"isAllJuris":false,"jurisCode":"013","jurisName":"MARICOPA","jurisTypeId":0,"jurisdictionTypeId":"County","region":"AZ","stateFIPS":"04","taxCode":"FR020800","taxRuleTypeId":"ProductTaxabilityRule","taxSubType":"ALL","taxTypeCode":"ALL","taxTypeGroup":"SalesAndUse","taxTypeId":"BothSalesAndUseTax","threshold":0,"value":0}
//
// swagger:model TaxRuleModel
type TaxRuleModel struct {

	// The maximum cap for the price of this item according to this rule.  Any amount above this cap will not be subject to this rule.
	//
	// For example, if you must pay 5% of a product's value up to a maximum value of $1000, you would set the `cap` to `1000.00` and the `value` to `0.05`.
	// Example: 0
	Cap float64 `json:"cap,omitempty"`

	// The unique ID number of the company that owns this tax rule.
	// Example: 12345
	CompanyID int32 `json:"companyId,omitempty"`

	// Name or ISO 3166 code identifying the country where this rule will apply.
	//
	// This field supports many different country identifiers:
	//  * Two character ISO 3166 codes
	//  * Three character ISO 3166 codes
	//  * Fully spelled out names of the country in ISO supported languages
	//  * Common alternative spellings for many countries
	//
	// For a full list of all supported codes and names, please see the Definitions API `ListCountries`.
	// Example: US
	// Required: true
	Country *string `json:"country"`

	// For U.S. tax rules, this is the county's Federal Information Processing Standard (FIPS) code.
	//
	// This field is required for rules that apply to specific jurisdictions in the United States.  It is not required
	// if you set the `isAllJuris` flag to true.
	// Example: 013
	// Max Length: 3
	// Min Length: 0
	CountyFIPS *string `json:"countyFIPS,omitempty"`

	// The date when this record was created.
	// Read Only: true
	// Format: date-time
	CreatedDate strfmt.DateTime `json:"createdDate,omitempty"`

	// The User ID of the user who created this record.
	// Read Only: true
	CreatedUserID int32 `json:"createdUserId,omitempty"`

	// The currency code to use for this rule.
	//
	// For a list of currencies supported by AvaTax, use the [ListCurrencies API](https://developer.avalara.com/api-reference/avatax/rest/v2/methods/Definitions/ListCurrencies/).
	// Max Length: 3
	// Min Length: 0
	CurrencyCode *string `json:"currencyCode,omitempty"`

	// DEPRECATED - Date: 10/16/2017, Version: 17.11, Message: Please use `entityUseCode` instead.
	//
	// Max Length: 25
	// Min Length: 0
	CustomerUsageType *string `json:"customerUsageType,omitempty"`

	// A friendly name for this tax rule.
	// Example: Freight
	// Max Length: 255
	// Min Length: 0
	Description *string `json:"description,omitempty"`

	// The first date at which this rule applies.  If `null`, this rule will apply to all dates prior to the end date.
	// Example: 2021-12-25T00:00:00+00:00
	// Format: date
	EffectiveDate strfmt.Date `json:"effectiveDate,omitempty"`

	// The last date for which this rule applies.  If `null`, this rule will apply to all dates after the effective date.
	// Format: date
	EndDate strfmt.Date `json:"endDate,omitempty"`

	// The entity use code to which this rule applies.
	//
	// You can create custom `entityUseCode` values with specific behavior using this API, or you can change
	// the behavior of Avalara's system-defined entity use codes.
	//
	// For a full list of Avalara-defined entity use codes, see the [ListEntityUseCodes API](https://developer.avalara.com/api-reference/avatax/rest/v2/methods/Definitions/ListEntityUseCodes/).
	// Max Length: 25
	// Min Length: 0
	EntityUseCode *string `json:"entityUseCode,omitempty"`

	// The unique ID number of this tax rule.
	// Example: 56789
	// Required: true
	ID *int32 `json:"id"`

	// Allows you to make tax rules apply to lower jurisdictions.  This feature is only available in the United States and Canada.
	//
	// * In the United States, this value can be used for rules written at the `State` jurisdictional level.  If set to `true`, this rule will at the state level, county level, city level, and special jurisdiction level.
	// * In Canada, this value can be used for rules written at the `Country` or `State` jurisdictional levels.  If set to `true`, this rule will at all lower jurisdictional levels.
	//
	// For any other use case, this value must be `false`.
	// Example: false
	IsAllJuris bool `json:"isAllJuris,omitempty"`

	// DEPRECATED - Date: 8/27/2018, Version: 18.9, Message: This field is no longer required.
	//
	IsSTPro bool `json:"isSTPro,omitempty"`

	// The code of the jurisdiction to which this tax rule applies.
	//
	// Custom tax rules can apply to a specific jurisdiction or to all jurisdictions.  To select a jurisdiction, use the
	// [ListJurisdictions API](https://developer.avalara.com/api-reference/avatax/rest/v2/methods/Definitions/ListJurisdictions/)
	// or the [ListJurisdictionsByAddress API](https://developer.avalara.com/api-reference/avatax/rest/v2/methods/Definitions/ListJurisdictionsByAddress/).
	//
	// Once you have determined which jurisdiction you wish to assign to the tax rule, you should fill in the `jurisName`, `jurisCode`, and
	// `jurisdictionTypeId` fields using the information you retrieved from the API above.
	// Example: 013
	// Required: true
	// Max Length: 10
	// Min Length: 0
	JurisCode *string `json:"jurisCode"`

	// The name of the jurisdiction to which this tax rule applies.
	//
	// Custom tax rules can apply to a specific jurisdiction or to all jurisdictions.  To select a jurisdiction, use the
	// [ListJurisdictions API](https://developer.avalara.com/api-reference/avatax/rest/v2/methods/Definitions/ListJurisdictions/)
	// or the [ListJurisdictionsByAddress API](https://developer.avalara.com/api-reference/avatax/rest/v2/methods/Definitions/ListJurisdictionsByAddress/).
	// To set a rule that applies to all jurisdictions of a specific type, see `isAllJuris`.
	//
	// Once you have determined which jurisdiction you wish to assign to the tax rule, you should fill in the `jurisName`, `jurisCode`, and
	// `jurisdictionTypeId` fields using the information you retrieved from the API above.
	// Example: MARICOPA
	// Max Length: 200
	// Min Length: 0
	JurisName *string `json:"jurisName,omitempty"`

	// DEPRECATED - Date: 12/20/2017, Version: 18.1, Message: Please use `jurisdictionTypeId` instead.
	//
	// Example: STA
	// Enum: [STA CTY CIT STJ CNT]
	JurisTypeID string `json:"jurisTypeId,omitempty"`

	// The type of the jurisdiction to which this tax rule applies.
	//
	// Custom tax rules can apply to a specific jurisdiction or to all jurisdictions.  To select a jurisdiction, use the
	// [ListJurisdictions API](https://developer.avalara.com/api-reference/avatax/rest/v2/methods/Definitions/ListJurisdictions/)
	// or the [ListJurisdictionsByAddress API](https://developer.avalara.com/api-reference/avatax/rest/v2/methods/Definitions/ListJurisdictionsByAddress/).
	//
	// Once you have determined which jurisdiction you wish to assign to the tax rule, you should fill in the `jurisName`, `jurisCode`, and
	// `jurisdictionTypeId` fields using the information you retrieved from the API above.
	//
	// To make a custom tax rule for US or Canada that applies to all jurisdictions of a specific type, see the `isAllJuris`
	// field for more information.
	// Example: Country
	// Enum: [Country State County City Special]
	JurisdictionTypeID string `json:"jurisdictionTypeId,omitempty"`

	// The date/time when this record was last modified.
	// Read Only: true
	// Format: date-time
	ModifiedDate strfmt.DateTime `json:"modifiedDate,omitempty"`

	// The user ID of the user who last modified this record.
	// Read Only: true
	ModifiedUserID int32 `json:"modifiedUserId,omitempty"`

	// Reserved for Avalara internal usage.  Leave this field null.
	// Max Length: 500
	// Min Length: 0
	NonPassthroughExpression *string `json:"nonPassthroughExpression,omitempty"`

	// Supports custom options for your tax rule.
	//
	// Supported options include:
	// * `TaxAll` - This value indicates that the entire amount of the line becomes taxable when the line amount exceeds the `threshold`.
	// Max Length: 100
	// Min Length: 0
	Options *string `json:"options,omitempty"`

	// Reserved for Avalara internal usage.  Leave this field null.
	PreferredProgramID int32 `json:"preferredProgramId,omitempty"`

	// Indicates the code of the rate type that applies to this rule.  Use [ListRateTypesByCountry](https://developer.avalara.com/api-reference/avatax/rest/v2/methods/Definitions/ListRateTypesByCountry/) API for a full list of rate type codes.
	//
	// If you specify a value in the rateTypeCode field, this rule will cause tax lines that are affected by the rule
	// to change to a different rate type code.
	RateTypeCode string `json:"rateTypeCode,omitempty"`

	// DEPRECATED - Date: 8/27/2018, Version: 18.9, Message: Please use `rateTypeCode`, `taxTypeGroup` and `subTaxType` instead.
	//
	// Example: ReducedA
	// Enum: [ReducedA ReducedB Food General IncreasedStandard LinenRental Medical Construction Parking SuperReduced ReducedR Standard Leasing LeasingLow Services Zero]
	RateTypeID string `json:"rateTypeId,omitempty"`

	// Name or ISO 3166 code identifying the region where this rule will apply.
	//
	// This field supports many different region identifiers:
	//  * Two and three character ISO 3166 region codes
	//  * Fully spelled out names of the region in ISO supported languages
	//  * Common alternative spellings for many regions
	//
	// For a full list of all supported codes and names, please see the Definitions API `ListRegions`.
	// NOTE: Region is required for US and not required for non-US countries because the user may be either creating a Country-level or Region-level rule.
	// Example: AZ
	Region string `json:"region,omitempty"`

	// The sourcing types to which this rule applies.
	// Example: Mixed
	// Enum: [Mixed Destination Origin]
	Sourcing string `json:"sourcing,omitempty"`

	// For U.S. tax rules, this is the state's Federal Information Processing Standard (FIPS) code.
	//
	// This field is required for rules that apply to specific jurisdictions in the United States.  It is not required
	// if you set the `isAllJuris` flag to true.
	// Example: 04
	// Max Length: 2
	// Min Length: 0
	StateFIPS *string `json:"stateFIPS,omitempty"`

	// For rules that apply to a specific tax code only, this specifies which tax code is affected by this rule.
	//
	// You can choose to specify a tax code either by passing its unique ID number in the `taxCodeId` field or
	// by passing its alphanumeric code in the `taxCode` field.  To search for the appropriate tax code for your
	// custom rule, use the `ListTaxCodes` API.
	//
	// The `RateOverrideRule`, `BaseRule`, and `ExemptEntityRule` rule types can be applied to all tax codes.  To
	// make a rule that applies to all tax codes, leave both fields blank.
	//
	// The `ProductTaxabilityRule` rule must be associated with a tax code.  If you attempt to create a product taxability rule
	// without a tax code, you will get an error message.
	// Example: FR020800
	// Max Length: 25
	// Min Length: 0
	TaxCode *string `json:"taxCode,omitempty"`

	// For rules that apply to a specific tax code only, this specifies which tax code is affected by this rule.
	//
	// You can choose to specify a tax code either by passing its unique ID number in the `taxCodeId` field or
	// by passing its alphanumeric code in the `taxCode` field.  To search for the appropriate tax code for your
	// custom rule, use the `ListTaxCodes` API.
	//
	// The `RateOverrideRule`, `BaseRule`, and `ExemptEntityRule` rule types can be applied to all tax codes.  To
	// make a rule that applies to all tax codes, leave both fields blank.
	//
	// The `ProductTaxabilityRule` rule must be associated with a tax code.  If you attempt to create a product taxability rule
	// without a tax code, you will get an error message.
	TaxCodeID int32 `json:"taxCodeId,omitempty"`

	// TaxRule Product Detail indicates the HSCode(s) to which the tax rule applies.
	TaxRuleProductDetail []*TaxRuleProductDetailModel `json:"taxRuleProductDetail"`

	// This type value determines the behavior of the tax rule.
	//
	// You can specify that this rule controls the product's taxability or exempt / nontaxable status, the product's rate
	// (for example, if you have been granted an official ruling for your product's rate that differs from the official rate),
	// or other types of behavior.
	// Example: RateRule
	// Required: true
	// Enum: [RateRule RateOverrideRule BaseRule ExemptEntityRule ProductTaxabilityRule NexusRule RateCapRule TaxOverrideRule FeeRule OtherRule]
	TaxRuleTypeID *string `json:"taxRuleTypeId"`

	// This field has different behavior based on the type of rule.
	//
	// * For a product taxability rule, if the rule applies to an item, this value will override the tax sub type of the original product.
	// * For other rules, this value determines what tax sub types will be affected by the rule.
	//
	// Refer to `ListTaxSubtypes` for a list of tax sub types supported by AvaTax.
	// Example: ALL
	TaxSubType string `json:"taxSubType,omitempty"`

	// Indicates the code of the tax type that applies to this rule. Use /api/v2/definitions/taxtypes endpoint to retrieve the list of tax types applicable for your company.
	// Example: ALL
	TaxTypeCode string `json:"taxTypeCode,omitempty"`

	// This field has different behavior based on the type of rule.
	//
	// * For a product taxability rule, if the rule applies to an item, this value will override the tax type group of the original product.
	// * For other rules, this value determines what tax type groups will be affected by the rule.
	//
	// Refer to `ListTaxTypeGroups` for a list of tax type groups supported by AvaTax.
	// Example: SalesAndUse
	TaxTypeGroup string `json:"taxTypeGroup,omitempty"`

	// DEPRECATED - Date: 09/30/2021, Version: 21.9.0, Message: Please use `taxTypeCode` instead.
	// Some tax type groups contain multiple different types of tax.  To create a rule that affects only one
	// type of tax within a tax type group, set this value to the code matching the specific tax type within
	// that group.  The custom tax rule will then only apply to taxes calculated for that specific type.
	//
	// For rules that affect all tax types, use the value `A` to match `All` tax types within that group.
	// Example: E
	// Enum: [E Lodging Bottle RentToOwn BikeTax LandedCost CheckoutBag Alcohol Amusement Hospitality RentalLeasing GrossReceipts Mattress Lumber Paint Tires EI All BothSalesAndUseTax ConsumerUseTax ConsumersUseAndSellersUseTax ConsumerUseAndSalesTax Fee VATInputTax LightBulbs Meals VATNonrecoverableInputTax VATOutputTax PIF Rental SalesTax UseTax EWaste Batteries]
	TaxTypeID string `json:"taxTypeId,omitempty"`

	// The per-unit threshold that must be met before this rule applies.
	//
	// For example, if your product is nontaxable unless it is above $100 per product, you would set the `threshold` value to `100`.  In this case, the rate
	// for the rule would apply to the entire amount above $100.
	//
	// You can also create rules that make the entire product taxable if it exceeds a threshold, but is nontaxable
	// if it is below the threshold.  To choose this, set the `options` field to the value `TaxAll`.
	// Example: 0
	Threshold float64 `json:"threshold,omitempty"`

	// The UnitOfBasis for the TaxRule
	UnitOfBasis string `json:"unitOfBasis,omitempty"`

	// For tax rules that are calculated using units of measurement, this indicates the unit of measurement type
	// used to calculate the amounts for this rule.
	//
	// For a list of units of measurement, use the [ListUnitsOfMeasurement API](https://developer.avalara.com/api-reference/avatax/rest/v2/methods/Definitions/ListUnitOfMeasurement/).
	UomID int32 `json:"uomId,omitempty"`

	// This field has different behavior based on the type of the tax rule.
	//
	// * For a product taxability rule, this value is either 1 or 0, indicating taxable or non-taxable.
	// * For a rate override rule, this value is the corrected rate stored as a decimal, for example, a rate of 5% would be stored as 0.05 decimal.  If you use the special value of 1.0, only the cap and threshold values will be applied and the rate will be left alone.
	// Example: 0
	Value float64 `json:"value,omitempty"`
}

// Validate validates this tax rule model
func (m *TaxRuleModel) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCountyFIPS(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCurrencyCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomerUsageType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEffectiveDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEndDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEntityUseCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateJurisCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateJurisName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateJurisTypeID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateJurisdictionTypeID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateModifiedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNonPassthroughExpression(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRateTypeID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourcing(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStateFIPS(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTaxCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTaxRuleProductDetail(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTaxRuleTypeID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTaxTypeID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TaxRuleModel) validateCountry(formats strfmt.Registry) error {

	if err := validate.Required("country", "body", m.Country); err != nil {
		return err
	}

	return nil
}

func (m *TaxRuleModel) validateCountyFIPS(formats strfmt.Registry) error {
	if swag.IsZero(m.CountyFIPS) { // not required
		return nil
	}

	if err := validate.MinLength("countyFIPS", "body", *m.CountyFIPS, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("countyFIPS", "body", *m.CountyFIPS, 3); err != nil {
		return err
	}

	return nil
}

func (m *TaxRuleModel) validateCreatedDate(formats strfmt.Registry) error {
	if swag.IsZero(m.CreatedDate) { // not required
		return nil
	}

	if err := validate.FormatOf("createdDate", "body", "date-time", m.CreatedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *TaxRuleModel) validateCurrencyCode(formats strfmt.Registry) error {
	if swag.IsZero(m.CurrencyCode) { // not required
		return nil
	}

	if err := validate.MinLength("currencyCode", "body", *m.CurrencyCode, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("currencyCode", "body", *m.CurrencyCode, 3); err != nil {
		return err
	}

	return nil
}

func (m *TaxRuleModel) validateCustomerUsageType(formats strfmt.Registry) error {
	if swag.IsZero(m.CustomerUsageType) { // not required
		return nil
	}

	if err := validate.MinLength("customerUsageType", "body", *m.CustomerUsageType, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("customerUsageType", "body", *m.CustomerUsageType, 25); err != nil {
		return err
	}

	return nil
}

func (m *TaxRuleModel) validateDescription(formats strfmt.Registry) error {
	if swag.IsZero(m.Description) { // not required
		return nil
	}

	if err := validate.MinLength("description", "body", *m.Description, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("description", "body", *m.Description, 255); err != nil {
		return err
	}

	return nil
}

func (m *TaxRuleModel) validateEffectiveDate(formats strfmt.Registry) error {
	if swag.IsZero(m.EffectiveDate) { // not required
		return nil
	}

	if err := validate.FormatOf("effectiveDate", "body", "date", m.EffectiveDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *TaxRuleModel) validateEndDate(formats strfmt.Registry) error {
	if swag.IsZero(m.EndDate) { // not required
		return nil
	}

	if err := validate.FormatOf("endDate", "body", "date", m.EndDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *TaxRuleModel) validateEntityUseCode(formats strfmt.Registry) error {
	if swag.IsZero(m.EntityUseCode) { // not required
		return nil
	}

	if err := validate.MinLength("entityUseCode", "body", *m.EntityUseCode, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("entityUseCode", "body", *m.EntityUseCode, 25); err != nil {
		return err
	}

	return nil
}

func (m *TaxRuleModel) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *TaxRuleModel) validateJurisCode(formats strfmt.Registry) error {

	if err := validate.Required("jurisCode", "body", m.JurisCode); err != nil {
		return err
	}

	if err := validate.MinLength("jurisCode", "body", *m.JurisCode, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("jurisCode", "body", *m.JurisCode, 10); err != nil {
		return err
	}

	return nil
}

func (m *TaxRuleModel) validateJurisName(formats strfmt.Registry) error {
	if swag.IsZero(m.JurisName) { // not required
		return nil
	}

	if err := validate.MinLength("jurisName", "body", *m.JurisName, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("jurisName", "body", *m.JurisName, 200); err != nil {
		return err
	}

	return nil
}

var taxRuleModelTypeJurisTypeIDPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["STA","CTY","CIT","STJ","CNT"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		taxRuleModelTypeJurisTypeIDPropEnum = append(taxRuleModelTypeJurisTypeIDPropEnum, v)
	}
}

const (

	// TaxRuleModelJurisTypeIDSTA captures enum value "STA"
	TaxRuleModelJurisTypeIDSTA string = "STA"

	// TaxRuleModelJurisTypeIDCTY captures enum value "CTY"
	TaxRuleModelJurisTypeIDCTY string = "CTY"

	// TaxRuleModelJurisTypeIDCIT captures enum value "CIT"
	TaxRuleModelJurisTypeIDCIT string = "CIT"

	// TaxRuleModelJurisTypeIDSTJ captures enum value "STJ"
	TaxRuleModelJurisTypeIDSTJ string = "STJ"

	// TaxRuleModelJurisTypeIDCNT captures enum value "CNT"
	TaxRuleModelJurisTypeIDCNT string = "CNT"
)

// prop value enum
func (m *TaxRuleModel) validateJurisTypeIDEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, taxRuleModelTypeJurisTypeIDPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TaxRuleModel) validateJurisTypeID(formats strfmt.Registry) error {
	if swag.IsZero(m.JurisTypeID) { // not required
		return nil
	}

	// value enum
	if err := m.validateJurisTypeIDEnum("jurisTypeId", "body", m.JurisTypeID); err != nil {
		return err
	}

	return nil
}

var taxRuleModelTypeJurisdictionTypeIDPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Country","State","County","City","Special"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		taxRuleModelTypeJurisdictionTypeIDPropEnum = append(taxRuleModelTypeJurisdictionTypeIDPropEnum, v)
	}
}

const (

	// TaxRuleModelJurisdictionTypeIDCountry captures enum value "Country"
	TaxRuleModelJurisdictionTypeIDCountry string = "Country"

	// TaxRuleModelJurisdictionTypeIDState captures enum value "State"
	TaxRuleModelJurisdictionTypeIDState string = "State"

	// TaxRuleModelJurisdictionTypeIDCounty captures enum value "County"
	TaxRuleModelJurisdictionTypeIDCounty string = "County"

	// TaxRuleModelJurisdictionTypeIDCity captures enum value "City"
	TaxRuleModelJurisdictionTypeIDCity string = "City"

	// TaxRuleModelJurisdictionTypeIDSpecial captures enum value "Special"
	TaxRuleModelJurisdictionTypeIDSpecial string = "Special"
)

// prop value enum
func (m *TaxRuleModel) validateJurisdictionTypeIDEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, taxRuleModelTypeJurisdictionTypeIDPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TaxRuleModel) validateJurisdictionTypeID(formats strfmt.Registry) error {
	if swag.IsZero(m.JurisdictionTypeID) { // not required
		return nil
	}

	// value enum
	if err := m.validateJurisdictionTypeIDEnum("jurisdictionTypeId", "body", m.JurisdictionTypeID); err != nil {
		return err
	}

	return nil
}

func (m *TaxRuleModel) validateModifiedDate(formats strfmt.Registry) error {
	if swag.IsZero(m.ModifiedDate) { // not required
		return nil
	}

	if err := validate.FormatOf("modifiedDate", "body", "date-time", m.ModifiedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *TaxRuleModel) validateNonPassthroughExpression(formats strfmt.Registry) error {
	if swag.IsZero(m.NonPassthroughExpression) { // not required
		return nil
	}

	if err := validate.MinLength("nonPassthroughExpression", "body", *m.NonPassthroughExpression, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("nonPassthroughExpression", "body", *m.NonPassthroughExpression, 500); err != nil {
		return err
	}

	return nil
}

func (m *TaxRuleModel) validateOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.Options) { // not required
		return nil
	}

	if err := validate.MinLength("options", "body", *m.Options, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("options", "body", *m.Options, 100); err != nil {
		return err
	}

	return nil
}

var taxRuleModelTypeRateTypeIDPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ReducedA","ReducedB","Food","General","IncreasedStandard","LinenRental","Medical","Construction","Parking","SuperReduced","ReducedR","Standard","Leasing","LeasingLow","Services","Zero"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		taxRuleModelTypeRateTypeIDPropEnum = append(taxRuleModelTypeRateTypeIDPropEnum, v)
	}
}

const (

	// TaxRuleModelRateTypeIDReducedA captures enum value "ReducedA"
	TaxRuleModelRateTypeIDReducedA string = "ReducedA"

	// TaxRuleModelRateTypeIDReducedB captures enum value "ReducedB"
	TaxRuleModelRateTypeIDReducedB string = "ReducedB"

	// TaxRuleModelRateTypeIDFood captures enum value "Food"
	TaxRuleModelRateTypeIDFood string = "Food"

	// TaxRuleModelRateTypeIDGeneral captures enum value "General"
	TaxRuleModelRateTypeIDGeneral string = "General"

	// TaxRuleModelRateTypeIDIncreasedStandard captures enum value "IncreasedStandard"
	TaxRuleModelRateTypeIDIncreasedStandard string = "IncreasedStandard"

	// TaxRuleModelRateTypeIDLinenRental captures enum value "LinenRental"
	TaxRuleModelRateTypeIDLinenRental string = "LinenRental"

	// TaxRuleModelRateTypeIDMedical captures enum value "Medical"
	TaxRuleModelRateTypeIDMedical string = "Medical"

	// TaxRuleModelRateTypeIDConstruction captures enum value "Construction"
	TaxRuleModelRateTypeIDConstruction string = "Construction"

	// TaxRuleModelRateTypeIDParking captures enum value "Parking"
	TaxRuleModelRateTypeIDParking string = "Parking"

	// TaxRuleModelRateTypeIDSuperReduced captures enum value "SuperReduced"
	TaxRuleModelRateTypeIDSuperReduced string = "SuperReduced"

	// TaxRuleModelRateTypeIDReducedR captures enum value "ReducedR"
	TaxRuleModelRateTypeIDReducedR string = "ReducedR"

	// TaxRuleModelRateTypeIDStandard captures enum value "Standard"
	TaxRuleModelRateTypeIDStandard string = "Standard"

	// TaxRuleModelRateTypeIDLeasing captures enum value "Leasing"
	TaxRuleModelRateTypeIDLeasing string = "Leasing"

	// TaxRuleModelRateTypeIDLeasingLow captures enum value "LeasingLow"
	TaxRuleModelRateTypeIDLeasingLow string = "LeasingLow"

	// TaxRuleModelRateTypeIDServices captures enum value "Services"
	TaxRuleModelRateTypeIDServices string = "Services"

	// TaxRuleModelRateTypeIDZero captures enum value "Zero"
	TaxRuleModelRateTypeIDZero string = "Zero"
)

// prop value enum
func (m *TaxRuleModel) validateRateTypeIDEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, taxRuleModelTypeRateTypeIDPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TaxRuleModel) validateRateTypeID(formats strfmt.Registry) error {
	if swag.IsZero(m.RateTypeID) { // not required
		return nil
	}

	// value enum
	if err := m.validateRateTypeIDEnum("rateTypeId", "body", m.RateTypeID); err != nil {
		return err
	}

	return nil
}

var taxRuleModelTypeSourcingPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Mixed","Destination","Origin"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		taxRuleModelTypeSourcingPropEnum = append(taxRuleModelTypeSourcingPropEnum, v)
	}
}

const (

	// TaxRuleModelSourcingMixed captures enum value "Mixed"
	TaxRuleModelSourcingMixed string = "Mixed"

	// TaxRuleModelSourcingDestination captures enum value "Destination"
	TaxRuleModelSourcingDestination string = "Destination"

	// TaxRuleModelSourcingOrigin captures enum value "Origin"
	TaxRuleModelSourcingOrigin string = "Origin"
)

// prop value enum
func (m *TaxRuleModel) validateSourcingEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, taxRuleModelTypeSourcingPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TaxRuleModel) validateSourcing(formats strfmt.Registry) error {
	if swag.IsZero(m.Sourcing) { // not required
		return nil
	}

	// value enum
	if err := m.validateSourcingEnum("sourcing", "body", m.Sourcing); err != nil {
		return err
	}

	return nil
}

func (m *TaxRuleModel) validateStateFIPS(formats strfmt.Registry) error {
	if swag.IsZero(m.StateFIPS) { // not required
		return nil
	}

	if err := validate.MinLength("stateFIPS", "body", *m.StateFIPS, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("stateFIPS", "body", *m.StateFIPS, 2); err != nil {
		return err
	}

	return nil
}

func (m *TaxRuleModel) validateTaxCode(formats strfmt.Registry) error {
	if swag.IsZero(m.TaxCode) { // not required
		return nil
	}

	if err := validate.MinLength("taxCode", "body", *m.TaxCode, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("taxCode", "body", *m.TaxCode, 25); err != nil {
		return err
	}

	return nil
}

func (m *TaxRuleModel) validateTaxRuleProductDetail(formats strfmt.Registry) error {
	if swag.IsZero(m.TaxRuleProductDetail) { // not required
		return nil
	}

	for i := 0; i < len(m.TaxRuleProductDetail); i++ {
		if swag.IsZero(m.TaxRuleProductDetail[i]) { // not required
			continue
		}

		if m.TaxRuleProductDetail[i] != nil {
			if err := m.TaxRuleProductDetail[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taxRuleProductDetail" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("taxRuleProductDetail" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var taxRuleModelTypeTaxRuleTypeIDPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["RateRule","RateOverrideRule","BaseRule","ExemptEntityRule","ProductTaxabilityRule","NexusRule","RateCapRule","TaxOverrideRule","FeeRule","OtherRule"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		taxRuleModelTypeTaxRuleTypeIDPropEnum = append(taxRuleModelTypeTaxRuleTypeIDPropEnum, v)
	}
}

const (

	// TaxRuleModelTaxRuleTypeIDRateRule captures enum value "RateRule"
	TaxRuleModelTaxRuleTypeIDRateRule string = "RateRule"

	// TaxRuleModelTaxRuleTypeIDRateOverrideRule captures enum value "RateOverrideRule"
	TaxRuleModelTaxRuleTypeIDRateOverrideRule string = "RateOverrideRule"

	// TaxRuleModelTaxRuleTypeIDBaseRule captures enum value "BaseRule"
	TaxRuleModelTaxRuleTypeIDBaseRule string = "BaseRule"

	// TaxRuleModelTaxRuleTypeIDExemptEntityRule captures enum value "ExemptEntityRule"
	TaxRuleModelTaxRuleTypeIDExemptEntityRule string = "ExemptEntityRule"

	// TaxRuleModelTaxRuleTypeIDProductTaxabilityRule captures enum value "ProductTaxabilityRule"
	TaxRuleModelTaxRuleTypeIDProductTaxabilityRule string = "ProductTaxabilityRule"

	// TaxRuleModelTaxRuleTypeIDNexusRule captures enum value "NexusRule"
	TaxRuleModelTaxRuleTypeIDNexusRule string = "NexusRule"

	// TaxRuleModelTaxRuleTypeIDRateCapRule captures enum value "RateCapRule"
	TaxRuleModelTaxRuleTypeIDRateCapRule string = "RateCapRule"

	// TaxRuleModelTaxRuleTypeIDTaxOverrideRule captures enum value "TaxOverrideRule"
	TaxRuleModelTaxRuleTypeIDTaxOverrideRule string = "TaxOverrideRule"

	// TaxRuleModelTaxRuleTypeIDFeeRule captures enum value "FeeRule"
	TaxRuleModelTaxRuleTypeIDFeeRule string = "FeeRule"

	// TaxRuleModelTaxRuleTypeIDOtherRule captures enum value "OtherRule"
	TaxRuleModelTaxRuleTypeIDOtherRule string = "OtherRule"
)

// prop value enum
func (m *TaxRuleModel) validateTaxRuleTypeIDEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, taxRuleModelTypeTaxRuleTypeIDPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TaxRuleModel) validateTaxRuleTypeID(formats strfmt.Registry) error {

	if err := validate.Required("taxRuleTypeId", "body", m.TaxRuleTypeID); err != nil {
		return err
	}

	// value enum
	if err := m.validateTaxRuleTypeIDEnum("taxRuleTypeId", "body", *m.TaxRuleTypeID); err != nil {
		return err
	}

	return nil
}

var taxRuleModelTypeTaxTypeIDPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["E","Lodging","Bottle","RentToOwn","BikeTax","LandedCost","CheckoutBag","Alcohol","Amusement","Hospitality","RentalLeasing","GrossReceipts","Mattress","Lumber","Paint","Tires","EI","All","BothSalesAndUseTax","ConsumerUseTax","ConsumersUseAndSellersUseTax","ConsumerUseAndSalesTax","Fee","VATInputTax","LightBulbs","Meals","VATNonrecoverableInputTax","VATOutputTax","PIF","Rental","SalesTax","UseTax","EWaste","Batteries"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		taxRuleModelTypeTaxTypeIDPropEnum = append(taxRuleModelTypeTaxTypeIDPropEnum, v)
	}
}

const (

	// TaxRuleModelTaxTypeIDE captures enum value "E"
	TaxRuleModelTaxTypeIDE string = "E"

	// TaxRuleModelTaxTypeIDLodging captures enum value "Lodging"
	TaxRuleModelTaxTypeIDLodging string = "Lodging"

	// TaxRuleModelTaxTypeIDBottle captures enum value "Bottle"
	TaxRuleModelTaxTypeIDBottle string = "Bottle"

	// TaxRuleModelTaxTypeIDRentToOwn captures enum value "RentToOwn"
	TaxRuleModelTaxTypeIDRentToOwn string = "RentToOwn"

	// TaxRuleModelTaxTypeIDBikeTax captures enum value "BikeTax"
	TaxRuleModelTaxTypeIDBikeTax string = "BikeTax"

	// TaxRuleModelTaxTypeIDLandedCost captures enum value "LandedCost"
	TaxRuleModelTaxTypeIDLandedCost string = "LandedCost"

	// TaxRuleModelTaxTypeIDCheckoutBag captures enum value "CheckoutBag"
	TaxRuleModelTaxTypeIDCheckoutBag string = "CheckoutBag"

	// TaxRuleModelTaxTypeIDAlcohol captures enum value "Alcohol"
	TaxRuleModelTaxTypeIDAlcohol string = "Alcohol"

	// TaxRuleModelTaxTypeIDAmusement captures enum value "Amusement"
	TaxRuleModelTaxTypeIDAmusement string = "Amusement"

	// TaxRuleModelTaxTypeIDHospitality captures enum value "Hospitality"
	TaxRuleModelTaxTypeIDHospitality string = "Hospitality"

	// TaxRuleModelTaxTypeIDRentalLeasing captures enum value "RentalLeasing"
	TaxRuleModelTaxTypeIDRentalLeasing string = "RentalLeasing"

	// TaxRuleModelTaxTypeIDGrossReceipts captures enum value "GrossReceipts"
	TaxRuleModelTaxTypeIDGrossReceipts string = "GrossReceipts"

	// TaxRuleModelTaxTypeIDMattress captures enum value "Mattress"
	TaxRuleModelTaxTypeIDMattress string = "Mattress"

	// TaxRuleModelTaxTypeIDLumber captures enum value "Lumber"
	TaxRuleModelTaxTypeIDLumber string = "Lumber"

	// TaxRuleModelTaxTypeIDPaint captures enum value "Paint"
	TaxRuleModelTaxTypeIDPaint string = "Paint"

	// TaxRuleModelTaxTypeIDTires captures enum value "Tires"
	TaxRuleModelTaxTypeIDTires string = "Tires"

	// TaxRuleModelTaxTypeIDEI captures enum value "EI"
	TaxRuleModelTaxTypeIDEI string = "EI"

	// TaxRuleModelTaxTypeIDAll captures enum value "All"
	TaxRuleModelTaxTypeIDAll string = "All"

	// TaxRuleModelTaxTypeIDBothSalesAndUseTax captures enum value "BothSalesAndUseTax"
	TaxRuleModelTaxTypeIDBothSalesAndUseTax string = "BothSalesAndUseTax"

	// TaxRuleModelTaxTypeIDConsumerUseTax captures enum value "ConsumerUseTax"
	TaxRuleModelTaxTypeIDConsumerUseTax string = "ConsumerUseTax"

	// TaxRuleModelTaxTypeIDConsumersUseAndSellersUseTax captures enum value "ConsumersUseAndSellersUseTax"
	TaxRuleModelTaxTypeIDConsumersUseAndSellersUseTax string = "ConsumersUseAndSellersUseTax"

	// TaxRuleModelTaxTypeIDConsumerUseAndSalesTax captures enum value "ConsumerUseAndSalesTax"
	TaxRuleModelTaxTypeIDConsumerUseAndSalesTax string = "ConsumerUseAndSalesTax"

	// TaxRuleModelTaxTypeIDFee captures enum value "Fee"
	TaxRuleModelTaxTypeIDFee string = "Fee"

	// TaxRuleModelTaxTypeIDVATInputTax captures enum value "VATInputTax"
	TaxRuleModelTaxTypeIDVATInputTax string = "VATInputTax"

	// TaxRuleModelTaxTypeIDLightBulbs captures enum value "LightBulbs"
	TaxRuleModelTaxTypeIDLightBulbs string = "LightBulbs"

	// TaxRuleModelTaxTypeIDMeals captures enum value "Meals"
	TaxRuleModelTaxTypeIDMeals string = "Meals"

	// TaxRuleModelTaxTypeIDVATNonrecoverableInputTax captures enum value "VATNonrecoverableInputTax"
	TaxRuleModelTaxTypeIDVATNonrecoverableInputTax string = "VATNonrecoverableInputTax"

	// TaxRuleModelTaxTypeIDVATOutputTax captures enum value "VATOutputTax"
	TaxRuleModelTaxTypeIDVATOutputTax string = "VATOutputTax"

	// TaxRuleModelTaxTypeIDPIF captures enum value "PIF"
	TaxRuleModelTaxTypeIDPIF string = "PIF"

	// TaxRuleModelTaxTypeIDRental captures enum value "Rental"
	TaxRuleModelTaxTypeIDRental string = "Rental"

	// TaxRuleModelTaxTypeIDSalesTax captures enum value "SalesTax"
	TaxRuleModelTaxTypeIDSalesTax string = "SalesTax"

	// TaxRuleModelTaxTypeIDUseTax captures enum value "UseTax"
	TaxRuleModelTaxTypeIDUseTax string = "UseTax"

	// TaxRuleModelTaxTypeIDEWaste captures enum value "EWaste"
	TaxRuleModelTaxTypeIDEWaste string = "EWaste"

	// TaxRuleModelTaxTypeIDBatteries captures enum value "Batteries"
	TaxRuleModelTaxTypeIDBatteries string = "Batteries"
)

// prop value enum
func (m *TaxRuleModel) validateTaxTypeIDEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, taxRuleModelTypeTaxTypeIDPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TaxRuleModel) validateTaxTypeID(formats strfmt.Registry) error {
	if swag.IsZero(m.TaxTypeID) { // not required
		return nil
	}

	// value enum
	if err := m.validateTaxTypeIDEnum("taxTypeId", "body", m.TaxTypeID); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this tax rule model based on the context it is used
func (m *TaxRuleModel) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCreatedDate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCreatedUserID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateModifiedDate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateModifiedUserID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTaxRuleProductDetail(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TaxRuleModel) contextValidateCreatedDate(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "createdDate", "body", strfmt.DateTime(m.CreatedDate)); err != nil {
		return err
	}

	return nil
}

func (m *TaxRuleModel) contextValidateCreatedUserID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "createdUserId", "body", int32(m.CreatedUserID)); err != nil {
		return err
	}

	return nil
}

func (m *TaxRuleModel) contextValidateModifiedDate(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "modifiedDate", "body", strfmt.DateTime(m.ModifiedDate)); err != nil {
		return err
	}

	return nil
}

func (m *TaxRuleModel) contextValidateModifiedUserID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "modifiedUserId", "body", int32(m.ModifiedUserID)); err != nil {
		return err
	}

	return nil
}

func (m *TaxRuleModel) contextValidateTaxRuleProductDetail(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.TaxRuleProductDetail); i++ {

		if m.TaxRuleProductDetail[i] != nil {
			if err := m.TaxRuleProductDetail[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taxRuleProductDetail" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("taxRuleProductDetail" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *TaxRuleModel) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TaxRuleModel) UnmarshalBinary(b []byte) error {
	var res TaxRuleModel
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
