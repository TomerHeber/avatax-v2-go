// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// BatchModel Represents a batch of uploaded documents.
// Example: {"batchAgent":"manual","files":[{"content":"UHJvY2Vzc0NvZGUsRG9jQ29kZSxEb2NUeXBlLERvY0RhdGUsQ29tcGFueUNvZGUsQ3VzdG9tZXJDb2RlLEVudGl0eVVzZUNvZGUsTGluZU5vLFRheENvZGUsVGF4RGF0ZSxJdGVtQ29kZSxEZXNjcmlwdGlvbixRdHksQW1vdW50LERpc2NvdW50LFJlZjEsUmVmMixFeGVtcHRpb25ObyxSZXZBY2N0LERlc3RBZGRyZXNzLERlc3RDaXR5LERlc3RSZWdpb24sRGVzdFBvc3RhbENvZGUsRGVzdENvdW50cnksT3JpZ0FkZHJlc3MsT3JpZ0NpdHksT3JpZ1JlZ2lvbixPcmlnUG9zdGFsQ29kZSxPcmlnQ291bnRyeSxMb2NhdGlvbkNvZGUsU2FsZXNQZXJzb25Db2RlLFB1cmNoYXNlT3JkZXJObyxDdXJyZW5jeUNvZGUsRXhjaGFuZ2VSYXRlLEV4Y2hhbmdlUmF0ZUVmZkRhdGUsUGF5bWVudERhdGUsVGF4SW5jbHVkZWQsRGVzdFRheFJlZ2lvbixPcmlnVGF4UmVnaW9uLFRheGFibGUsVGF4VHlwZSxUb3RhbFRheCxDb3VudHJ5TmFtZSxDb3VudHJ5Q29kZSxDb3VudHJ5UmF0ZSxDb3VudHJ5VGF4LFN0YXRlTmFtZSxTdGF0ZUNvZGUsU3RhdGVSYXRlLFN0YXRlVGF4LENvdW50eU5hbWUsQ291bnR5Q29kZSxDb3VudHlSYXRlLENvdW50eVRheCxDaXR5TmFtZSxDaXR5Q29kZSxDaXR5UmF0ZSxDaXR5VGF4LE90aGVyMU5hbWUsT3RoZXIxQ29kZSxPdGhlcjFSYXRlLE90aGVyMVRheCxPdGhlcjJOYW1lLE90aGVyMkNvZGUsT3RoZXIyUmF0ZSxPdGhlcjJUYXgsT3RoZXIzTmFtZSxPdGhlcjNDb2RlLE90aGVyM1JhdGUsT3RoZXIzVGF4LE90aGVyNE5hbWUsT3RoZXI0Q29kZSxPdGhlcjRSYXRlLE90aGVyNFRheCxSZWZlcmVuY2VDb2RlLEJ1eWVyc1ZBVE5vLElzU2VsbGVySW1wb3J0ZXJPZlJlY29yZCxCUkJ1eWVyVHlwZSxCUkJ1eWVyX0lzRXhlbXB0T3JDYW5ub3RXSF9JUlJGLEJSQnV5ZXJfSXNFeGVtcHRPckNhbm5vdFdIX1BJU1JGLEJSQnV5ZXJfSXNFeGVtcHRPckNhbm5vdFdIX0NPRklOU1JGLEJSQnV5ZXJfSXNFeGVtcHRPckNhbm5vdFdIX0NTTExSRixCUkJ1eWVyX0lzRXhlbXB0X1BJUyxCUkJ1eWVyX0lzRXhlbXB0X0NPRklOUyxCUkJ1eWVyX0lzRXhlbXB0X0NTTEwsSGVhZGVyX0Rlc2NyaXB0aW9uLEVtYWlsDQozLDlhYzI4MGMzLTNhNTUtNGEzNS1iZWQyLWE4M2RiNTNiMDUxZSwxLDEvMS8yMDE0LERFRkFVTFQsQ3VzdDEsLDEsLCwsLCwxMDAwLCwsLCwsMjM1IEUgNDJuZCBTdCAsTmV3IFlvcmssTlksMTAwMTctNTcwMyAgLFVTLDkwMCBXaW5zbG93IFdheSxCYWluYnJpZGdlIElzbGFuZCxXQSw5ODExMCxVUywsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwNCg==","contentLength":0,"contentType":"text/csv","fileExtension":".csv","filePath":"samplebatch.csv","name":"samplebatch.csv"}],"name":"TestBatch","type":"TransactionImport"}
//
// swagger:model BatchModel
type BatchModel struct {

	// The Account ID number of the account that owns this batch.
	AccountID int32 `json:"accountId,omitempty"`

	// The agent used to create this batch
	// Example: manual
	// Max Length: 50
	// Min Length: 0
	BatchAgent *string `json:"batchAgent,omitempty"`

	// The Company ID number of the company that owns this batch.
	CompanyID int32 `json:"companyId,omitempty"`

	// The date/time when this batch was completely processed
	// Read Only: true
	// Format: date-time
	CompletedDate strfmt.DateTime `json:"completedDate,omitempty"`

	// The date when this record was created.
	// Read Only: true
	// Format: date-time
	CreatedDate strfmt.DateTime `json:"createdDate,omitempty"`

	// The User ID of the user who created this record.
	// Read Only: true
	CreatedUserID int32 `json:"createdUserId,omitempty"`

	// The current record being processed
	// Read Only: true
	CurrentRecord int32 `json:"currentRecord,omitempty"`

	// The list of files contained in this batch.
	// Example: [{"content":"UHJvY2Vzc0NvZGUsRG9jQ29kZSxEb2NUeXBlLERvY0RhdGUsQ29tcGFueUNvZGUsQ3VzdG9tZXJDb2RlLEVudGl0eVVzZUNvZGUsTGluZU5vLFRheENvZGUsVGF4RGF0ZSxJdGVtQ29kZSxEZXNjcmlwdGlvbixRdHksQW1vdW50LERpc2NvdW50LFJlZjEsUmVmMixFeGVtcHRpb25ObyxSZXZBY2N0LERlc3RBZGRyZXNzLERlc3RDaXR5LERlc3RSZWdpb24sRGVzdFBvc3RhbENvZGUsRGVzdENvdW50cnksT3JpZ0FkZHJlc3MsT3JpZ0NpdHksT3JpZ1JlZ2lvbixPcmlnUG9zdGFsQ29kZSxPcmlnQ291bnRyeSxMb2NhdGlvbkNvZGUsU2FsZXNQZXJzb25Db2RlLFB1cmNoYXNlT3JkZXJObyxDdXJyZW5jeUNvZGUsRXhjaGFuZ2VSYXRlLEV4Y2hhbmdlUmF0ZUVmZkRhdGUsUGF5bWVudERhdGUsVGF4SW5jbHVkZWQsRGVzdFRheFJlZ2lvbixPcmlnVGF4UmVnaW9uLFRheGFibGUsVGF4VHlwZSxUb3RhbFRheCxDb3VudHJ5TmFtZSxDb3VudHJ5Q29kZSxDb3VudHJ5UmF0ZSxDb3VudHJ5VGF4LFN0YXRlTmFtZSxTdGF0ZUNvZGUsU3RhdGVSYXRlLFN0YXRlVGF4LENvdW50eU5hbWUsQ291bnR5Q29kZSxDb3VudHlSYXRlLENvdW50eVRheCxDaXR5TmFtZSxDaXR5Q29kZSxDaXR5UmF0ZSxDaXR5VGF4LE90aGVyMU5hbWUsT3RoZXIxQ29kZSxPdGhlcjFSYXRlLE90aGVyMVRheCxPdGhlcjJOYW1lLE90aGVyMkNvZGUsT3RoZXIyUmF0ZSxPdGhlcjJUYXgsT3RoZXIzTmFtZSxPdGhlcjNDb2RlLE90aGVyM1JhdGUsT3RoZXIzVGF4LE90aGVyNE5hbWUsT3RoZXI0Q29kZSxPdGhlcjRSYXRlLE90aGVyNFRheCxSZWZlcmVuY2VDb2RlLEJ1eWVyc1ZBVE5vLElzU2VsbGVySW1wb3J0ZXJPZlJlY29yZCxCUkJ1eWVyVHlwZSxCUkJ1eWVyX0lzRXhlbXB0T3JDYW5ub3RXSF9JUlJGLEJSQnV5ZXJfSXNFeGVtcHRPckNhbm5vdFdIX1BJU1JGLEJSQnV5ZXJfSXNFeGVtcHRPckNhbm5vdFdIX0NPRklOU1JGLEJSQnV5ZXJfSXNFeGVtcHRPckNhbm5vdFdIX0NTTExSRixCUkJ1eWVyX0lzRXhlbXB0X1BJUyxCUkJ1eWVyX0lzRXhlbXB0X0NPRklOUyxCUkJ1eWVyX0lzRXhlbXB0X0NTTEwsSGVhZGVyX0Rlc2NyaXB0aW9uLEVtYWlsDQozLDlhYzI4MGMzLTNhNTUtNGEzNS1iZWQyLWE4M2RiNTNiMDUxZSwxLDEvMS8yMDE0LERFRkFVTFQsQ3VzdDEsLDEsLCwsLCwxMDAwLCwsLCwsMjM1IEUgNDJuZCBTdCAsTmV3IFlvcmssTlksMTAwMTctNTcwMyAgLFVTLDkwMCBXaW5zbG93IFdheSxCYWluYnJpZGdlIElzbGFuZCxXQSw5ODExMCxVUywsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwNCg==","contentLength":0,"contentType":"text/csv","fileExtension":".csv","filePath":"samplebatch.csv","name":"samplebatch.csv"}]
	Files []*BatchFileModel `json:"files"`

	// The unique ID number of this batch.
	// Read Only: true
	ID int32 `json:"id,omitempty"`

	// The date/time when this record was last modified.
	// Read Only: true
	// Format: date-time
	ModifiedDate strfmt.DateTime `json:"modifiedDate,omitempty"`

	// The user ID of the user who last modified this record.
	// Read Only: true
	ModifiedUserID int32 `json:"modifiedUserId,omitempty"`

	// The user-friendly readable name for this batch.
	// Example: TestBatch
	// Required: true
	// Max Length: 194
	// Min Length: 0
	Name *string `json:"name"`

	// Any optional flags provided for this batch
	// Max Length: 200
	// Min Length: 0
	Options *string `json:"options,omitempty"`

	// The number of records in this batch; determined by the server
	// Read Only: true
	RecordCount int32 `json:"recordCount,omitempty"`

	// The date/time when this batch started processing
	// Read Only: true
	// Format: date-time
	StartedDate strfmt.DateTime `json:"startedDate,omitempty"`

	// This batch's current processing status
	// Example: Waiting
	// Read Only: true
	// Enum: [Waiting SystemErrors Cancelled Completed Creating Deleted Errors Paused Processing Cancelling]
	Status string `json:"status,omitempty"`

	// The type of this batch.
	// Example: AvaCertUpdate
	// Required: true
	// Enum: [AvaCertUpdate AvaCertUpdateAll BatchMaintenance CompanyLocationImport DocumentImport ExemptCertImport ItemImport SalesAuditExport SstpTestDeckImport TaxRuleImport TransactionImport UPCBulkImport UPCValidationImport CustomerSupplierImport]
	Type *string `json:"type"`
}

// Validate validates this batch model
func (m *BatchModel) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBatchAgent(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCompletedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFiles(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateModifiedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStartedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BatchModel) validateBatchAgent(formats strfmt.Registry) error {
	if swag.IsZero(m.BatchAgent) { // not required
		return nil
	}

	if err := validate.MinLength("batchAgent", "body", *m.BatchAgent, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("batchAgent", "body", *m.BatchAgent, 50); err != nil {
		return err
	}

	return nil
}

func (m *BatchModel) validateCompletedDate(formats strfmt.Registry) error {
	if swag.IsZero(m.CompletedDate) { // not required
		return nil
	}

	if err := validate.FormatOf("completedDate", "body", "date-time", m.CompletedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *BatchModel) validateCreatedDate(formats strfmt.Registry) error {
	if swag.IsZero(m.CreatedDate) { // not required
		return nil
	}

	if err := validate.FormatOf("createdDate", "body", "date-time", m.CreatedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *BatchModel) validateFiles(formats strfmt.Registry) error {
	if swag.IsZero(m.Files) { // not required
		return nil
	}

	for i := 0; i < len(m.Files); i++ {
		if swag.IsZero(m.Files[i]) { // not required
			continue
		}

		if m.Files[i] != nil {
			if err := m.Files[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("files" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("files" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BatchModel) validateModifiedDate(formats strfmt.Registry) error {
	if swag.IsZero(m.ModifiedDate) { // not required
		return nil
	}

	if err := validate.FormatOf("modifiedDate", "body", "date-time", m.ModifiedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *BatchModel) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	if err := validate.MinLength("name", "body", *m.Name, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("name", "body", *m.Name, 194); err != nil {
		return err
	}

	return nil
}

func (m *BatchModel) validateOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.Options) { // not required
		return nil
	}

	if err := validate.MinLength("options", "body", *m.Options, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("options", "body", *m.Options, 200); err != nil {
		return err
	}

	return nil
}

func (m *BatchModel) validateStartedDate(formats strfmt.Registry) error {
	if swag.IsZero(m.StartedDate) { // not required
		return nil
	}

	if err := validate.FormatOf("startedDate", "body", "date-time", m.StartedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

var batchModelTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Waiting","SystemErrors","Cancelled","Completed","Creating","Deleted","Errors","Paused","Processing","Cancelling"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		batchModelTypeStatusPropEnum = append(batchModelTypeStatusPropEnum, v)
	}
}

const (

	// BatchModelStatusWaiting captures enum value "Waiting"
	BatchModelStatusWaiting string = "Waiting"

	// BatchModelStatusSystemErrors captures enum value "SystemErrors"
	BatchModelStatusSystemErrors string = "SystemErrors"

	// BatchModelStatusCancelled captures enum value "Cancelled"
	BatchModelStatusCancelled string = "Cancelled"

	// BatchModelStatusCompleted captures enum value "Completed"
	BatchModelStatusCompleted string = "Completed"

	// BatchModelStatusCreating captures enum value "Creating"
	BatchModelStatusCreating string = "Creating"

	// BatchModelStatusDeleted captures enum value "Deleted"
	BatchModelStatusDeleted string = "Deleted"

	// BatchModelStatusErrors captures enum value "Errors"
	BatchModelStatusErrors string = "Errors"

	// BatchModelStatusPaused captures enum value "Paused"
	BatchModelStatusPaused string = "Paused"

	// BatchModelStatusProcessing captures enum value "Processing"
	BatchModelStatusProcessing string = "Processing"

	// BatchModelStatusCancelling captures enum value "Cancelling"
	BatchModelStatusCancelling string = "Cancelling"
)

// prop value enum
func (m *BatchModel) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, batchModelTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *BatchModel) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

var batchModelTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["AvaCertUpdate","AvaCertUpdateAll","BatchMaintenance","CompanyLocationImport","DocumentImport","ExemptCertImport","ItemImport","SalesAuditExport","SstpTestDeckImport","TaxRuleImport","TransactionImport","UPCBulkImport","UPCValidationImport","CustomerSupplierImport"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		batchModelTypeTypePropEnum = append(batchModelTypeTypePropEnum, v)
	}
}

const (

	// BatchModelTypeAvaCertUpdate captures enum value "AvaCertUpdate"
	BatchModelTypeAvaCertUpdate string = "AvaCertUpdate"

	// BatchModelTypeAvaCertUpdateAll captures enum value "AvaCertUpdateAll"
	BatchModelTypeAvaCertUpdateAll string = "AvaCertUpdateAll"

	// BatchModelTypeBatchMaintenance captures enum value "BatchMaintenance"
	BatchModelTypeBatchMaintenance string = "BatchMaintenance"

	// BatchModelTypeCompanyLocationImport captures enum value "CompanyLocationImport"
	BatchModelTypeCompanyLocationImport string = "CompanyLocationImport"

	// BatchModelTypeDocumentImport captures enum value "DocumentImport"
	BatchModelTypeDocumentImport string = "DocumentImport"

	// BatchModelTypeExemptCertImport captures enum value "ExemptCertImport"
	BatchModelTypeExemptCertImport string = "ExemptCertImport"

	// BatchModelTypeItemImport captures enum value "ItemImport"
	BatchModelTypeItemImport string = "ItemImport"

	// BatchModelTypeSalesAuditExport captures enum value "SalesAuditExport"
	BatchModelTypeSalesAuditExport string = "SalesAuditExport"

	// BatchModelTypeSstpTestDeckImport captures enum value "SstpTestDeckImport"
	BatchModelTypeSstpTestDeckImport string = "SstpTestDeckImport"

	// BatchModelTypeTaxRuleImport captures enum value "TaxRuleImport"
	BatchModelTypeTaxRuleImport string = "TaxRuleImport"

	// BatchModelTypeTransactionImport captures enum value "TransactionImport"
	BatchModelTypeTransactionImport string = "TransactionImport"

	// BatchModelTypeUPCBulkImport captures enum value "UPCBulkImport"
	BatchModelTypeUPCBulkImport string = "UPCBulkImport"

	// BatchModelTypeUPCValidationImport captures enum value "UPCValidationImport"
	BatchModelTypeUPCValidationImport string = "UPCValidationImport"

	// BatchModelTypeCustomerSupplierImport captures enum value "CustomerSupplierImport"
	BatchModelTypeCustomerSupplierImport string = "CustomerSupplierImport"
)

// prop value enum
func (m *BatchModel) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, batchModelTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *BatchModel) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this batch model based on the context it is used
func (m *BatchModel) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCompletedDate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCreatedDate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCreatedUserID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCurrentRecord(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFiles(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateModifiedDate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateModifiedUserID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRecordCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStartedDate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BatchModel) contextValidateCompletedDate(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "completedDate", "body", strfmt.DateTime(m.CompletedDate)); err != nil {
		return err
	}

	return nil
}

func (m *BatchModel) contextValidateCreatedDate(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "createdDate", "body", strfmt.DateTime(m.CreatedDate)); err != nil {
		return err
	}

	return nil
}

func (m *BatchModel) contextValidateCreatedUserID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "createdUserId", "body", int32(m.CreatedUserID)); err != nil {
		return err
	}

	return nil
}

func (m *BatchModel) contextValidateCurrentRecord(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "currentRecord", "body", int32(m.CurrentRecord)); err != nil {
		return err
	}

	return nil
}

func (m *BatchModel) contextValidateFiles(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Files); i++ {

		if m.Files[i] != nil {
			if err := m.Files[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("files" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("files" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BatchModel) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "id", "body", int32(m.ID)); err != nil {
		return err
	}

	return nil
}

func (m *BatchModel) contextValidateModifiedDate(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "modifiedDate", "body", strfmt.DateTime(m.ModifiedDate)); err != nil {
		return err
	}

	return nil
}

func (m *BatchModel) contextValidateModifiedUserID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "modifiedUserId", "body", int32(m.ModifiedUserID)); err != nil {
		return err
	}

	return nil
}

func (m *BatchModel) contextValidateRecordCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "recordCount", "body", int32(m.RecordCount)); err != nil {
		return err
	}

	return nil
}

func (m *BatchModel) contextValidateStartedDate(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "startedDate", "body", strfmt.DateTime(m.StartedDate)); err != nil {
		return err
	}

	return nil
}

func (m *BatchModel) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "status", "body", string(m.Status)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BatchModel) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BatchModel) UnmarshalBinary(b []byte) error {
	var res BatchModel
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
