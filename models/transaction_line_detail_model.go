// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// TransactionLineDetailModel An individual tax detail element.  Represents the amount of tax calculated for a particular jurisdiction, for a particular line in an invoice.
// Example: {"addressId":12345,"country":"US","exemptAmount":0,"exemptReasonId":4,"exemptUnits":62.5,"id":123456789,"inState":false,"jurisCode":"06","jurisName":"CALIFORNIA","jurisType":"STA","jurisdictionId":5000531,"nonTaxableAmount":0,"nonTaxableRuleId":0,"nonTaxableType":"BaseRule","nonTaxableUnits":1000,"rate":0.0625,"rateRuleId":1321915,"rateSourceId":3,"rateType":"General","region":"CA","reportingExemptUnits":125,"reportingNonTaxableUnits":2000,"reportingTax":125,"reportingTaxCalculated":125,"reportingTaxableUnits":125,"serCode":"","signatureCode":"AGAM","sourcing":"Destination","stateAssignedNo":"","stateFIPS":"06","tax":62.5,"taxAuthorityTypeId":45,"taxCalculated":62.5,"taxName":"CA STATE TAX","taxOverride":0,"taxRegionId":2127184,"taxType":"Sales","taxableAmount":1000,"taxableUnits":62.5,"transactionId":123456789,"transactionLineId":123456789}
//
// swagger:model TransactionLineDetailModel
type TransactionLineDetailModel struct {

	// The unique ID number of the address used for this tax detail.
	// Example: 12345
	AddressID int64 `json:"addressId,omitempty"`

	// The two character ISO 3166 country code of the country where this tax detail is assigned.
	// Example: US
	// Max Length: 2
	// Min Length: 2
	Country string `json:"country,omitempty"`

	// For U.S. transactions, the Federal Information Processing Standard (FIPS) code for the county where this tax detail is assigned.
	CountyFIPS string `json:"countyFIPS,omitempty"`

	// The amount of this line that was considered exempt in this tax detail.
	// Example: 0
	ExemptAmount float64 `json:"exemptAmount,omitempty"`

	// The unique ID number of the exemption reason for this tax detail.
	// Example: 4
	ExemptReasonID int32 `json:"exemptReasonId,omitempty"`

	// Number of units in this line item that were calculated to be exempt according to this rate detail.
	// Example: 62.5
	ExemptUnits float64 `json:"exemptUnits,omitempty"`

	// The unique ID number of this tax detail.
	// Example: 123456789
	// Read Only: true
	ID int64 `json:"id,omitempty"`

	// True if this detail element represented an in-state transaction.
	// Example: false
	InState bool `json:"inState,omitempty"`

	// The Taxes/Fee component. True if the fee is applied.
	IsFee bool `json:"isFee,omitempty"`

	// True if this value is a non-passthrough tax.
	//
	// A non-passthrough tax is a tax that may not be charged to a customer; it must be paid directly by the company.
	IsNonPassThru bool `json:"isNonPassThru,omitempty"`

	// The code of the jurisdiction to which this tax detail applies.
	// Example: 06
	JurisCode string `json:"jurisCode,omitempty"`

	// The name of the jurisdiction to which this tax detail applies.
	// Example: CALIFORNIA
	JurisName string `json:"jurisName,omitempty"`

	// DEPRECATED - Date: 12/20/2017, Version: 18.1, Message: Use jurisdictionTypeId instead.
	// The type of the jurisdiction to which this tax detail applies.
	// Example: STA
	// Enum: [STA CTY CIT STJ CNT]
	JurisType string `json:"jurisType,omitempty"`

	// The unique ID number of the jurisdiction to which this tax detail applies.
	// Example: 5000531
	JurisdictionID int32 `json:"jurisdictionId,omitempty"`

	// The type of the jurisdiction in which this tax detail applies.
	// Example: Country
	// Enum: [Country State County City Special]
	JurisdictionType string `json:"jurisdictionType,omitempty"`

	// LiabilityType identifies the party liable to file the tax. This field is used to filter taxes from reports and tax filings as appropriate.
	// Example: Seller
	// Enum: [Seller BuyersAgent]
	LiabilityType string `json:"liabilityType,omitempty"`

	// The amount of this line item that was considered nontaxable in this tax detail.
	// Example: 0
	NonTaxableAmount float64 `json:"nonTaxableAmount,omitempty"`

	// The rule according to which portion of this detail was considered nontaxable.
	// Example: 0
	NonTaxableRuleID int32 `json:"nonTaxableRuleId,omitempty"`

	// The type of nontaxability that was applied to this tax detail.
	// Example: RateRule
	// Enum: [RateRule RateOverrideRule BaseRule ExemptEntityRule ProductTaxabilityRule NexusRule RateCapRule TaxOverrideRule FeeRule OtherRule]
	NonTaxableType string `json:"nonTaxableType,omitempty"`

	// Number of units in this line item that were calculated to be nontaxable according to this rate detail.
	// Example: 1000
	NonTaxableUnits float64 `json:"nonTaxableUnits,omitempty"`

	// The rate at which this tax detail was calculated.
	// Example: 0.0625
	Rate float64 `json:"rate,omitempty"`

	// The unique ID number of the rule according to which this tax detail was calculated.
	// Example: 1321915
	RateRuleID int32 `json:"rateRuleId,omitempty"`

	// The unique ID number of the source of the rate according to which this tax detail was calculated.
	// Example: 3
	RateSourceID int32 `json:"rateSourceId,omitempty"`

	// DEPRECATED - Date: 12/20/2017, Version: 18.1, Message: Please use rateTypeCode instead.
	// The rate type for this tax detail.
	// Example: ReducedA
	// Enum: [ReducedA ReducedB Food General IncreasedStandard LinenRental Medical Construction Parking SuperReduced ReducedR Standard Leasing LeasingLow Services Zero]
	RateType string `json:"rateType,omitempty"`

	// Indicates the code of the rate type that was used to calculate this tax detail.  Use [ListRateTypesByCountry](https://developer.avalara.com/api-reference/avatax/rest/v2/methods/Definitions/ListRateTypesByCountry/) API for a full list of rate type codes.
	// Max Length: 25
	// Min Length: 0
	RateTypeCode *string `json:"rateTypeCode,omitempty"`

	// The two-or-three character ISO region code for the region where this tax detail is assigned.
	// Example: CA
	Region string `json:"region,omitempty"`

	// Number of units in this line item that were calculated to be exempt according to this rate detail in the reporting currency.
	// Example: 125
	ReportingExemptUnits float64 `json:"reportingExemptUnits,omitempty"`

	// Number of units in this line item that were calculated to be nontaxable according to this rate detail in the reporting currency.
	// Example: 2000
	ReportingNonTaxableUnits float64 `json:"reportingNonTaxableUnits,omitempty"`

	// The amount of tax for this tax detail in the reporting currency.
	// Example: 125
	ReportingTax float64 `json:"reportingTax,omitempty"`

	// The amount of tax that AvaTax calculated in the reporting currency.
	// If an override for tax amount is used, there may be a difference between the tax
	// field which applies your override, and the this amount that is calculated without override.
	// Example: 125
	ReportingTaxCalculated float64 `json:"reportingTaxCalculated,omitempty"`

	// Number of units in this line item that were calculated to be taxable according to this rate detail in the reporting currency.
	// Example: 125
	ReportingTaxableUnits float64 `json:"reportingTaxableUnits,omitempty"`

	// For Streamlined Sales Tax customers, the SST Electronic Return code under which this tax detail should be applied.
	SerCode string `json:"serCode,omitempty"`

	// The Avalara-specified signature code of the jurisdiction to which this tax detail applies.
	// Example: AGAM
	SignatureCode string `json:"signatureCode,omitempty"`

	// Indicates whether this tax detail applies to the origin or destination of the transaction.
	// Example: Mixed
	// Enum: [Mixed Destination Origin]
	Sourcing string `json:"sourcing,omitempty"`

	// The state assigned number of the jurisdiction to which this tax detail applies.
	StateAssignedNo string `json:"stateAssignedNo,omitempty"`

	// For U.S. transactions, the Federal Information Processing Standard (FIPS) code for the state where this tax detail is assigned.
	// Example: 06
	StateFIPS string `json:"stateFIPS,omitempty"`

	// The amount of tax for this tax detail.
	// Example: 62.5
	Tax float64 `json:"tax,omitempty"`

	// The type of the tax authority to which this tax will be remitted.
	// Example: 45
	TaxAuthorityTypeID int32 `json:"taxAuthorityTypeId,omitempty"`

	// The amount of tax that AvaTax calculated.
	// If an override for tax amount is used, there may be a difference between the tax
	// field which applies your override, and the this amount that is calculated without override.
	// Example: 62.5
	TaxCalculated float64 `json:"taxCalculated,omitempty"`

	// The name of the tax against which this tax amount was calculated.
	// Example: CA STATE TAX
	TaxName string `json:"taxName,omitempty"`

	// The amount of tax override that was specified for this tax line.
	// Example: 0
	TaxOverride float64 `json:"taxOverride,omitempty"`

	// The unique ID number of the tax region.
	// Example: 2127184
	TaxRegionID int32 `json:"taxRegionId,omitempty"`

	// The id of the tax subtype.
	TaxSubTypeID string `json:"taxSubTypeId,omitempty"`

	// The type of tax that was calculated.  Depends on the company's nexus settings as well as the jurisdiction's tax laws.
	// Example: Sales
	TaxType string `json:"taxType,omitempty"`

	// The id of the tax type group.
	TaxTypeGroupID string `json:"taxTypeGroupId,omitempty"`

	// The taxable amount of this tax detail.
	// Example: 1000
	TaxableAmount float64 `json:"taxableAmount,omitempty"`

	// Number of units in this line item that were calculated to be taxable according to this rate detail.
	// Example: 62.5
	TaxableUnits float64 `json:"taxableUnits,omitempty"`

	// The unique ID number of this transaction.
	// Example: 123456789
	// Read Only: true
	TransactionID int64 `json:"transactionId,omitempty"`

	// The unique ID number of the line within this transaction.
	// Example: 123456789
	// Read Only: true
	TransactionLineID int64 `json:"transactionLineId,omitempty"`

	// When calculating units, what basis of measurement did we use for calculating the units?
	UnitOfBasis string `json:"unitOfBasis,omitempty"`
}

// Validate validates this transaction line detail model
func (m *TransactionLineDetailModel) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateJurisType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateJurisdictionType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLiabilityType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNonTaxableType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRateTypeCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourcing(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TransactionLineDetailModel) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(m.Country) { // not required
		return nil
	}

	if err := validate.MinLength("country", "body", m.Country, 2); err != nil {
		return err
	}

	if err := validate.MaxLength("country", "body", m.Country, 2); err != nil {
		return err
	}

	return nil
}

var transactionLineDetailModelTypeJurisTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["STA","CTY","CIT","STJ","CNT"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		transactionLineDetailModelTypeJurisTypePropEnum = append(transactionLineDetailModelTypeJurisTypePropEnum, v)
	}
}

const (

	// TransactionLineDetailModelJurisTypeSTA captures enum value "STA"
	TransactionLineDetailModelJurisTypeSTA string = "STA"

	// TransactionLineDetailModelJurisTypeCTY captures enum value "CTY"
	TransactionLineDetailModelJurisTypeCTY string = "CTY"

	// TransactionLineDetailModelJurisTypeCIT captures enum value "CIT"
	TransactionLineDetailModelJurisTypeCIT string = "CIT"

	// TransactionLineDetailModelJurisTypeSTJ captures enum value "STJ"
	TransactionLineDetailModelJurisTypeSTJ string = "STJ"

	// TransactionLineDetailModelJurisTypeCNT captures enum value "CNT"
	TransactionLineDetailModelJurisTypeCNT string = "CNT"
)

// prop value enum
func (m *TransactionLineDetailModel) validateJurisTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, transactionLineDetailModelTypeJurisTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TransactionLineDetailModel) validateJurisType(formats strfmt.Registry) error {
	if swag.IsZero(m.JurisType) { // not required
		return nil
	}

	// value enum
	if err := m.validateJurisTypeEnum("jurisType", "body", m.JurisType); err != nil {
		return err
	}

	return nil
}

var transactionLineDetailModelTypeJurisdictionTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Country","State","County","City","Special"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		transactionLineDetailModelTypeJurisdictionTypePropEnum = append(transactionLineDetailModelTypeJurisdictionTypePropEnum, v)
	}
}

const (

	// TransactionLineDetailModelJurisdictionTypeCountry captures enum value "Country"
	TransactionLineDetailModelJurisdictionTypeCountry string = "Country"

	// TransactionLineDetailModelJurisdictionTypeState captures enum value "State"
	TransactionLineDetailModelJurisdictionTypeState string = "State"

	// TransactionLineDetailModelJurisdictionTypeCounty captures enum value "County"
	TransactionLineDetailModelJurisdictionTypeCounty string = "County"

	// TransactionLineDetailModelJurisdictionTypeCity captures enum value "City"
	TransactionLineDetailModelJurisdictionTypeCity string = "City"

	// TransactionLineDetailModelJurisdictionTypeSpecial captures enum value "Special"
	TransactionLineDetailModelJurisdictionTypeSpecial string = "Special"
)

// prop value enum
func (m *TransactionLineDetailModel) validateJurisdictionTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, transactionLineDetailModelTypeJurisdictionTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TransactionLineDetailModel) validateJurisdictionType(formats strfmt.Registry) error {
	if swag.IsZero(m.JurisdictionType) { // not required
		return nil
	}

	// value enum
	if err := m.validateJurisdictionTypeEnum("jurisdictionType", "body", m.JurisdictionType); err != nil {
		return err
	}

	return nil
}

var transactionLineDetailModelTypeLiabilityTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Seller","BuyersAgent"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		transactionLineDetailModelTypeLiabilityTypePropEnum = append(transactionLineDetailModelTypeLiabilityTypePropEnum, v)
	}
}

const (

	// TransactionLineDetailModelLiabilityTypeSeller captures enum value "Seller"
	TransactionLineDetailModelLiabilityTypeSeller string = "Seller"

	// TransactionLineDetailModelLiabilityTypeBuyersAgent captures enum value "BuyersAgent"
	TransactionLineDetailModelLiabilityTypeBuyersAgent string = "BuyersAgent"
)

// prop value enum
func (m *TransactionLineDetailModel) validateLiabilityTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, transactionLineDetailModelTypeLiabilityTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TransactionLineDetailModel) validateLiabilityType(formats strfmt.Registry) error {
	if swag.IsZero(m.LiabilityType) { // not required
		return nil
	}

	// value enum
	if err := m.validateLiabilityTypeEnum("liabilityType", "body", m.LiabilityType); err != nil {
		return err
	}

	return nil
}

var transactionLineDetailModelTypeNonTaxableTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["RateRule","RateOverrideRule","BaseRule","ExemptEntityRule","ProductTaxabilityRule","NexusRule","RateCapRule","TaxOverrideRule","FeeRule","OtherRule"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		transactionLineDetailModelTypeNonTaxableTypePropEnum = append(transactionLineDetailModelTypeNonTaxableTypePropEnum, v)
	}
}

const (

	// TransactionLineDetailModelNonTaxableTypeRateRule captures enum value "RateRule"
	TransactionLineDetailModelNonTaxableTypeRateRule string = "RateRule"

	// TransactionLineDetailModelNonTaxableTypeRateOverrideRule captures enum value "RateOverrideRule"
	TransactionLineDetailModelNonTaxableTypeRateOverrideRule string = "RateOverrideRule"

	// TransactionLineDetailModelNonTaxableTypeBaseRule captures enum value "BaseRule"
	TransactionLineDetailModelNonTaxableTypeBaseRule string = "BaseRule"

	// TransactionLineDetailModelNonTaxableTypeExemptEntityRule captures enum value "ExemptEntityRule"
	TransactionLineDetailModelNonTaxableTypeExemptEntityRule string = "ExemptEntityRule"

	// TransactionLineDetailModelNonTaxableTypeProductTaxabilityRule captures enum value "ProductTaxabilityRule"
	TransactionLineDetailModelNonTaxableTypeProductTaxabilityRule string = "ProductTaxabilityRule"

	// TransactionLineDetailModelNonTaxableTypeNexusRule captures enum value "NexusRule"
	TransactionLineDetailModelNonTaxableTypeNexusRule string = "NexusRule"

	// TransactionLineDetailModelNonTaxableTypeRateCapRule captures enum value "RateCapRule"
	TransactionLineDetailModelNonTaxableTypeRateCapRule string = "RateCapRule"

	// TransactionLineDetailModelNonTaxableTypeTaxOverrideRule captures enum value "TaxOverrideRule"
	TransactionLineDetailModelNonTaxableTypeTaxOverrideRule string = "TaxOverrideRule"

	// TransactionLineDetailModelNonTaxableTypeFeeRule captures enum value "FeeRule"
	TransactionLineDetailModelNonTaxableTypeFeeRule string = "FeeRule"

	// TransactionLineDetailModelNonTaxableTypeOtherRule captures enum value "OtherRule"
	TransactionLineDetailModelNonTaxableTypeOtherRule string = "OtherRule"
)

// prop value enum
func (m *TransactionLineDetailModel) validateNonTaxableTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, transactionLineDetailModelTypeNonTaxableTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TransactionLineDetailModel) validateNonTaxableType(formats strfmt.Registry) error {
	if swag.IsZero(m.NonTaxableType) { // not required
		return nil
	}

	// value enum
	if err := m.validateNonTaxableTypeEnum("nonTaxableType", "body", m.NonTaxableType); err != nil {
		return err
	}

	return nil
}

var transactionLineDetailModelTypeRateTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ReducedA","ReducedB","Food","General","IncreasedStandard","LinenRental","Medical","Construction","Parking","SuperReduced","ReducedR","Standard","Leasing","LeasingLow","Services","Zero"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		transactionLineDetailModelTypeRateTypePropEnum = append(transactionLineDetailModelTypeRateTypePropEnum, v)
	}
}

const (

	// TransactionLineDetailModelRateTypeReducedA captures enum value "ReducedA"
	TransactionLineDetailModelRateTypeReducedA string = "ReducedA"

	// TransactionLineDetailModelRateTypeReducedB captures enum value "ReducedB"
	TransactionLineDetailModelRateTypeReducedB string = "ReducedB"

	// TransactionLineDetailModelRateTypeFood captures enum value "Food"
	TransactionLineDetailModelRateTypeFood string = "Food"

	// TransactionLineDetailModelRateTypeGeneral captures enum value "General"
	TransactionLineDetailModelRateTypeGeneral string = "General"

	// TransactionLineDetailModelRateTypeIncreasedStandard captures enum value "IncreasedStandard"
	TransactionLineDetailModelRateTypeIncreasedStandard string = "IncreasedStandard"

	// TransactionLineDetailModelRateTypeLinenRental captures enum value "LinenRental"
	TransactionLineDetailModelRateTypeLinenRental string = "LinenRental"

	// TransactionLineDetailModelRateTypeMedical captures enum value "Medical"
	TransactionLineDetailModelRateTypeMedical string = "Medical"

	// TransactionLineDetailModelRateTypeConstruction captures enum value "Construction"
	TransactionLineDetailModelRateTypeConstruction string = "Construction"

	// TransactionLineDetailModelRateTypeParking captures enum value "Parking"
	TransactionLineDetailModelRateTypeParking string = "Parking"

	// TransactionLineDetailModelRateTypeSuperReduced captures enum value "SuperReduced"
	TransactionLineDetailModelRateTypeSuperReduced string = "SuperReduced"

	// TransactionLineDetailModelRateTypeReducedR captures enum value "ReducedR"
	TransactionLineDetailModelRateTypeReducedR string = "ReducedR"

	// TransactionLineDetailModelRateTypeStandard captures enum value "Standard"
	TransactionLineDetailModelRateTypeStandard string = "Standard"

	// TransactionLineDetailModelRateTypeLeasing captures enum value "Leasing"
	TransactionLineDetailModelRateTypeLeasing string = "Leasing"

	// TransactionLineDetailModelRateTypeLeasingLow captures enum value "LeasingLow"
	TransactionLineDetailModelRateTypeLeasingLow string = "LeasingLow"

	// TransactionLineDetailModelRateTypeServices captures enum value "Services"
	TransactionLineDetailModelRateTypeServices string = "Services"

	// TransactionLineDetailModelRateTypeZero captures enum value "Zero"
	TransactionLineDetailModelRateTypeZero string = "Zero"
)

// prop value enum
func (m *TransactionLineDetailModel) validateRateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, transactionLineDetailModelTypeRateTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TransactionLineDetailModel) validateRateType(formats strfmt.Registry) error {
	if swag.IsZero(m.RateType) { // not required
		return nil
	}

	// value enum
	if err := m.validateRateTypeEnum("rateType", "body", m.RateType); err != nil {
		return err
	}

	return nil
}

func (m *TransactionLineDetailModel) validateRateTypeCode(formats strfmt.Registry) error {
	if swag.IsZero(m.RateTypeCode) { // not required
		return nil
	}

	if err := validate.MinLength("rateTypeCode", "body", *m.RateTypeCode, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("rateTypeCode", "body", *m.RateTypeCode, 25); err != nil {
		return err
	}

	return nil
}

var transactionLineDetailModelTypeSourcingPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Mixed","Destination","Origin"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		transactionLineDetailModelTypeSourcingPropEnum = append(transactionLineDetailModelTypeSourcingPropEnum, v)
	}
}

const (

	// TransactionLineDetailModelSourcingMixed captures enum value "Mixed"
	TransactionLineDetailModelSourcingMixed string = "Mixed"

	// TransactionLineDetailModelSourcingDestination captures enum value "Destination"
	TransactionLineDetailModelSourcingDestination string = "Destination"

	// TransactionLineDetailModelSourcingOrigin captures enum value "Origin"
	TransactionLineDetailModelSourcingOrigin string = "Origin"
)

// prop value enum
func (m *TransactionLineDetailModel) validateSourcingEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, transactionLineDetailModelTypeSourcingPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TransactionLineDetailModel) validateSourcing(formats strfmt.Registry) error {
	if swag.IsZero(m.Sourcing) { // not required
		return nil
	}

	// value enum
	if err := m.validateSourcingEnum("sourcing", "body", m.Sourcing); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this transaction line detail model based on the context it is used
func (m *TransactionLineDetailModel) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTransactionID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTransactionLineID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TransactionLineDetailModel) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "id", "body", int64(m.ID)); err != nil {
		return err
	}

	return nil
}

func (m *TransactionLineDetailModel) contextValidateTransactionID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "transactionId", "body", int64(m.TransactionID)); err != nil {
		return err
	}

	return nil
}

func (m *TransactionLineDetailModel) contextValidateTransactionLineID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "transactionLineId", "body", int64(m.TransactionLineID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TransactionLineDetailModel) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TransactionLineDetailModel) UnmarshalBinary(b []byte) error {
	var res TransactionLineDetailModel
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
