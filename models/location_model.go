// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// LocationModel A location where this company does business.
// Some jurisdictions may require you to list all locations where your company does business.
// Example: {"addressCategoryId":"MainOffice","addressTypeId":"Location","city":"Irvine","companyId":12345,"country":"US","county":"Orange","dbaName":"Bob's Artisan Pottery","description":"Bob's Artisan Pottery","id":56789,"isDefault":true,"isMarketplaceOutsideUsa":false,"isRegistered":true,"line1":"2000 Main Street","locationCode":"DEFAULT","outletName":"Main Office","postalCode":"92614","region":"CA","registeredDate":"2015-01-01T00:00:00","settings":[{"questionId":17,"value":"abcdefghij"}]}
//
// swagger:model LocationModel
type LocationModel struct {

	// Indicates the type of place of business represented by this location.
	// Example: Storefront
	// Required: true
	// Enum: [Storefront MainOffice Warehouse Salesperson Other SellerRemitsTax MarketplaceRemitsTax NonPhysical]
	AddressCategoryID *string `json:"addressCategoryId"`

	// Indicates whether this location is a physical place of business or a temporary salesperson location.
	// Example: Location
	// Required: true
	// Enum: [Location Salesperson Marketplace]
	AddressTypeID *string `json:"addressTypeId"`

	// The city of the physical address of this location.
	// Example: Irvine
	// Max Length: 50
	// Min Length: 0
	City *string `json:"city,omitempty"`

	// The unique ID number of the company that operates at this location.
	// Example: 12345
	// Read Only: true
	CompanyID int32 `json:"companyId,omitempty"`

	// Name or ISO 3166 code identifying the country of the physical address of this location.
	//
	// This field supports many different country identifiers:
	//  * Two character ISO 3166 codes
	//  * Three character ISO 3166 codes
	//  * Fully spelled out names of the country in ISO supported languages
	//  * Common alternative spellings for many countries
	//
	// For a full list of all supported codes and names, please see the Definitions API `ListCountries`.
	// Example: US
	// Required: true
	Country *string `json:"country"`

	// The county name of the physical address of this location.  Not required.
	// Example: Orange
	// Max Length: 50
	// Min Length: 0
	County *string `json:"county,omitempty"`

	// The date when this record was created.
	// Read Only: true
	// Format: date-time
	CreatedDate strfmt.DateTime `json:"createdDate,omitempty"`

	// The User ID of the user who created this record.
	// Read Only: true
	CreatedUserID int32 `json:"createdUserId,omitempty"`

	// If this location has a different business name from its legal entity name, specify the "Doing Business As" name for this location.
	// Example: Bob's Artisan Pottery
	// Max Length: 100
	// Min Length: 0
	DbaName *string `json:"dbaName,omitempty"`

	// A friendly name for this location.
	// Example: Bob's Artisan Pottery
	// Max Length: 255
	// Min Length: 0
	Description *string `json:"description,omitempty"`

	// The date when this location was opened for business, or null if not known.
	// Format: date
	EffectiveDate strfmt.Date `json:"effectiveDate,omitempty"`

	// If this place of business has closed, the date when this location closed business.
	// Format: date
	EndDate strfmt.Date `json:"endDate,omitempty"`

	// The unique ID number of this location.
	// Example: 56789
	// Required: true
	ID *int32 `json:"id"`

	// Set this flag to true to indicate that this is the default location for this company.
	// Example: true
	IsDefault bool `json:"isDefault,omitempty"`

	// Indicates whether the Marketplace is outside or in USA
	// Example: false
	IsMarketplaceOutsideUsa bool `json:"isMarketplaceOutsideUsa,omitempty"`

	// Set this flag to true to indicate that this location has been registered with a tax authority.
	// Example: true
	IsRegistered bool `json:"isRegistered,omitempty"`

	// The most recent date when a transaction was processed for this location.  Set by AvaTax.
	// Read Only: true
	// Format: date-time
	LastTransactionDate strfmt.DateTime `json:"lastTransactionDate,omitempty"`

	// The first line of the physical address of this location.
	// Example: 2000 Main Street
	// Required: true
	// Max Length: 50
	// Min Length: 0
	Line1 *string `json:"line1"`

	// The second line of the physical address of this location.
	// Max Length: 50
	// Min Length: 0
	Line2 *string `json:"line2,omitempty"`

	// The third line of the physical address of this location.
	// Max Length: 50
	// Min Length: 0
	Line3 *string `json:"line3,omitempty"`

	// A code that identifies this location.  Must be unique within your company.
	// Example: DEFAULT
	// Required: true
	// Max Length: 50
	// Min Length: 0
	LocationCode *string `json:"locationCode"`

	// The date/time when this record was last modified.
	// Read Only: true
	// Format: date-time
	ModifiedDate strfmt.DateTime `json:"modifiedDate,omitempty"`

	// The user ID of the user who last modified this record.
	// Read Only: true
	ModifiedUserID int32 `json:"modifiedUserId,omitempty"`

	// A friendly name for this location.
	// Example: Main Office
	// Max Length: 100
	// Min Length: 0
	OutletName *string `json:"outletName,omitempty"`

	// List of location parameters.
	// Read Only: true
	Parameters []*LocationParameterModel `json:"parameters"`

	// The postal code or zip code of the physical address of this location.
	// Example: 92614
	// Required: true
	// Max Length: 10
	// Min Length: 0
	PostalCode *string `json:"postalCode"`

	// Name or ISO 3166 code identifying the region within the country of the physical address of this location.
	//
	// This field supports many different region identifiers:
	//  * Two and three character ISO 3166 region codes
	//  * Fully spelled out names of the region in ISO supported languages
	//  * Common alternative spellings for many regions
	//
	// For a full list of all supported codes and names, please see the Definitions API `ListRegions`.
	// Example: CA
	Region string `json:"region,omitempty"`

	// The date when this location was registered with a tax authority.  Not required.
	// Example: 2015-01-01T00:00:00
	// Format: date-time
	RegisteredDate strfmt.DateTime `json:"registeredDate,omitempty"`

	// Extra information required by certain jurisdictions for filing.
	// For a list of settings recognized by Avalara, query the endpoint "/api/v2/definitions/locationquestions".
	// To determine the list of settings required for this location, query the endpoint "/api/v2/companies/(id)/locations/(id)/validate".
	// Example: [{"questionId":17,"value":"abcdefghij"}]
	Settings []*LocationSettingModel `json:"settings"`
}

// Validate validates this location model
func (m *LocationModel) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAddressCategoryID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAddressTypeID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCounty(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDbaName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEffectiveDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEndDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastTransactionDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLine1(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLine2(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLine3(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocationCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateModifiedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOutletName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateParameters(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRegisteredDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSettings(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var locationModelTypeAddressCategoryIDPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Storefront","MainOffice","Warehouse","Salesperson","Other","SellerRemitsTax","MarketplaceRemitsTax","NonPhysical"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		locationModelTypeAddressCategoryIDPropEnum = append(locationModelTypeAddressCategoryIDPropEnum, v)
	}
}

const (

	// LocationModelAddressCategoryIDStorefront captures enum value "Storefront"
	LocationModelAddressCategoryIDStorefront string = "Storefront"

	// LocationModelAddressCategoryIDMainOffice captures enum value "MainOffice"
	LocationModelAddressCategoryIDMainOffice string = "MainOffice"

	// LocationModelAddressCategoryIDWarehouse captures enum value "Warehouse"
	LocationModelAddressCategoryIDWarehouse string = "Warehouse"

	// LocationModelAddressCategoryIDSalesperson captures enum value "Salesperson"
	LocationModelAddressCategoryIDSalesperson string = "Salesperson"

	// LocationModelAddressCategoryIDOther captures enum value "Other"
	LocationModelAddressCategoryIDOther string = "Other"

	// LocationModelAddressCategoryIDSellerRemitsTax captures enum value "SellerRemitsTax"
	LocationModelAddressCategoryIDSellerRemitsTax string = "SellerRemitsTax"

	// LocationModelAddressCategoryIDMarketplaceRemitsTax captures enum value "MarketplaceRemitsTax"
	LocationModelAddressCategoryIDMarketplaceRemitsTax string = "MarketplaceRemitsTax"

	// LocationModelAddressCategoryIDNonPhysical captures enum value "NonPhysical"
	LocationModelAddressCategoryIDNonPhysical string = "NonPhysical"
)

// prop value enum
func (m *LocationModel) validateAddressCategoryIDEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, locationModelTypeAddressCategoryIDPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *LocationModel) validateAddressCategoryID(formats strfmt.Registry) error {

	if err := validate.Required("addressCategoryId", "body", m.AddressCategoryID); err != nil {
		return err
	}

	// value enum
	if err := m.validateAddressCategoryIDEnum("addressCategoryId", "body", *m.AddressCategoryID); err != nil {
		return err
	}

	return nil
}

var locationModelTypeAddressTypeIDPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Location","Salesperson","Marketplace"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		locationModelTypeAddressTypeIDPropEnum = append(locationModelTypeAddressTypeIDPropEnum, v)
	}
}

const (

	// LocationModelAddressTypeIDLocation captures enum value "Location"
	LocationModelAddressTypeIDLocation string = "Location"

	// LocationModelAddressTypeIDSalesperson captures enum value "Salesperson"
	LocationModelAddressTypeIDSalesperson string = "Salesperson"

	// LocationModelAddressTypeIDMarketplace captures enum value "Marketplace"
	LocationModelAddressTypeIDMarketplace string = "Marketplace"
)

// prop value enum
func (m *LocationModel) validateAddressTypeIDEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, locationModelTypeAddressTypeIDPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *LocationModel) validateAddressTypeID(formats strfmt.Registry) error {

	if err := validate.Required("addressTypeId", "body", m.AddressTypeID); err != nil {
		return err
	}

	// value enum
	if err := m.validateAddressTypeIDEnum("addressTypeId", "body", *m.AddressTypeID); err != nil {
		return err
	}

	return nil
}

func (m *LocationModel) validateCity(formats strfmt.Registry) error {
	if swag.IsZero(m.City) { // not required
		return nil
	}

	if err := validate.MinLength("city", "body", *m.City, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("city", "body", *m.City, 50); err != nil {
		return err
	}

	return nil
}

func (m *LocationModel) validateCountry(formats strfmt.Registry) error {

	if err := validate.Required("country", "body", m.Country); err != nil {
		return err
	}

	return nil
}

func (m *LocationModel) validateCounty(formats strfmt.Registry) error {
	if swag.IsZero(m.County) { // not required
		return nil
	}

	if err := validate.MinLength("county", "body", *m.County, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("county", "body", *m.County, 50); err != nil {
		return err
	}

	return nil
}

func (m *LocationModel) validateCreatedDate(formats strfmt.Registry) error {
	if swag.IsZero(m.CreatedDate) { // not required
		return nil
	}

	if err := validate.FormatOf("createdDate", "body", "date-time", m.CreatedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *LocationModel) validateDbaName(formats strfmt.Registry) error {
	if swag.IsZero(m.DbaName) { // not required
		return nil
	}

	if err := validate.MinLength("dbaName", "body", *m.DbaName, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("dbaName", "body", *m.DbaName, 100); err != nil {
		return err
	}

	return nil
}

func (m *LocationModel) validateDescription(formats strfmt.Registry) error {
	if swag.IsZero(m.Description) { // not required
		return nil
	}

	if err := validate.MinLength("description", "body", *m.Description, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("description", "body", *m.Description, 255); err != nil {
		return err
	}

	return nil
}

func (m *LocationModel) validateEffectiveDate(formats strfmt.Registry) error {
	if swag.IsZero(m.EffectiveDate) { // not required
		return nil
	}

	if err := validate.FormatOf("effectiveDate", "body", "date", m.EffectiveDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *LocationModel) validateEndDate(formats strfmt.Registry) error {
	if swag.IsZero(m.EndDate) { // not required
		return nil
	}

	if err := validate.FormatOf("endDate", "body", "date", m.EndDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *LocationModel) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *LocationModel) validateLastTransactionDate(formats strfmt.Registry) error {
	if swag.IsZero(m.LastTransactionDate) { // not required
		return nil
	}

	if err := validate.FormatOf("lastTransactionDate", "body", "date-time", m.LastTransactionDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *LocationModel) validateLine1(formats strfmt.Registry) error {

	if err := validate.Required("line1", "body", m.Line1); err != nil {
		return err
	}

	if err := validate.MinLength("line1", "body", *m.Line1, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("line1", "body", *m.Line1, 50); err != nil {
		return err
	}

	return nil
}

func (m *LocationModel) validateLine2(formats strfmt.Registry) error {
	if swag.IsZero(m.Line2) { // not required
		return nil
	}

	if err := validate.MinLength("line2", "body", *m.Line2, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("line2", "body", *m.Line2, 50); err != nil {
		return err
	}

	return nil
}

func (m *LocationModel) validateLine3(formats strfmt.Registry) error {
	if swag.IsZero(m.Line3) { // not required
		return nil
	}

	if err := validate.MinLength("line3", "body", *m.Line3, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("line3", "body", *m.Line3, 50); err != nil {
		return err
	}

	return nil
}

func (m *LocationModel) validateLocationCode(formats strfmt.Registry) error {

	if err := validate.Required("locationCode", "body", m.LocationCode); err != nil {
		return err
	}

	if err := validate.MinLength("locationCode", "body", *m.LocationCode, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("locationCode", "body", *m.LocationCode, 50); err != nil {
		return err
	}

	return nil
}

func (m *LocationModel) validateModifiedDate(formats strfmt.Registry) error {
	if swag.IsZero(m.ModifiedDate) { // not required
		return nil
	}

	if err := validate.FormatOf("modifiedDate", "body", "date-time", m.ModifiedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *LocationModel) validateOutletName(formats strfmt.Registry) error {
	if swag.IsZero(m.OutletName) { // not required
		return nil
	}

	if err := validate.MinLength("outletName", "body", *m.OutletName, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("outletName", "body", *m.OutletName, 100); err != nil {
		return err
	}

	return nil
}

func (m *LocationModel) validateParameters(formats strfmt.Registry) error {
	if swag.IsZero(m.Parameters) { // not required
		return nil
	}

	for i := 0; i < len(m.Parameters); i++ {
		if swag.IsZero(m.Parameters[i]) { // not required
			continue
		}

		if m.Parameters[i] != nil {
			if err := m.Parameters[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("parameters" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("parameters" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *LocationModel) validatePostalCode(formats strfmt.Registry) error {

	if err := validate.Required("postalCode", "body", m.PostalCode); err != nil {
		return err
	}

	if err := validate.MinLength("postalCode", "body", *m.PostalCode, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("postalCode", "body", *m.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

func (m *LocationModel) validateRegisteredDate(formats strfmt.Registry) error {
	if swag.IsZero(m.RegisteredDate) { // not required
		return nil
	}

	if err := validate.FormatOf("registeredDate", "body", "date-time", m.RegisteredDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *LocationModel) validateSettings(formats strfmt.Registry) error {
	if swag.IsZero(m.Settings) { // not required
		return nil
	}

	for i := 0; i < len(m.Settings); i++ {
		if swag.IsZero(m.Settings[i]) { // not required
			continue
		}

		if m.Settings[i] != nil {
			if err := m.Settings[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("settings" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("settings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this location model based on the context it is used
func (m *LocationModel) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCompanyID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCreatedDate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCreatedUserID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLastTransactionDate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateModifiedDate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateModifiedUserID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateParameters(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSettings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LocationModel) contextValidateCompanyID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "companyId", "body", int32(m.CompanyID)); err != nil {
		return err
	}

	return nil
}

func (m *LocationModel) contextValidateCreatedDate(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "createdDate", "body", strfmt.DateTime(m.CreatedDate)); err != nil {
		return err
	}

	return nil
}

func (m *LocationModel) contextValidateCreatedUserID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "createdUserId", "body", int32(m.CreatedUserID)); err != nil {
		return err
	}

	return nil
}

func (m *LocationModel) contextValidateLastTransactionDate(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "lastTransactionDate", "body", strfmt.DateTime(m.LastTransactionDate)); err != nil {
		return err
	}

	return nil
}

func (m *LocationModel) contextValidateModifiedDate(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "modifiedDate", "body", strfmt.DateTime(m.ModifiedDate)); err != nil {
		return err
	}

	return nil
}

func (m *LocationModel) contextValidateModifiedUserID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "modifiedUserId", "body", int32(m.ModifiedUserID)); err != nil {
		return err
	}

	return nil
}

func (m *LocationModel) contextValidateParameters(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "parameters", "body", []*LocationParameterModel(m.Parameters)); err != nil {
		return err
	}

	for i := 0; i < len(m.Parameters); i++ {

		if m.Parameters[i] != nil {
			if err := m.Parameters[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("parameters" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("parameters" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *LocationModel) contextValidateSettings(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Settings); i++ {

		if m.Settings[i] != nil {
			if err := m.Settings[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("settings" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("settings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *LocationModel) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LocationModel) UnmarshalBinary(b []byte) error {
	var res LocationModel
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
