// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// TransactionModel This object represents a single transaction; for example, a sales invoice or purchase order.
// Example: {"addresses":[{"boundaryLevel":"Address","city":"Bainbridge Island","country":"US","id":0,"line1":"100 Ravine Lane Northeast #220","postalCode":"98110","region":"WA","taxRegionId":0,"transactionId":0}],"adjustmentDescription":"","adjustmentReason":"NotAdjusted","code":"594747b8-02a4-49ac-afae-3a6ebe47d2cb","companyId":12345,"country":"US","currencyCode":"USD","customerCode":"ABC","customerVendorCode":"ABC","date":"2021-12-25","description":"Yarn","destinationAddressId":123456789,"entityUseCode":"","exchangeRate":2,"exchangeRateCurrencyCode":"USD","exchangeRateEffectiveDate":"2021-12-25","exemptNo":"","id":123456789,"isSellerImporterOfRecord":false,"lines":[{"boundaryOverrideId":0,"description":"Yarn","destinationAddressId":12345,"details":[{"addressId":12345,"country":"US","exemptAmount":0,"exemptReasonId":4,"exemptUnits":62.5,"id":123456789,"inState":false,"jurisCode":"06","jurisName":"CALIFORNIA","jurisType":"STA","jurisdictionId":5000531,"nonTaxableAmount":0,"nonTaxableRuleId":0,"nonTaxableType":"BaseRule","nonTaxableUnits":1000,"rate":0.0625,"rateRuleId":1321915,"rateSourceId":3,"rateType":"General","region":"CA","reportingExemptUnits":125,"reportingNonTaxableUnits":2000,"reportingTax":125,"reportingTaxCalculated":125,"reportingTaxableUnits":125,"serCode":"","signatureCode":"AGAM","sourcing":"Destination","stateAssignedNo":"","stateFIPS":"06","tax":62.5,"taxAuthorityTypeId":45,"taxCalculated":62.5,"taxName":"CA STATE TAX","taxOverride":0,"taxRegionId":2127184,"taxType":"Sales","taxableAmount":1000,"taxableUnits":62.5,"transactionId":123456789,"transactionLineId":123456789}],"discountAmount":100,"discountTypeId":0,"entityUseCode":"","exemptAmount":0,"exemptCertId":0,"exemptNo":"","id":123456789,"isItemTaxable":true,"isSSTP":false,"itemCode":"116292","lineAmount":1000,"lineNumber":"1","originAddressId":123456789,"quantity":1,"ref1":"Note: Deliver to Bob","reportingDate":"2021-12-25","revAccount":"","sourcing":"Destination","tax":62.5,"taxCalculated":62.5,"taxCode":"PS081282","taxDate":"2021-12-25","taxEngine":"","taxIncluded":false,"taxOverrideAmount":0,"taxOverrideReason":"","taxOverrideType":"None","taxableAmount":1000,"transactionId":123456789,"vatNumberTypeId":0}],"locationCode":"DEFAULT","locked":false,"originAddressId":123456789,"reconciled":true,"region":"CA","salespersonCode":"DEF","status":"Committed","taxDate":"2021-12-25T00:00:00+00:00","taxDetailsByTaxType":[{"taxType":"SalesAndUse","totalExempt":0.05,"totalNonTaxable":0,"totalTax":0.625,"totalTaxable":100}],"taxOverrideAmount":0,"taxOverrideReason":"","taxOverrideType":"None","totalAmount":1000,"totalDiscount":0,"totalExempt":0,"totalTax":62.5,"totalTaxCalculated":62.5,"totalTaxable":1000,"type":"SalesInvoice","version":0}
//
// swagger:model TransactionModel
type TransactionModel struct {

	// A list of line items in this transaction.  To fetch this list, add the query string `?$include=Addresses` to your URL.
	//
	// For more information about transaction addresses, please see [Using Address Types](https://developer.avalara.com/avatax/dev-guide/customizing-transaction/address-types/)
	// in the AvaTax Developer Guide.
	// Example: [{"boundaryLevel":"Address","city":"Bainbridge Island","country":"US","id":0,"line1":"100 Ravine Lane Northeast #220","postalCode":"98110","region":"WA","taxRegionId":0,"transactionId":0}]
	Addresses []*TransactionAddressModel `json:"addresses"`

	// If this transaction was adjusted, indicates a description of the reason why the transaction was adjusted.
	AdjustmentDescription string `json:"adjustmentDescription,omitempty"`

	// If this transaction was adjusted, indicates the unique ID number of the reason why the transaction was adjusted.
	// Example: NotAdjusted
	// Enum: [NotAdjusted SourcingIssue ReconciledWithGeneralLedger ExemptCertApplied PriceAdjusted ProductReturned ProductExchanged BadDebt Other Offline]
	AdjustmentReason string `json:"adjustmentReason,omitempty"`

	// If this transaction was created as part of a batch, this code indicates which batch.
	BatchCode string `json:"batchCode,omitempty"`

	// VAT business identification number used for this transaction.
	BusinessIdentificationNo string `json:"businessIdentificationNo,omitempty"`

	// A unique customer-provided code identifying this transaction.
	// Example: 594747b8-02a4-49ac-afae-3a6ebe47d2cb
	// Read Only: true
	Code string `json:"code,omitempty"`

	// The unique ID number of the company that recorded this transaction.
	// Example: 12345
	CompanyID int32 `json:"companyId,omitempty"`

	// The two-character ISO 3166 code of the country for this transaction.
	// Example: US
	// Max Length: 2
	// Min Length: 2
	Country string `json:"country,omitempty"`

	// The three-character ISO 4217 currency code that was used for payment for this transaction.
	// Example: USD
	CurrencyCode string `json:"currencyCode,omitempty"`

	// Unique code identifying the customer that requested this transaction.
	//
	// When you specify a `customerCode`, AvaTax will look to see if a customer exists with this code in the exemption certificate system.
	// If that customer exists, and if that customer has uploaded an exemption certificate that applies to this transaction, the relevant
	// parts of this transaction that can use the exemption certificate will be treated as exempt.
	// Example: ABC
	CustomerCode string `json:"customerCode,omitempty"`

	// The name of the supplier / exporter / seller.
	// For sales doctype this will be the name of your own company for which you are reporting.
	// For purchases doctype this will be the name of the supplier you have purchased from.
	CustomerSupplierName string `json:"customerSupplierName,omitempty"`

	// DEPRECATED - Date: 10/16/2017, Version: 17.11, Message: Please use entityUseCode instead.
	// The customer usage type for this transaction.  Customer usage types often affect exemption or taxability rules.
	CustomerUsageType string `json:"customerUsageType,omitempty"`

	// DEPRECATED - Date: 3/1/2018, Version: 18.3, Message: Please use `customerCode`
	// This field has been renamed to `customerCode` to match documentation for other APIs related to exemption customers.
	// Example: ABC
	CustomerVendorCode string `json:"customerVendorCode,omitempty"`

	// The Id of the datasource from which this transaction originated.
	// This value will be overridden by the system to take the datasource Id from the call header.
	DataSourceID int32 `json:"dataSourceId,omitempty"`

	// The date on which this transaction occurred.
	// Example: 2021-12-25T00:00:00+00:00
	// Format: date
	Date strfmt.Date `json:"date,omitempty"`

	// The Delivery Terms is a field used in conjunction with Importer of Record to influence whether AvaTax includes Import Duty and Tax values in the transaction totals or not.
	// Delivered at Place (DAP) and Delivered Duty Paid (DDP) are two delivery terms that  indicate that Import Duty and Tax should be included in the transaction total.
	// This field is also used for reports.
	// This field is used for future feature support. This field is not currently in use.
	// Example: DAP
	// Enum: [DAP DDP]
	DeliveryTerms string `json:"deliveryTerms,omitempty"`

	// Description of this transaction.  Field permits unicode values.
	// Example: Yarn
	Description string `json:"description,omitempty"`

	// The unique ID number of the destination address for this transaction.
	// Example: 123456789
	DestinationAddressID int64 `json:"destinationAddressId,omitempty"`

	// Email address associated with this transaction.
	Email string `json:"email,omitempty"`

	// The entity use code for this transaction.  Entity use codes often affect exemption or taxability rules.
	EntityUseCode string `json:"entityUseCode,omitempty"`

	// If this transaction included foreign currency exchange, this is the exchange rate that was used.
	// Example: 2
	ExchangeRate float64 `json:"exchangeRate,omitempty"`

	// The three-character ISO 4217 exchange rate currency code that was used for payment for this transaction.
	// Example: USD
	ExchangeRateCurrencyCode string `json:"exchangeRateCurrencyCode,omitempty"`

	// If this transaction included foreign currency exchange, this is the date as of which the exchange rate was calculated.
	// Example: 2021-12-25T00:00:00+00:00
	// Format: date
	ExchangeRateEffectiveDate strfmt.Date `json:"exchangeRateEffectiveDate,omitempty"`

	// The customer Tax Id Number (tax_number) associated with a certificate - Sales tax calculation requests first determine if there is an applicable
	// ECMS entry available, and will utilize it for exemption processing. If no applicable ECMS entry is available, the AvaTax service
	// will determine if an Exemption Number field is populated or an Entity/Use Code is included in the sales tax calculation request,
	// and will perform exemption processing using either of those two options.
	ExemptNo string `json:"exemptNo,omitempty"`

	// The unique ID number of this transaction.
	// Example: 123456789
	// Read Only: true
	ID int64 `json:"id,omitempty"`

	// Invoice messages associated with this document. Currently, this stores legally-required VAT messages.
	InvoiceMessages []*InvoiceMessageModel `json:"invoiceMessages"`

	// By default, the value is null, when the value is null, the value can be set at nexus level and used.
	// If the value is not null, it will override the value at nexus level.
	//
	// If true, this seller was considered the importer of record of a product shipped internationally.
	//
	// If this transaction is not an international transaction, this field may be left blank.
	//
	// The "importer of record" is liable to pay customs and import duties for products shipped internationally.  If
	// you specify that the seller is the importer of record, then estimates of customs and import duties will be added
	// as tax details to the transaction.  Otherwise, the buyer is considered the importer of record, and customs
	// and import duties will not be added to the tax details for this transaction.
	// Example: false
	IsSellerImporterOfRecord bool `json:"isSellerImporterOfRecord,omitempty"`

	// A list of line items in this transaction.  To fetch this list, add the query string `?$include=Lines` or `?$include=Details` to your URL.
	// Example: [{"boundaryOverrideId":0,"description":"Yarn","destinationAddressId":12345,"details":[{"addressId":12345,"country":"US","exemptAmount":0,"exemptReasonId":4,"exemptUnits":62.5,"id":123456789,"inState":false,"jurisCode":"06","jurisName":"CALIFORNIA","jurisType":"STA","jurisdictionId":5000531,"nonTaxableAmount":0,"nonTaxableRuleId":0,"nonTaxableType":"BaseRule","nonTaxableUnits":1000,"rate":0.0625,"rateRuleId":1321915,"rateSourceId":3,"rateType":"General","region":"CA","reportingExemptUnits":125,"reportingNonTaxableUnits":2000,"reportingTax":125,"reportingTaxCalculated":125,"reportingTaxableUnits":125,"serCode":"","signatureCode":"AGAM","sourcing":"Destination","stateAssignedNo":"","stateFIPS":"06","tax":62.5,"taxAuthorityTypeId":45,"taxCalculated":62.5,"taxName":"CA STATE TAX","taxOverride":0,"taxRegionId":2127184,"taxType":"Sales","taxableAmount":1000,"taxableUnits":62.5,"transactionId":123456789,"transactionLineId":123456789}],"discountAmount":100,"discountTypeId":0,"entityUseCode":"","exemptAmount":0,"exemptCertId":0,"exemptNo":"","id":123456789,"isItemTaxable":true,"isSSTP":false,"itemCode":"116292","lineAmount":1000,"lineNumber":"1","originAddressId":123456789,"quantity":1,"ref1":"Note: Deliver to Bob","reportingDate":"2021-12-25","revAccount":"","sourcing":"Destination","tax":62.5,"taxCalculated":62.5,"taxCode":"PS081282","taxDate":"2021-12-25","taxEngine":"","taxIncluded":false,"taxOverrideAmount":0,"taxOverrideReason":"","taxOverrideType":"None","taxableAmount":1000,"transactionId":123456789,"vatNumberTypeId":0}]
	Lines []*TransactionLineModel `json:"lines"`

	// DEPRECATED - Date: 3/1/2018, Version: 18.3, Message: In order to ensure consistency of field names, Please use reportingLocationCode instead.
	// This field has been replaced by the reportingLocationCode field
	// Example: DEFAULT
	LocationCode string `json:"locationCode,omitempty"`

	// A list of location types in this transaction.  To fetch this list, add the query string `?$include=Addresses` to your URL.
	LocationTypes []*TransactionLocationTypeModel `json:"locationTypes"`

	// If this transaction has been reported to a tax authority, this transaction is considered locked and may not be adjusted after reporting.
	// Example: false
	Locked bool `json:"locked,omitempty"`

	// List of informational and warning messages regarding this API call.  These messages are only relevant to the current API call.
	Messages []*AvaTaxMessage `json:"messages"`

	// The date/time when this record was last modified.
	// Read Only: true
	// Format: date-time
	ModifiedDate strfmt.DateTime `json:"modifiedDate,omitempty"`

	// The user ID of the user who last modified this record.
	// Read Only: true
	ModifiedUserID int32 `json:"modifiedUserId,omitempty"`

	// The unique ID number of the origin address for this transaction.
	// Example: 123456789
	OriginAddressID int64 `json:"originAddressId,omitempty"`

	// Contains a list of extra parameters that were set when the transaction was created.
	Parameters []*TransactionParameterModel `json:"parameters"`

	// DEPRECATED - Date: 07/25/2018, Version: 18.7, Message: This field is deprecated and will return null till its removed.
	// The date when payment was made on this transaction.  By default, this should be the same as the date of the transaction.
	// Format: date
	PaymentDate strfmt.Date `json:"paymentDate,omitempty"`

	// The customer-supplied purchase order number of this transaction.
	PurchaseOrderNo string `json:"purchaseOrderNo,omitempty"`

	// If this transaction has been reconciled against the company's ledger, this value is set to true.
	// Example: true
	Reconciled bool `json:"reconciled,omitempty"`

	// A user-defined reference code for this transaction.
	ReferenceCode string `json:"referenceCode,omitempty"`

	// The two-or-three character ISO region code of the region for this transaction.
	// Example: CA
	Region string `json:"region,omitempty"`

	// For customers who use [location-based tax reporting](https://developer.avalara.com/avatax/dev-guide/locations/location-based-reporting),
	// this field controls how this transaction will be filed for multi-location tax filings.
	//
	// If you specify a non-null value for this field, AvaTax will ensure that this transaction is reported on the tax return associated
	// with the [LocationModel](https://developer.avalara.com/api-reference/avatax/rest/v2/models/LocationModel/) identified by this code.
	//
	// This field does not affect any addresses for the transaction.  It only controls the tax filing behavior of this transaction.
	//
	// If you are looking for information about how to set up addresses for a transaction, please see [Using Address Types](https://developer.avalara.com/avatax/dev-guide/customizing-transaction/address-types/)
	// in the AvaTax Developer Guide.
	ReportingLocationCode string `json:"reportingLocationCode,omitempty"`

	// The salesperson who provided this transaction.  Not required.
	// Example: DEF
	SalespersonCode string `json:"salespersonCode,omitempty"`

	// The software version used to calculate this transaction.
	SoftwareVersion string `json:"softwareVersion,omitempty"`

	// The status of the transaction.
	// Example: Temporary
	// Enum: [Temporary Saved Posted Committed Cancelled Adjusted Queued PendingApproval Any]
	Status string `json:"status,omitempty"`

	// Contains a summary of tax on this transaction.
	Summary []*TransactionSummary `json:"summary"`

	// Tax date for this transaction
	// Example: 2021-12-25
	// Read Only: true
	// Format: date
	TaxDate strfmt.Date `json:"taxDate,omitempty"`

	// Contains the tax details per tax type
	// Example: [{"taxType":"SalesAndUse","totalExempt":0.05,"totalNonTaxable":0,"totalTax":0.625,"totalTaxable":100}]
	TaxDetailsByTaxType []*TaxDetailsByTaxType `json:"taxDetailsByTaxType"`

	// If a tax override was applied to this transaction, indicates the amount of tax that was requested by the customer.
	// Example: 0
	TaxOverrideAmount float64 `json:"taxOverrideAmount,omitempty"`

	// If a tax override was applied to this transaction, indicates the reason for the tax override.
	TaxOverrideReason string `json:"taxOverrideReason,omitempty"`

	// If a tax override was applied to this transaction, indicates what type of tax override was applied.
	// Example: None
	// Enum: [None TaxAmount Exemption TaxDate AccruedTaxAmount DeriveTaxable OutOfHarbor TaxAmountByTaxType]
	TaxOverrideType string `json:"taxOverrideType,omitempty"`

	// The total amount of this transaction.
	// Example: 1000
	TotalAmount float64 `json:"totalAmount,omitempty"`

	// The total amount of discounts applied to all lines within this transaction.
	// Example: 0
	TotalDiscount float64 `json:"totalDiscount,omitempty"`

	// The amount of this transaction that was exempt.
	// Example: 0
	TotalExempt float64 `json:"totalExempt,omitempty"`

	// The total tax for all lines in this transaction.
	//
	// If you used a `taxOverride` of type `taxAmount` for any lines in this transaction, this value
	// may be different than the amount of tax calculated by AvaTax.  The amount of tax calculated by
	// AvaTax will be stored in the `totalTaxCalculated` field, whereas this field will contain the
	// total tax that was charged on the transaction.
	//
	// You can compare the `totalTax` and `totalTaxCalculated` fields to check for any discrepancies
	// between an external tax calculation provider and the calculation performed by AvaTax.
	// Example: 62.5
	TotalTax float64 `json:"totalTax,omitempty"`

	// The amount of tax that AvaTax calculated for the transaction.
	//
	// If you used a `taxOverride` of type `taxAmount` for any lines in this transaction, this value
	// will represent the amount that AvaTax calculated for this transaction without applying the override.
	// The field `totalTax` will be the total amount of tax after all overrides are applied.
	//
	// You can compare the `totalTax` and `totalTaxCalculated` fields to check for any discrepancies
	// between an external tax calculation provider and the calculation performed by AvaTax.
	// Example: 62.5
	TotalTaxCalculated float64 `json:"totalTaxCalculated,omitempty"`

	// The portion of the total amount of this transaction that was taxable.
	// Example: 1000
	TotalTaxable float64 `json:"totalTaxable,omitempty"`

	// The type of the transaction.
	//
	// Transactions of type `SalesOrder`, `ReturnOrder`, and so on are temporary estimates and will not be saved.
	//
	// Transactions of type `SalesInvoice, `ReturnInvoice`, and so on are permanent transactions that can be reported to tax authorities
	// if they are in status `Committed`.
	//
	// A sales transaction represents a sale from the company to a customer.  A purchase transaction represents a purchase made by the company.
	// A return transaction represents a customer who decided to request a refund after purchasing a product from the company.  An inventory
	// transfer transaction represents goods that were moved from one location of the company to another location without changing ownership.
	// Example: SalesOrder
	// Enum: [SalesOrder SalesInvoice PurchaseOrder PurchaseInvoice ReturnOrder ReturnInvoice InventoryTransferOrder InventoryTransferInvoice ReverseChargeOrder ReverseChargeInvoice CustomsInvoice CustomsOrder Any]
	Type string `json:"type,omitempty"`

	// Custom user fields/flex fields for this transaction.
	UserDefinedFields []*TransactionUserDefinedFieldModel `json:"userDefinedFields"`

	// If this transaction was adjusted, this indicates the version number of this transaction.  Incremented each time the transaction
	// is adjusted.
	// Example: 0
	Version int32 `json:"version,omitempty"`
}

// Validate validates this transaction model
func (m *TransactionModel) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAddresses(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAdjustmentReason(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeliveryTerms(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExchangeRateEffectiveDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInvoiceMessages(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLines(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocationTypes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMessages(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateModifiedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateParameters(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePaymentDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSummary(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTaxDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTaxDetailsByTaxType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTaxOverrideType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserDefinedFields(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TransactionModel) validateAddresses(formats strfmt.Registry) error {
	if swag.IsZero(m.Addresses) { // not required
		return nil
	}

	for i := 0; i < len(m.Addresses); i++ {
		if swag.IsZero(m.Addresses[i]) { // not required
			continue
		}

		if m.Addresses[i] != nil {
			if err := m.Addresses[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("addresses" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("addresses" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var transactionModelTypeAdjustmentReasonPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["NotAdjusted","SourcingIssue","ReconciledWithGeneralLedger","ExemptCertApplied","PriceAdjusted","ProductReturned","ProductExchanged","BadDebt","Other","Offline"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		transactionModelTypeAdjustmentReasonPropEnum = append(transactionModelTypeAdjustmentReasonPropEnum, v)
	}
}

const (

	// TransactionModelAdjustmentReasonNotAdjusted captures enum value "NotAdjusted"
	TransactionModelAdjustmentReasonNotAdjusted string = "NotAdjusted"

	// TransactionModelAdjustmentReasonSourcingIssue captures enum value "SourcingIssue"
	TransactionModelAdjustmentReasonSourcingIssue string = "SourcingIssue"

	// TransactionModelAdjustmentReasonReconciledWithGeneralLedger captures enum value "ReconciledWithGeneralLedger"
	TransactionModelAdjustmentReasonReconciledWithGeneralLedger string = "ReconciledWithGeneralLedger"

	// TransactionModelAdjustmentReasonExemptCertApplied captures enum value "ExemptCertApplied"
	TransactionModelAdjustmentReasonExemptCertApplied string = "ExemptCertApplied"

	// TransactionModelAdjustmentReasonPriceAdjusted captures enum value "PriceAdjusted"
	TransactionModelAdjustmentReasonPriceAdjusted string = "PriceAdjusted"

	// TransactionModelAdjustmentReasonProductReturned captures enum value "ProductReturned"
	TransactionModelAdjustmentReasonProductReturned string = "ProductReturned"

	// TransactionModelAdjustmentReasonProductExchanged captures enum value "ProductExchanged"
	TransactionModelAdjustmentReasonProductExchanged string = "ProductExchanged"

	// TransactionModelAdjustmentReasonBadDebt captures enum value "BadDebt"
	TransactionModelAdjustmentReasonBadDebt string = "BadDebt"

	// TransactionModelAdjustmentReasonOther captures enum value "Other"
	TransactionModelAdjustmentReasonOther string = "Other"

	// TransactionModelAdjustmentReasonOffline captures enum value "Offline"
	TransactionModelAdjustmentReasonOffline string = "Offline"
)

// prop value enum
func (m *TransactionModel) validateAdjustmentReasonEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, transactionModelTypeAdjustmentReasonPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TransactionModel) validateAdjustmentReason(formats strfmt.Registry) error {
	if swag.IsZero(m.AdjustmentReason) { // not required
		return nil
	}

	// value enum
	if err := m.validateAdjustmentReasonEnum("adjustmentReason", "body", m.AdjustmentReason); err != nil {
		return err
	}

	return nil
}

func (m *TransactionModel) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(m.Country) { // not required
		return nil
	}

	if err := validate.MinLength("country", "body", m.Country, 2); err != nil {
		return err
	}

	if err := validate.MaxLength("country", "body", m.Country, 2); err != nil {
		return err
	}

	return nil
}

func (m *TransactionModel) validateDate(formats strfmt.Registry) error {
	if swag.IsZero(m.Date) { // not required
		return nil
	}

	if err := validate.FormatOf("date", "body", "date", m.Date.String(), formats); err != nil {
		return err
	}

	return nil
}

var transactionModelTypeDeliveryTermsPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["DAP","DDP"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		transactionModelTypeDeliveryTermsPropEnum = append(transactionModelTypeDeliveryTermsPropEnum, v)
	}
}

const (

	// TransactionModelDeliveryTermsDAP captures enum value "DAP"
	TransactionModelDeliveryTermsDAP string = "DAP"

	// TransactionModelDeliveryTermsDDP captures enum value "DDP"
	TransactionModelDeliveryTermsDDP string = "DDP"
)

// prop value enum
func (m *TransactionModel) validateDeliveryTermsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, transactionModelTypeDeliveryTermsPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TransactionModel) validateDeliveryTerms(formats strfmt.Registry) error {
	if swag.IsZero(m.DeliveryTerms) { // not required
		return nil
	}

	// value enum
	if err := m.validateDeliveryTermsEnum("deliveryTerms", "body", m.DeliveryTerms); err != nil {
		return err
	}

	return nil
}

func (m *TransactionModel) validateExchangeRateEffectiveDate(formats strfmt.Registry) error {
	if swag.IsZero(m.ExchangeRateEffectiveDate) { // not required
		return nil
	}

	if err := validate.FormatOf("exchangeRateEffectiveDate", "body", "date", m.ExchangeRateEffectiveDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *TransactionModel) validateInvoiceMessages(formats strfmt.Registry) error {
	if swag.IsZero(m.InvoiceMessages) { // not required
		return nil
	}

	for i := 0; i < len(m.InvoiceMessages); i++ {
		if swag.IsZero(m.InvoiceMessages[i]) { // not required
			continue
		}

		if m.InvoiceMessages[i] != nil {
			if err := m.InvoiceMessages[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("invoiceMessages" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("invoiceMessages" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TransactionModel) validateLines(formats strfmt.Registry) error {
	if swag.IsZero(m.Lines) { // not required
		return nil
	}

	for i := 0; i < len(m.Lines); i++ {
		if swag.IsZero(m.Lines[i]) { // not required
			continue
		}

		if m.Lines[i] != nil {
			if err := m.Lines[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("lines" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("lines" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TransactionModel) validateLocationTypes(formats strfmt.Registry) error {
	if swag.IsZero(m.LocationTypes) { // not required
		return nil
	}

	for i := 0; i < len(m.LocationTypes); i++ {
		if swag.IsZero(m.LocationTypes[i]) { // not required
			continue
		}

		if m.LocationTypes[i] != nil {
			if err := m.LocationTypes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("locationTypes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("locationTypes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TransactionModel) validateMessages(formats strfmt.Registry) error {
	if swag.IsZero(m.Messages) { // not required
		return nil
	}

	for i := 0; i < len(m.Messages); i++ {
		if swag.IsZero(m.Messages[i]) { // not required
			continue
		}

		if m.Messages[i] != nil {
			if err := m.Messages[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("messages" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("messages" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TransactionModel) validateModifiedDate(formats strfmt.Registry) error {
	if swag.IsZero(m.ModifiedDate) { // not required
		return nil
	}

	if err := validate.FormatOf("modifiedDate", "body", "date-time", m.ModifiedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *TransactionModel) validateParameters(formats strfmt.Registry) error {
	if swag.IsZero(m.Parameters) { // not required
		return nil
	}

	for i := 0; i < len(m.Parameters); i++ {
		if swag.IsZero(m.Parameters[i]) { // not required
			continue
		}

		if m.Parameters[i] != nil {
			if err := m.Parameters[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("parameters" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("parameters" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TransactionModel) validatePaymentDate(formats strfmt.Registry) error {
	if swag.IsZero(m.PaymentDate) { // not required
		return nil
	}

	if err := validate.FormatOf("paymentDate", "body", "date", m.PaymentDate.String(), formats); err != nil {
		return err
	}

	return nil
}

var transactionModelTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Temporary","Saved","Posted","Committed","Cancelled","Adjusted","Queued","PendingApproval","Any"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		transactionModelTypeStatusPropEnum = append(transactionModelTypeStatusPropEnum, v)
	}
}

const (

	// TransactionModelStatusTemporary captures enum value "Temporary"
	TransactionModelStatusTemporary string = "Temporary"

	// TransactionModelStatusSaved captures enum value "Saved"
	TransactionModelStatusSaved string = "Saved"

	// TransactionModelStatusPosted captures enum value "Posted"
	TransactionModelStatusPosted string = "Posted"

	// TransactionModelStatusCommitted captures enum value "Committed"
	TransactionModelStatusCommitted string = "Committed"

	// TransactionModelStatusCancelled captures enum value "Cancelled"
	TransactionModelStatusCancelled string = "Cancelled"

	// TransactionModelStatusAdjusted captures enum value "Adjusted"
	TransactionModelStatusAdjusted string = "Adjusted"

	// TransactionModelStatusQueued captures enum value "Queued"
	TransactionModelStatusQueued string = "Queued"

	// TransactionModelStatusPendingApproval captures enum value "PendingApproval"
	TransactionModelStatusPendingApproval string = "PendingApproval"

	// TransactionModelStatusAny captures enum value "Any"
	TransactionModelStatusAny string = "Any"
)

// prop value enum
func (m *TransactionModel) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, transactionModelTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TransactionModel) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *TransactionModel) validateSummary(formats strfmt.Registry) error {
	if swag.IsZero(m.Summary) { // not required
		return nil
	}

	for i := 0; i < len(m.Summary); i++ {
		if swag.IsZero(m.Summary[i]) { // not required
			continue
		}

		if m.Summary[i] != nil {
			if err := m.Summary[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("summary" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("summary" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TransactionModel) validateTaxDate(formats strfmt.Registry) error {
	if swag.IsZero(m.TaxDate) { // not required
		return nil
	}

	if err := validate.FormatOf("taxDate", "body", "date", m.TaxDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *TransactionModel) validateTaxDetailsByTaxType(formats strfmt.Registry) error {
	if swag.IsZero(m.TaxDetailsByTaxType) { // not required
		return nil
	}

	for i := 0; i < len(m.TaxDetailsByTaxType); i++ {
		if swag.IsZero(m.TaxDetailsByTaxType[i]) { // not required
			continue
		}

		if m.TaxDetailsByTaxType[i] != nil {
			if err := m.TaxDetailsByTaxType[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taxDetailsByTaxType" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("taxDetailsByTaxType" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var transactionModelTypeTaxOverrideTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["None","TaxAmount","Exemption","TaxDate","AccruedTaxAmount","DeriveTaxable","OutOfHarbor","TaxAmountByTaxType"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		transactionModelTypeTaxOverrideTypePropEnum = append(transactionModelTypeTaxOverrideTypePropEnum, v)
	}
}

const (

	// TransactionModelTaxOverrideTypeNone captures enum value "None"
	TransactionModelTaxOverrideTypeNone string = "None"

	// TransactionModelTaxOverrideTypeTaxAmount captures enum value "TaxAmount"
	TransactionModelTaxOverrideTypeTaxAmount string = "TaxAmount"

	// TransactionModelTaxOverrideTypeExemption captures enum value "Exemption"
	TransactionModelTaxOverrideTypeExemption string = "Exemption"

	// TransactionModelTaxOverrideTypeTaxDate captures enum value "TaxDate"
	TransactionModelTaxOverrideTypeTaxDate string = "TaxDate"

	// TransactionModelTaxOverrideTypeAccruedTaxAmount captures enum value "AccruedTaxAmount"
	TransactionModelTaxOverrideTypeAccruedTaxAmount string = "AccruedTaxAmount"

	// TransactionModelTaxOverrideTypeDeriveTaxable captures enum value "DeriveTaxable"
	TransactionModelTaxOverrideTypeDeriveTaxable string = "DeriveTaxable"

	// TransactionModelTaxOverrideTypeOutOfHarbor captures enum value "OutOfHarbor"
	TransactionModelTaxOverrideTypeOutOfHarbor string = "OutOfHarbor"

	// TransactionModelTaxOverrideTypeTaxAmountByTaxType captures enum value "TaxAmountByTaxType"
	TransactionModelTaxOverrideTypeTaxAmountByTaxType string = "TaxAmountByTaxType"
)

// prop value enum
func (m *TransactionModel) validateTaxOverrideTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, transactionModelTypeTaxOverrideTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TransactionModel) validateTaxOverrideType(formats strfmt.Registry) error {
	if swag.IsZero(m.TaxOverrideType) { // not required
		return nil
	}

	// value enum
	if err := m.validateTaxOverrideTypeEnum("taxOverrideType", "body", m.TaxOverrideType); err != nil {
		return err
	}

	return nil
}

var transactionModelTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SalesOrder","SalesInvoice","PurchaseOrder","PurchaseInvoice","ReturnOrder","ReturnInvoice","InventoryTransferOrder","InventoryTransferInvoice","ReverseChargeOrder","ReverseChargeInvoice","CustomsInvoice","CustomsOrder","Any"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		transactionModelTypeTypePropEnum = append(transactionModelTypeTypePropEnum, v)
	}
}

const (

	// TransactionModelTypeSalesOrder captures enum value "SalesOrder"
	TransactionModelTypeSalesOrder string = "SalesOrder"

	// TransactionModelTypeSalesInvoice captures enum value "SalesInvoice"
	TransactionModelTypeSalesInvoice string = "SalesInvoice"

	// TransactionModelTypePurchaseOrder captures enum value "PurchaseOrder"
	TransactionModelTypePurchaseOrder string = "PurchaseOrder"

	// TransactionModelTypePurchaseInvoice captures enum value "PurchaseInvoice"
	TransactionModelTypePurchaseInvoice string = "PurchaseInvoice"

	// TransactionModelTypeReturnOrder captures enum value "ReturnOrder"
	TransactionModelTypeReturnOrder string = "ReturnOrder"

	// TransactionModelTypeReturnInvoice captures enum value "ReturnInvoice"
	TransactionModelTypeReturnInvoice string = "ReturnInvoice"

	// TransactionModelTypeInventoryTransferOrder captures enum value "InventoryTransferOrder"
	TransactionModelTypeInventoryTransferOrder string = "InventoryTransferOrder"

	// TransactionModelTypeInventoryTransferInvoice captures enum value "InventoryTransferInvoice"
	TransactionModelTypeInventoryTransferInvoice string = "InventoryTransferInvoice"

	// TransactionModelTypeReverseChargeOrder captures enum value "ReverseChargeOrder"
	TransactionModelTypeReverseChargeOrder string = "ReverseChargeOrder"

	// TransactionModelTypeReverseChargeInvoice captures enum value "ReverseChargeInvoice"
	TransactionModelTypeReverseChargeInvoice string = "ReverseChargeInvoice"

	// TransactionModelTypeCustomsInvoice captures enum value "CustomsInvoice"
	TransactionModelTypeCustomsInvoice string = "CustomsInvoice"

	// TransactionModelTypeCustomsOrder captures enum value "CustomsOrder"
	TransactionModelTypeCustomsOrder string = "CustomsOrder"

	// TransactionModelTypeAny captures enum value "Any"
	TransactionModelTypeAny string = "Any"
)

// prop value enum
func (m *TransactionModel) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, transactionModelTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TransactionModel) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

func (m *TransactionModel) validateUserDefinedFields(formats strfmt.Registry) error {
	if swag.IsZero(m.UserDefinedFields) { // not required
		return nil
	}

	for i := 0; i < len(m.UserDefinedFields); i++ {
		if swag.IsZero(m.UserDefinedFields[i]) { // not required
			continue
		}

		if m.UserDefinedFields[i] != nil {
			if err := m.UserDefinedFields[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("userDefinedFields" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("userDefinedFields" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this transaction model based on the context it is used
func (m *TransactionModel) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAddresses(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInvoiceMessages(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLines(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLocationTypes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMessages(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateModifiedDate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateModifiedUserID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateParameters(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSummary(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTaxDate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTaxDetailsByTaxType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUserDefinedFields(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TransactionModel) contextValidateAddresses(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Addresses); i++ {

		if m.Addresses[i] != nil {
			if err := m.Addresses[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("addresses" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("addresses" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TransactionModel) contextValidateCode(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "code", "body", string(m.Code)); err != nil {
		return err
	}

	return nil
}

func (m *TransactionModel) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "id", "body", int64(m.ID)); err != nil {
		return err
	}

	return nil
}

func (m *TransactionModel) contextValidateInvoiceMessages(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.InvoiceMessages); i++ {

		if m.InvoiceMessages[i] != nil {
			if err := m.InvoiceMessages[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("invoiceMessages" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("invoiceMessages" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TransactionModel) contextValidateLines(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Lines); i++ {

		if m.Lines[i] != nil {
			if err := m.Lines[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("lines" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("lines" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TransactionModel) contextValidateLocationTypes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.LocationTypes); i++ {

		if m.LocationTypes[i] != nil {
			if err := m.LocationTypes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("locationTypes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("locationTypes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TransactionModel) contextValidateMessages(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Messages); i++ {

		if m.Messages[i] != nil {
			if err := m.Messages[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("messages" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("messages" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TransactionModel) contextValidateModifiedDate(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "modifiedDate", "body", strfmt.DateTime(m.ModifiedDate)); err != nil {
		return err
	}

	return nil
}

func (m *TransactionModel) contextValidateModifiedUserID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "modifiedUserId", "body", int32(m.ModifiedUserID)); err != nil {
		return err
	}

	return nil
}

func (m *TransactionModel) contextValidateParameters(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Parameters); i++ {

		if m.Parameters[i] != nil {
			if err := m.Parameters[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("parameters" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("parameters" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TransactionModel) contextValidateSummary(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Summary); i++ {

		if m.Summary[i] != nil {
			if err := m.Summary[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("summary" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("summary" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TransactionModel) contextValidateTaxDate(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "taxDate", "body", strfmt.Date(m.TaxDate)); err != nil {
		return err
	}

	return nil
}

func (m *TransactionModel) contextValidateTaxDetailsByTaxType(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.TaxDetailsByTaxType); i++ {

		if m.TaxDetailsByTaxType[i] != nil {
			if err := m.TaxDetailsByTaxType[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taxDetailsByTaxType" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("taxDetailsByTaxType" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TransactionModel) contextValidateUserDefinedFields(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.UserDefinedFields); i++ {

		if m.UserDefinedFields[i] != nil {
			if err := m.UserDefinedFields[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("userDefinedFields" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("userDefinedFields" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *TransactionModel) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TransactionModel) UnmarshalBinary(b []byte) error {
	var res TransactionModel
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
